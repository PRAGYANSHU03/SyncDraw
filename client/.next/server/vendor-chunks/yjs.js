"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/yjs";
exports.ids = ["vendor-chunks/yjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/yjs/dist/yjs.mjs":
/*!***************************************!*\
  !*** ./node_modules/yjs/dist/yjs.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbsolutePosition: () => (/* binding */ AbsolutePosition),\n/* harmony export */   AbstractConnector: () => (/* binding */ AbstractConnector),\n/* harmony export */   AbstractStruct: () => (/* binding */ AbstractStruct),\n/* harmony export */   AbstractType: () => (/* binding */ AbstractType),\n/* harmony export */   Array: () => (/* binding */ YArray),\n/* harmony export */   ContentAny: () => (/* binding */ ContentAny),\n/* harmony export */   ContentBinary: () => (/* binding */ ContentBinary),\n/* harmony export */   ContentDeleted: () => (/* binding */ ContentDeleted),\n/* harmony export */   ContentDoc: () => (/* binding */ ContentDoc),\n/* harmony export */   ContentEmbed: () => (/* binding */ ContentEmbed),\n/* harmony export */   ContentFormat: () => (/* binding */ ContentFormat),\n/* harmony export */   ContentJSON: () => (/* binding */ ContentJSON),\n/* harmony export */   ContentString: () => (/* binding */ ContentString),\n/* harmony export */   ContentType: () => (/* binding */ ContentType),\n/* harmony export */   Doc: () => (/* binding */ Doc),\n/* harmony export */   GC: () => (/* binding */ GC),\n/* harmony export */   ID: () => (/* binding */ ID),\n/* harmony export */   Item: () => (/* binding */ Item),\n/* harmony export */   Map: () => (/* binding */ YMap),\n/* harmony export */   PermanentUserData: () => (/* binding */ PermanentUserData),\n/* harmony export */   RelativePosition: () => (/* binding */ RelativePosition),\n/* harmony export */   Skip: () => (/* binding */ Skip),\n/* harmony export */   Snapshot: () => (/* binding */ Snapshot),\n/* harmony export */   Text: () => (/* binding */ YText),\n/* harmony export */   Transaction: () => (/* binding */ Transaction),\n/* harmony export */   UndoManager: () => (/* binding */ UndoManager),\n/* harmony export */   UpdateDecoderV1: () => (/* binding */ UpdateDecoderV1),\n/* harmony export */   UpdateDecoderV2: () => (/* binding */ UpdateDecoderV2),\n/* harmony export */   UpdateEncoderV1: () => (/* binding */ UpdateEncoderV1),\n/* harmony export */   UpdateEncoderV2: () => (/* binding */ UpdateEncoderV2),\n/* harmony export */   XmlElement: () => (/* binding */ YXmlElement),\n/* harmony export */   XmlFragment: () => (/* binding */ YXmlFragment),\n/* harmony export */   XmlHook: () => (/* binding */ YXmlHook),\n/* harmony export */   XmlText: () => (/* binding */ YXmlText),\n/* harmony export */   YArrayEvent: () => (/* binding */ YArrayEvent),\n/* harmony export */   YEvent: () => (/* binding */ YEvent),\n/* harmony export */   YMapEvent: () => (/* binding */ YMapEvent),\n/* harmony export */   YTextEvent: () => (/* binding */ YTextEvent),\n/* harmony export */   YXmlEvent: () => (/* binding */ YXmlEvent),\n/* harmony export */   applyUpdate: () => (/* binding */ applyUpdate),\n/* harmony export */   applyUpdateV2: () => (/* binding */ applyUpdateV2),\n/* harmony export */   cleanupYTextFormatting: () => (/* binding */ cleanupYTextFormatting),\n/* harmony export */   compareIDs: () => (/* binding */ compareIDs),\n/* harmony export */   compareRelativePositions: () => (/* binding */ compareRelativePositions),\n/* harmony export */   convertUpdateFormatV1ToV2: () => (/* binding */ convertUpdateFormatV1ToV2),\n/* harmony export */   convertUpdateFormatV2ToV1: () => (/* binding */ convertUpdateFormatV2ToV1),\n/* harmony export */   createAbsolutePositionFromRelativePosition: () => (/* binding */ createAbsolutePositionFromRelativePosition),\n/* harmony export */   createDeleteSet: () => (/* binding */ createDeleteSet),\n/* harmony export */   createDeleteSetFromStructStore: () => (/* binding */ createDeleteSetFromStructStore),\n/* harmony export */   createDocFromSnapshot: () => (/* binding */ createDocFromSnapshot),\n/* harmony export */   createID: () => (/* binding */ createID),\n/* harmony export */   createRelativePositionFromJSON: () => (/* binding */ createRelativePositionFromJSON),\n/* harmony export */   createRelativePositionFromTypeIndex: () => (/* binding */ createRelativePositionFromTypeIndex),\n/* harmony export */   createSnapshot: () => (/* binding */ createSnapshot),\n/* harmony export */   decodeRelativePosition: () => (/* binding */ decodeRelativePosition),\n/* harmony export */   decodeSnapshot: () => (/* binding */ decodeSnapshot),\n/* harmony export */   decodeSnapshotV2: () => (/* binding */ decodeSnapshotV2),\n/* harmony export */   decodeStateVector: () => (/* binding */ decodeStateVector),\n/* harmony export */   decodeUpdate: () => (/* binding */ decodeUpdate),\n/* harmony export */   decodeUpdateV2: () => (/* binding */ decodeUpdateV2),\n/* harmony export */   diffUpdate: () => (/* binding */ diffUpdate),\n/* harmony export */   diffUpdateV2: () => (/* binding */ diffUpdateV2),\n/* harmony export */   emptySnapshot: () => (/* binding */ emptySnapshot),\n/* harmony export */   encodeRelativePosition: () => (/* binding */ encodeRelativePosition),\n/* harmony export */   encodeSnapshot: () => (/* binding */ encodeSnapshot),\n/* harmony export */   encodeSnapshotV2: () => (/* binding */ encodeSnapshotV2),\n/* harmony export */   encodeStateAsUpdate: () => (/* binding */ encodeStateAsUpdate),\n/* harmony export */   encodeStateAsUpdateV2: () => (/* binding */ encodeStateAsUpdateV2),\n/* harmony export */   encodeStateVector: () => (/* binding */ encodeStateVector),\n/* harmony export */   encodeStateVectorFromUpdate: () => (/* binding */ encodeStateVectorFromUpdate),\n/* harmony export */   encodeStateVectorFromUpdateV2: () => (/* binding */ encodeStateVectorFromUpdateV2),\n/* harmony export */   equalDeleteSets: () => (/* binding */ equalDeleteSets),\n/* harmony export */   equalSnapshots: () => (/* binding */ equalSnapshots),\n/* harmony export */   findIndexSS: () => (/* binding */ findIndexSS),\n/* harmony export */   findRootTypeKey: () => (/* binding */ findRootTypeKey),\n/* harmony export */   getItem: () => (/* binding */ getItem),\n/* harmony export */   getItemCleanEnd: () => (/* binding */ getItemCleanEnd),\n/* harmony export */   getItemCleanStart: () => (/* binding */ getItemCleanStart),\n/* harmony export */   getState: () => (/* binding */ getState),\n/* harmony export */   getTypeChildren: () => (/* binding */ getTypeChildren),\n/* harmony export */   isDeleted: () => (/* binding */ isDeleted),\n/* harmony export */   isParentOf: () => (/* binding */ isParentOf),\n/* harmony export */   iterateDeletedStructs: () => (/* binding */ iterateDeletedStructs),\n/* harmony export */   logType: () => (/* binding */ logType),\n/* harmony export */   logUpdate: () => (/* binding */ logUpdate),\n/* harmony export */   logUpdateV2: () => (/* binding */ logUpdateV2),\n/* harmony export */   mergeDeleteSets: () => (/* binding */ mergeDeleteSets),\n/* harmony export */   mergeUpdates: () => (/* binding */ mergeUpdates),\n/* harmony export */   mergeUpdatesV2: () => (/* binding */ mergeUpdatesV2),\n/* harmony export */   obfuscateUpdate: () => (/* binding */ obfuscateUpdate),\n/* harmony export */   obfuscateUpdateV2: () => (/* binding */ obfuscateUpdateV2),\n/* harmony export */   parseUpdateMeta: () => (/* binding */ parseUpdateMeta),\n/* harmony export */   parseUpdateMetaV2: () => (/* binding */ parseUpdateMetaV2),\n/* harmony export */   readUpdate: () => (/* binding */ readUpdate),\n/* harmony export */   readUpdateV2: () => (/* binding */ readUpdateV2),\n/* harmony export */   relativePositionToJSON: () => (/* binding */ relativePositionToJSON),\n/* harmony export */   snapshot: () => (/* binding */ snapshot),\n/* harmony export */   snapshotContainsUpdate: () => (/* binding */ snapshotContainsUpdate),\n/* harmony export */   transact: () => (/* binding */ transact),\n/* harmony export */   tryGc: () => (/* binding */ tryGc),\n/* harmony export */   typeListToArraySnapshot: () => (/* binding */ typeListToArraySnapshot),\n/* harmony export */   typeMapGetAllSnapshot: () => (/* binding */ typeMapGetAllSnapshot),\n/* harmony export */   typeMapGetSnapshot: () => (/* binding */ typeMapGetSnapshot)\n/* harmony export */ });\n/* harmony import */ var lib0_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/observable */ \"(ssr)/./node_modules/lib0/observable.js\");\n/* harmony import */ var lib0_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/array */ \"(ssr)/./node_modules/lib0/array.js\");\n/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/math */ \"(ssr)/./node_modules/lib0/math.js\");\n/* harmony import */ var lib0_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/map */ \"(ssr)/./node_modules/lib0/map.js\");\n/* harmony import */ var lib0_encoding__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/encoding */ \"(ssr)/./node_modules/lib0/encoding.js\");\n/* harmony import */ var lib0_decoding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/decoding */ \"(ssr)/./node_modules/lib0/decoding.js\");\n/* harmony import */ var lib0_random__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lib0/random */ \"(ssr)/./node_modules/lib0/random.js\");\n/* harmony import */ var lib0_promise__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lib0/promise */ \"(ssr)/./node_modules/lib0/promise.js\");\n/* harmony import */ var lib0_buffer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lib0/buffer */ \"(ssr)/./node_modules/lib0/buffer.js\");\n/* harmony import */ var lib0_error__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lib0/error */ \"(ssr)/./node_modules/lib0/error.js\");\n/* harmony import */ var lib0_binary__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lib0/binary */ \"(ssr)/./node_modules/lib0/binary.js\");\n/* harmony import */ var lib0_function__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lib0/function */ \"(ssr)/./node_modules/lib0/function.js\");\n/* harmony import */ var lib0_set__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lib0/set */ \"(ssr)/./node_modules/lib0/set.js\");\n/* harmony import */ var lib0_logging__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lib0/logging */ \"(ssr)/./node_modules/lib0/logging.node.js\");\n/* harmony import */ var lib0_logging__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! lib0/logging */ \"(ssr)/./node_modules/lib0/logging.common.js\");\n/* harmony import */ var lib0_time__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! lib0/time */ \"(ssr)/./node_modules/lib0/time.js\");\n/* harmony import */ var lib0_string__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! lib0/string */ \"(ssr)/./node_modules/lib0/string.js\");\n/* harmony import */ var lib0_iterator__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! lib0/iterator */ \"(ssr)/./node_modules/lib0/iterator.js\");\n/* harmony import */ var lib0_object__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! lib0/object */ \"(ssr)/./node_modules/lib0/object.js\");\n/* harmony import */ var lib0_environment__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! lib0/environment */ \"(ssr)/./node_modules/lib0/environment.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * This is an abstract interface that all Connectors should implement to keep them interchangeable.\n *\n * @note This interface is experimental and it is not advised to actually inherit this class.\n *       It just serves as typing information.\n *\n * @extends {ObservableV2<any>}\n */ class AbstractConnector extends lib0_observable__WEBPACK_IMPORTED_MODULE_0__.ObservableV2 {\n    /**\n   * @param {Doc} ydoc\n   * @param {any} awareness\n   */ constructor(ydoc, awareness){\n        super();\n        this.doc = ydoc;\n        this.awareness = awareness;\n    }\n}\nclass DeleteItem {\n    /**\n   * @param {number} clock\n   * @param {number} len\n   */ constructor(clock, len){\n        /**\n     * @type {number}\n     */ this.clock = clock;\n        /**\n     * @type {number}\n     */ this.len = len;\n    }\n}\n/**\n * We no longer maintain a DeleteStore. DeleteSet is a temporary object that is created when needed.\n * - When created in a transaction, it must only be accessed after sorting, and merging\n *   - This DeleteSet is send to other clients\n * - We do not create a DeleteSet when we send a sync message. The DeleteSet message is created directly from StructStore\n * - We read a DeleteSet as part of a sync/update message. In this case the DeleteSet is already sorted and merged.\n */ class DeleteSet {\n    constructor(){\n        /**\n     * @type {Map<number,Array<DeleteItem>>}\n     */ this.clients = new Map();\n    }\n}\n/**\n * Iterate over all structs that the DeleteSet gc's.\n *\n * @param {Transaction} transaction\n * @param {DeleteSet} ds\n * @param {function(GC|Item):void} f\n *\n * @function\n */ const iterateDeletedStructs = (transaction, ds, f)=>ds.clients.forEach((deletes, clientid)=>{\n        const structs = /** @type {Array<GC|Item>} */ transaction.doc.store.clients.get(clientid);\n        if (structs != null) {\n            const lastStruct = structs[structs.length - 1];\n            const clockState = lastStruct.id.clock + lastStruct.length;\n            for(let i = 0, del = deletes[i]; i < deletes.length && del.clock < clockState; del = deletes[++i]){\n                iterateStructs(transaction, structs, del.clock, del.len, f);\n            }\n        }\n    });\n/**\n * @param {Array<DeleteItem>} dis\n * @param {number} clock\n * @return {number|null}\n *\n * @private\n * @function\n */ const findIndexDS = (dis, clock)=>{\n    let left = 0;\n    let right = dis.length - 1;\n    while(left <= right){\n        const midindex = lib0_math__WEBPACK_IMPORTED_MODULE_1__.floor((left + right) / 2);\n        const mid = dis[midindex];\n        const midclock = mid.clock;\n        if (midclock <= clock) {\n            if (clock < midclock + mid.len) {\n                return midindex;\n            }\n            left = midindex + 1;\n        } else {\n            right = midindex - 1;\n        }\n    }\n    return null;\n};\n/**\n * @param {DeleteSet} ds\n * @param {ID} id\n * @return {boolean}\n *\n * @private\n * @function\n */ const isDeleted = (ds, id)=>{\n    const dis = ds.clients.get(id.client);\n    return dis !== undefined && findIndexDS(dis, id.clock) !== null;\n};\n/**\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */ const sortAndMergeDeleteSet = (ds)=>{\n    ds.clients.forEach((dels)=>{\n        dels.sort((a, b)=>a.clock - b.clock);\n        // merge items without filtering or splicing the array\n        // i is the current pointer\n        // j refers to the current insert position for the pointed item\n        // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]\n        let i, j;\n        for(i = 1, j = 1; i < dels.length; i++){\n            const left = dels[j - 1];\n            const right = dels[i];\n            if (left.clock + left.len >= right.clock) {\n                left.len = lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(left.len, right.clock + right.len - left.clock);\n            } else {\n                if (j < i) {\n                    dels[j] = right;\n                }\n                j++;\n            }\n        }\n        dels.length = j;\n    });\n};\n/**\n * @param {Array<DeleteSet>} dss\n * @return {DeleteSet} A fresh DeleteSet\n */ const mergeDeleteSets = (dss)=>{\n    const merged = new DeleteSet();\n    for(let dssI = 0; dssI < dss.length; dssI++){\n        dss[dssI].clients.forEach((delsLeft, client)=>{\n            if (!merged.clients.has(client)) {\n                // Write all missing keys from current ds and all following.\n                // If merged already contains `client` current ds has already been added.\n                /**\n         * @type {Array<DeleteItem>}\n         */ const dels = delsLeft.slice();\n                for(let i = dssI + 1; i < dss.length; i++){\n                    lib0_array__WEBPACK_IMPORTED_MODULE_2__.appendTo(dels, dss[i].clients.get(client) || []);\n                }\n                merged.clients.set(client, dels);\n            }\n        });\n    }\n    sortAndMergeDeleteSet(merged);\n    return merged;\n};\n/**\n * @param {DeleteSet} ds\n * @param {number} client\n * @param {number} clock\n * @param {number} length\n *\n * @private\n * @function\n */ const addToDeleteSet = (ds, client, clock, length)=>{\n    lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(ds.clients, client, ()=>/** @type {Array<DeleteItem>} */ []).push(new DeleteItem(clock, length));\n};\nconst createDeleteSet = ()=>new DeleteSet();\n/**\n * @param {StructStore} ss\n * @return {DeleteSet} Merged and sorted DeleteSet\n *\n * @private\n * @function\n */ const createDeleteSetFromStructStore = (ss)=>{\n    const ds = createDeleteSet();\n    ss.clients.forEach((structs, client)=>{\n        /**\n     * @type {Array<DeleteItem>}\n     */ const dsitems = [];\n        for(let i = 0; i < structs.length; i++){\n            const struct = structs[i];\n            if (struct.deleted) {\n                const clock = struct.id.clock;\n                let len = struct.length;\n                if (i + 1 < structs.length) {\n                    for(let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1]){\n                        len += next.length;\n                    }\n                }\n                dsitems.push(new DeleteItem(clock, len));\n            }\n        }\n        if (dsitems.length > 0) {\n            ds.clients.set(client, dsitems);\n        }\n    });\n    return ds;\n};\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */ const writeDeleteSet = (encoder, ds)=>{\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, ds.clients.size);\n    // Ensure that the delete set is written in a deterministic order\n    lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(ds.clients.entries()).sort((a, b)=>b[0] - a[0]).forEach(([client, dsitems])=>{\n        encoder.resetDsCurVal();\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, client);\n        const len = dsitems.length;\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, len);\n        for(let i = 0; i < len; i++){\n            const item = dsitems[i];\n            encoder.writeDsClock(item.clock);\n            encoder.writeDsLen(item.len);\n        }\n    });\n};\n/**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {DeleteSet}\n *\n * @private\n * @function\n */ const readDeleteSet = (decoder)=>{\n    const ds = new DeleteSet();\n    const numClients = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    for(let i = 0; i < numClients; i++){\n        decoder.resetDsCurVal();\n        const client = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        const numberOfDeletes = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        if (numberOfDeletes > 0) {\n            const dsField = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(ds.clients, client, ()=>/** @type {Array<DeleteItem>} */ []);\n            for(let i = 0; i < numberOfDeletes; i++){\n                dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));\n            }\n        }\n    }\n    return ds;\n};\n/**\n * @todo YDecoder also contains references to String and other Decoders. Would make sense to exchange YDecoder.toUint8Array for YDecoder.DsToUint8Array()..\n */ /**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @return {Uint8Array|null} Returns a v2 update containing all deletes that couldn't be applied yet; or null if all deletes were applied successfully.\n *\n * @private\n * @function\n */ const readAndApplyDeleteSet = (decoder, transaction, store)=>{\n    const unappliedDS = new DeleteSet();\n    const numClients = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    for(let i = 0; i < numClients; i++){\n        decoder.resetDsCurVal();\n        const client = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        const numberOfDeletes = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        const structs = store.clients.get(client) || [];\n        const state = getState(store, client);\n        for(let i = 0; i < numberOfDeletes; i++){\n            const clock = decoder.readDsClock();\n            const clockEnd = clock + decoder.readDsLen();\n            if (clock < state) {\n                if (state < clockEnd) {\n                    addToDeleteSet(unappliedDS, client, state, clockEnd - state);\n                }\n                let index = findIndexSS(structs, clock);\n                /**\n         * We can ignore the case of GC and Delete structs, because we are going to skip them\n         * @type {Item}\n         */ // @ts-ignore\n                let struct = structs[index];\n                // split the first item if necessary\n                if (!struct.deleted && struct.id.clock < clock) {\n                    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n                    index++; // increase we now want to use the next struct\n                }\n                while(index < structs.length){\n                    // @ts-ignore\n                    struct = structs[index++];\n                    if (struct.id.clock < clockEnd) {\n                        if (!struct.deleted) {\n                            if (clockEnd < struct.id.clock + struct.length) {\n                                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));\n                            }\n                            struct.delete(transaction);\n                        }\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);\n            }\n        }\n    }\n    if (unappliedDS.clients.size > 0) {\n        const ds = new UpdateEncoderV2();\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(ds.restEncoder, 0); // encode 0 structs\n        writeDeleteSet(ds, unappliedDS);\n        return ds.toUint8Array();\n    }\n    return null;\n};\n/**\n * @param {DeleteSet} ds1\n * @param {DeleteSet} ds2\n */ const equalDeleteSets = (ds1, ds2)=>{\n    if (ds1.clients.size !== ds2.clients.size) return false;\n    for (const [client, deleteItems1] of ds1.clients.entries()){\n        const deleteItems2 = /** @type {Array<import('../internals.js').DeleteItem>} */ ds2.clients.get(client);\n        if (deleteItems2 === undefined || deleteItems1.length !== deleteItems2.length) return false;\n        for(let i = 0; i < deleteItems1.length; i++){\n            const di1 = deleteItems1[i];\n            const di2 = deleteItems2[i];\n            if (di1.clock !== di2.clock || di1.len !== di2.len) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\n/**\n * @module Y\n */ const generateNewClientId = lib0_random__WEBPACK_IMPORTED_MODULE_6__.uint32;\n/**\n * @typedef {Object} DocOpts\n * @property {boolean} [DocOpts.gc=true] Disable garbage collection (default: gc=true)\n * @property {function(Item):boolean} [DocOpts.gcFilter] Will be called before an Item is garbage collected. Return false to keep the Item.\n * @property {string} [DocOpts.guid] Define a globally unique identifier for this document\n * @property {string | null} [DocOpts.collectionid] Associate this document with a collection. This only plays a role if your provider has a concept of collection.\n * @property {any} [DocOpts.meta] Any kind of meta information you want to associate with this document. If this is a subdocument, remote peers will store the meta information as well.\n * @property {boolean} [DocOpts.autoLoad] If a subdocument, automatically load document. If this is a subdocument, remote peers will load the document as well automatically.\n * @property {boolean} [DocOpts.shouldLoad] Whether the document should be synced by the provider now. This is toggled to true when you call ydoc.load()\n */ /**\n * @typedef {Object} DocEvents\n * @property {function(Doc):void} DocEvents.destroy\n * @property {function(Doc):void} DocEvents.load\n * @property {function(boolean, Doc):void} DocEvents.sync\n * @property {function(Uint8Array, any, Doc, Transaction):void} DocEvents.update\n * @property {function(Uint8Array, any, Doc, Transaction):void} DocEvents.updateV2\n * @property {function(Doc):void} DocEvents.beforeAllTransactions\n * @property {function(Transaction, Doc):void} DocEvents.beforeTransaction\n * @property {function(Transaction, Doc):void} DocEvents.beforeObserverCalls\n * @property {function(Transaction, Doc):void} DocEvents.afterTransaction\n * @property {function(Transaction, Doc):void} DocEvents.afterTransactionCleanup\n * @property {function(Doc, Array<Transaction>):void} DocEvents.afterAllTransactions\n * @property {function({ loaded: Set<Doc>, added: Set<Doc>, removed: Set<Doc> }, Doc, Transaction):void} DocEvents.subdocs\n */ /**\n * A Yjs instance handles the state of shared data.\n * @extends ObservableV2<DocEvents>\n */ class Doc extends lib0_observable__WEBPACK_IMPORTED_MODULE_0__.ObservableV2 {\n    /**\n   * @param {DocOpts} opts configuration\n   */ constructor({ guid = lib0_random__WEBPACK_IMPORTED_MODULE_6__.uuidv4(), collectionid = null, gc = true, gcFilter = ()=>true, meta = null, autoLoad = false, shouldLoad = true } = {}){\n        super();\n        this.gc = gc;\n        this.gcFilter = gcFilter;\n        this.clientID = generateNewClientId();\n        this.guid = guid;\n        this.collectionid = collectionid;\n        /**\n     * @type {Map<string, AbstractType<YEvent<any>>>}\n     */ this.share = new Map();\n        this.store = new StructStore();\n        /**\n     * @type {Transaction | null}\n     */ this._transaction = null;\n        /**\n     * @type {Array<Transaction>}\n     */ this._transactionCleanups = [];\n        /**\n     * @type {Set<Doc>}\n     */ this.subdocs = new Set();\n        /**\n     * If this document is a subdocument - a document integrated into another document - then _item is defined.\n     * @type {Item?}\n     */ this._item = null;\n        this.shouldLoad = shouldLoad;\n        this.autoLoad = autoLoad;\n        this.meta = meta;\n        /**\n     * This is set to true when the persistence provider loaded the document from the database or when the `sync` event fires.\n     * Note that not all providers implement this feature. Provider authors are encouraged to fire the `load` event when the doc content is loaded from the database.\n     *\n     * @type {boolean}\n     */ this.isLoaded = false;\n        /**\n     * This is set to true when the connection provider has successfully synced with a backend.\n     * Note that when using peer-to-peer providers this event may not provide very useful.\n     * Also note that not all providers implement this feature. Provider authors are encouraged to fire\n     * the `sync` event when the doc has been synced (with `true` as a parameter) or if connection is\n     * lost (with false as a parameter).\n     */ this.isSynced = false;\n        this.isDestroyed = false;\n        /**\n     * Promise that resolves once the document has been loaded from a persistence provider.\n     */ this.whenLoaded = lib0_promise__WEBPACK_IMPORTED_MODULE_7__.create((resolve)=>{\n            this.on(\"load\", ()=>{\n                this.isLoaded = true;\n                resolve(this);\n            });\n        });\n        const provideSyncedPromise = ()=>lib0_promise__WEBPACK_IMPORTED_MODULE_7__.create((resolve)=>{\n                /**\n       * @param {boolean} isSynced\n       */ const eventHandler = (isSynced)=>{\n                    if (isSynced === undefined || isSynced === true) {\n                        this.off(\"sync\", eventHandler);\n                        resolve();\n                    }\n                };\n                this.on(\"sync\", eventHandler);\n            });\n        this.on(\"sync\", (isSynced)=>{\n            if (isSynced === false && this.isSynced) {\n                this.whenSynced = provideSyncedPromise();\n            }\n            this.isSynced = isSynced === undefined || isSynced === true;\n            if (this.isSynced && !this.isLoaded) {\n                this.emit(\"load\", [\n                    this\n                ]);\n            }\n        });\n        /**\n     * Promise that resolves once the document has been synced with a backend.\n     * This promise is recreated when the connection is lost.\n     * Note the documentation about the `isSynced` property.\n     */ this.whenSynced = provideSyncedPromise();\n    }\n    /**\n   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).\n   *\n   * `load()` might be used in the future to request any provider to load the most current data.\n   *\n   * It is safe to call `load()` multiple times.\n   */ load() {\n        const item = this._item;\n        if (item !== null && !this.shouldLoad) {\n            transact(/** @type {any} */ item.parent.doc, (transaction)=>{\n                transaction.subdocsLoaded.add(this);\n            }, null, true);\n        }\n        this.shouldLoad = true;\n    }\n    getSubdocs() {\n        return this.subdocs;\n    }\n    getSubdocGuids() {\n        return new Set(lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(this.subdocs).map((doc)=>doc.guid));\n    }\n    /**\n   * Changes that happen inside of a transaction are bundled. This means that\n   * the observer fires _after_ the transaction is finished and that all changes\n   * that happened inside of the transaction are sent as one message to the\n   * other peers.\n   *\n   * @template T\n   * @param {function(Transaction):T} f The function that should be executed as a transaction\n   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin\n   * @return T\n   *\n   * @public\n   */ transact(f, origin = null) {\n        return transact(this, f, origin);\n    }\n    /**\n   * Define a shared data type.\n   *\n   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result\n   * and do not overwrite each other. I.e.\n   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`\n   *\n   * After this method is called, the type is also available on `ydoc.share.get(name)`.\n   *\n   * *Best Practices:*\n   * Define all types right after the Y.Doc instance is created and store them in a separate object.\n   * Also use the typed methods `getText(name)`, `getArray(name)`, ..\n   *\n   * @template {typeof AbstractType<any>} Type\n   * @example\n   *   const ydoc = new Y.Doc(..)\n   *   const appState = {\n   *     document: ydoc.getText('document')\n   *     comments: ydoc.getArray('comments')\n   *   }\n   *\n   * @param {string} name\n   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...\n   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor\n   *\n   * @public\n   */ get(name, TypeConstructor = /** @type {any} */ AbstractType) {\n        const type = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(this.share, name, ()=>{\n            // @ts-ignore\n            const t = new TypeConstructor();\n            t._integrate(this, null);\n            return t;\n        });\n        const Constr = type.constructor;\n        if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {\n            if (Constr === AbstractType) {\n                // @ts-ignore\n                const t = new TypeConstructor();\n                t._map = type._map;\n                type._map.forEach(/** @param {Item?} n */ (n)=>{\n                    for(; n !== null; n = n.left){\n                        // @ts-ignore\n                        n.parent = t;\n                    }\n                });\n                t._start = type._start;\n                for(let n = t._start; n !== null; n = n.right){\n                    n.parent = t;\n                }\n                t._length = type._length;\n                this.share.set(name, t);\n                t._integrate(this, null);\n                return /** @type {InstanceType<Type>} */ t;\n            } else {\n                throw new Error(`Type with the name ${name} has already been defined with a different constructor`);\n            }\n        }\n        return /** @type {InstanceType<Type>} */ type;\n    }\n    /**\n   * @template T\n   * @param {string} [name]\n   * @return {YArray<T>}\n   *\n   * @public\n   */ getArray(name = \"\") {\n        return /** @type {YArray<T>} */ this.get(name, YArray);\n    }\n    /**\n   * @param {string} [name]\n   * @return {YText}\n   *\n   * @public\n   */ getText(name = \"\") {\n        return this.get(name, YText);\n    }\n    /**\n   * @template T\n   * @param {string} [name]\n   * @return {YMap<T>}\n   *\n   * @public\n   */ getMap(name = \"\") {\n        return /** @type {YMap<T>} */ this.get(name, YMap);\n    }\n    /**\n   * @param {string} [name]\n   * @return {YXmlElement}\n   *\n   * @public\n   */ getXmlElement(name = \"\") {\n        return /** @type {YXmlElement<{[key:string]:string}>} */ this.get(name, YXmlElement);\n    }\n    /**\n   * @param {string} [name]\n   * @return {YXmlFragment}\n   *\n   * @public\n   */ getXmlFragment(name = \"\") {\n        return this.get(name, YXmlFragment);\n    }\n    /**\n   * Converts the entire document into a js object, recursively traversing each yjs type\n   * Doesn't log types that have not been defined (using ydoc.getType(..)).\n   *\n   * @deprecated Do not use this method and rather call toJSON directly on the shared types.\n   *\n   * @return {Object<string, any>}\n   */ toJSON() {\n        /**\n     * @type {Object<string, any>}\n     */ const doc = {};\n        this.share.forEach((value, key)=>{\n            doc[key] = value.toJSON();\n        });\n        return doc;\n    }\n    /**\n   * Emit `destroy` event and unregister all event handlers.\n   */ destroy() {\n        this.isDestroyed = true;\n        lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(this.subdocs).forEach((subdoc)=>subdoc.destroy());\n        const item = this._item;\n        if (item !== null) {\n            this._item = null;\n            const content = /** @type {ContentDoc} */ item.content;\n            content.doc = new Doc({\n                guid: this.guid,\n                ...content.opts,\n                shouldLoad: false\n            });\n            content.doc._item = item;\n            transact(/** @type {any} */ item.parent.doc, (transaction)=>{\n                const doc = content.doc;\n                if (!item.deleted) {\n                    transaction.subdocsAdded.add(doc);\n                }\n                transaction.subdocsRemoved.add(this);\n            }, null, true);\n        }\n        // @ts-ignore\n        this.emit(\"destroyed\", [\n            true\n        ]); // DEPRECATED!\n        this.emit(\"destroy\", [\n            this\n        ]);\n        super.destroy();\n    }\n}\nclass DSDecoderV1 {\n    /**\n   * @param {decoding.Decoder} decoder\n   */ constructor(decoder){\n        this.restDecoder = decoder;\n    }\n    resetDsCurVal() {\n    // nop\n    }\n    /**\n   * @return {number}\n   */ readDsClock() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder);\n    }\n    /**\n   * @return {number}\n   */ readDsLen() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder);\n    }\n}\nclass UpdateDecoderV1 extends DSDecoderV1 {\n    /**\n   * @return {ID}\n   */ readLeftID() {\n        return createID(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder));\n    }\n    /**\n   * @return {ID}\n   */ readRightID() {\n        return createID(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder));\n    }\n    /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */ readClient() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder);\n    }\n    /**\n   * @return {number} info An unsigned 8-bit integer\n   */ readInfo() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readUint8(this.restDecoder);\n    }\n    /**\n   * @return {string}\n   */ readString() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(this.restDecoder);\n    }\n    /**\n   * @return {boolean} isKey\n   */ readParentInfo() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder) === 1;\n    }\n    /**\n   * @return {number} info An unsigned 8-bit integer\n   */ readTypeRef() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder);\n    }\n    /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number} len\n   */ readLen() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder);\n    }\n    /**\n   * @return {any}\n   */ readAny() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readAny(this.restDecoder);\n    }\n    /**\n   * @return {Uint8Array}\n   */ readBuf() {\n        return lib0_buffer__WEBPACK_IMPORTED_MODULE_8__.copyUint8Array(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(this.restDecoder));\n    }\n    /**\n   * Legacy implementation uses JSON parse. We use any-decoding in v2.\n   *\n   * @return {any}\n   */ readJSON() {\n        return JSON.parse(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(this.restDecoder));\n    }\n    /**\n   * @return {string}\n   */ readKey() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(this.restDecoder);\n    }\n}\nclass DSDecoderV2 {\n    /**\n   * @param {decoding.Decoder} decoder\n   */ constructor(decoder){\n        /**\n     * @private\n     */ this.dsCurrVal = 0;\n        this.restDecoder = decoder;\n    }\n    resetDsCurVal() {\n        this.dsCurrVal = 0;\n    }\n    /**\n   * @return {number}\n   */ readDsClock() {\n        this.dsCurrVal += lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder);\n        return this.dsCurrVal;\n    }\n    /**\n   * @return {number}\n   */ readDsLen() {\n        const diff = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder) + 1;\n        this.dsCurrVal += diff;\n        return diff;\n    }\n}\nclass UpdateDecoderV2 extends DSDecoderV2 {\n    /**\n   * @param {decoding.Decoder} decoder\n   */ constructor(decoder){\n        super(decoder);\n        /**\n     * List of cached keys. If the keys[id] does not exist, we read a new key\n     * from stringEncoder and push it to keys.\n     *\n     * @type {Array<string>}\n     */ this.keys = [];\n        lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder); // read feature flag - currently unused\n        this.keyClockDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n        this.clientDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n        this.leftClockDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n        this.rightClockDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n        this.infoDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.RleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readUint8);\n        this.stringDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.StringDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n        this.parentInfoDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.RleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readUint8);\n        this.typeRefDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n        this.lenDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n    }\n    /**\n   * @return {ID}\n   */ readLeftID() {\n        return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());\n    }\n    /**\n   * @return {ID}\n   */ readRightID() {\n        return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());\n    }\n    /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */ readClient() {\n        return this.clientDecoder.read();\n    }\n    /**\n   * @return {number} info An unsigned 8-bit integer\n   */ readInfo() {\n        return /** @type {number} */ this.infoDecoder.read();\n    }\n    /**\n   * @return {string}\n   */ readString() {\n        return this.stringDecoder.read();\n    }\n    /**\n   * @return {boolean}\n   */ readParentInfo() {\n        return this.parentInfoDecoder.read() === 1;\n    }\n    /**\n   * @return {number} An unsigned 8-bit integer\n   */ readTypeRef() {\n        return this.typeRefDecoder.read();\n    }\n    /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number}\n   */ readLen() {\n        return this.lenDecoder.read();\n    }\n    /**\n   * @return {any}\n   */ readAny() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readAny(this.restDecoder);\n    }\n    /**\n   * @return {Uint8Array}\n   */ readBuf() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(this.restDecoder);\n    }\n    /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @return {any}\n   */ readJSON() {\n        return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readAny(this.restDecoder);\n    }\n    /**\n   * @return {string}\n   */ readKey() {\n        const keyClock = this.keyClockDecoder.read();\n        if (keyClock < this.keys.length) {\n            return this.keys[keyClock];\n        } else {\n            const key = this.stringDecoder.read();\n            this.keys.push(key);\n            return key;\n        }\n    }\n}\nclass DSEncoderV1 {\n    constructor(){\n        this.restEncoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();\n    }\n    toUint8Array() {\n        return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.restEncoder);\n    }\n    resetDsCurVal() {\n    // nop\n    }\n    /**\n   * @param {number} clock\n   */ writeDsClock(clock) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, clock);\n    }\n    /**\n   * @param {number} len\n   */ writeDsLen(len) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, len);\n    }\n}\nclass UpdateEncoderV1 extends DSEncoderV1 {\n    /**\n   * @param {ID} id\n   */ writeLeftID(id) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, id.client);\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, id.clock);\n    }\n    /**\n   * @param {ID} id\n   */ writeRightID(id) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, id.client);\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, id.clock);\n    }\n    /**\n   * Use writeClient and writeClock instead of writeID if possible.\n   * @param {number} client\n   */ writeClient(client) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, client);\n    }\n    /**\n   * @param {number} info An unsigned 8-bit integer\n   */ writeInfo(info) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8(this.restEncoder, info);\n    }\n    /**\n   * @param {string} s\n   */ writeString(s) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(this.restEncoder, s);\n    }\n    /**\n   * @param {boolean} isYKey\n   */ writeParentInfo(isYKey) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, isYKey ? 1 : 0);\n    }\n    /**\n   * @param {number} info An unsigned 8-bit integer\n   */ writeTypeRef(info) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, info);\n    }\n    /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */ writeLen(len) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, len);\n    }\n    /**\n   * @param {any} any\n   */ writeAny(any) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeAny(this.restEncoder, any);\n    }\n    /**\n   * @param {Uint8Array} buf\n   */ writeBuf(buf) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(this.restEncoder, buf);\n    }\n    /**\n   * @param {any} embed\n   */ writeJSON(embed) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(this.restEncoder, JSON.stringify(embed));\n    }\n    /**\n   * @param {string} key\n   */ writeKey(key) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(this.restEncoder, key);\n    }\n}\nclass DSEncoderV2 {\n    constructor(){\n        this.restEncoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder(); // encodes all the rest / non-optimized\n        this.dsCurrVal = 0;\n    }\n    toUint8Array() {\n        return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.restEncoder);\n    }\n    resetDsCurVal() {\n        this.dsCurrVal = 0;\n    }\n    /**\n   * @param {number} clock\n   */ writeDsClock(clock) {\n        const diff = clock - this.dsCurrVal;\n        this.dsCurrVal = clock;\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, diff);\n    }\n    /**\n   * @param {number} len\n   */ writeDsLen(len) {\n        if (len === 0) {\n            lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n        }\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, len - 1);\n        this.dsCurrVal += len;\n    }\n}\nclass UpdateEncoderV2 extends DSEncoderV2 {\n    constructor(){\n        super();\n        /**\n     * @type {Map<string,number>}\n     */ this.keyMap = new Map();\n        /**\n     * Refers to the next unique key-identifier to me used.\n     * See writeKey method for more information.\n     *\n     * @type {number}\n     */ this.keyClock = 0;\n        this.keyClockEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();\n        this.clientEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();\n        this.leftClockEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();\n        this.rightClockEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();\n        this.infoEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.RleEncoder(lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8);\n        this.stringEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.StringEncoder();\n        this.parentInfoEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.RleEncoder(lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8);\n        this.typeRefEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();\n        this.lenEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();\n    }\n    toUint8Array() {\n        const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, 0); // this is a feature flag that we might use in the future\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.infoEncoder));\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.parentInfoEncoder));\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());\n        // @note The rest encoder is appended! (note the missing var)\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8Array(encoder, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.restEncoder));\n        return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder);\n    }\n    /**\n   * @param {ID} id\n   */ writeLeftID(id) {\n        this.clientEncoder.write(id.client);\n        this.leftClockEncoder.write(id.clock);\n    }\n    /**\n   * @param {ID} id\n   */ writeRightID(id) {\n        this.clientEncoder.write(id.client);\n        this.rightClockEncoder.write(id.clock);\n    }\n    /**\n   * @param {number} client\n   */ writeClient(client) {\n        this.clientEncoder.write(client);\n    }\n    /**\n   * @param {number} info An unsigned 8-bit integer\n   */ writeInfo(info) {\n        this.infoEncoder.write(info);\n    }\n    /**\n   * @param {string} s\n   */ writeString(s) {\n        this.stringEncoder.write(s);\n    }\n    /**\n   * @param {boolean} isYKey\n   */ writeParentInfo(isYKey) {\n        this.parentInfoEncoder.write(isYKey ? 1 : 0);\n    }\n    /**\n   * @param {number} info An unsigned 8-bit integer\n   */ writeTypeRef(info) {\n        this.typeRefEncoder.write(info);\n    }\n    /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */ writeLen(len) {\n        this.lenEncoder.write(len);\n    }\n    /**\n   * @param {any} any\n   */ writeAny(any) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeAny(this.restEncoder, any);\n    }\n    /**\n   * @param {Uint8Array} buf\n   */ writeBuf(buf) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(this.restEncoder, buf);\n    }\n    /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @param {any} embed\n   */ writeJSON(embed) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeAny(this.restEncoder, embed);\n    }\n    /**\n   * Property keys are often reused. For example, in y-prosemirror the key `bold` might\n   * occur very often. For a 3d application, the key `position` might occur very often.\n   *\n   * We cache these keys in a Map and refer to them via a unique number.\n   *\n   * @param {string} key\n   */ writeKey(key) {\n        const clock = this.keyMap.get(key);\n        if (clock === undefined) {\n            /**\n       * @todo uncomment to introduce this feature finally\n       *\n       * Background. The ContentFormat object was always encoded using writeKey, but the decoder used to use readString.\n       * Furthermore, I forgot to set the keyclock. So everything was working fine.\n       *\n       * However, this feature here is basically useless as it is not being used (it actually only consumes extra memory).\n       *\n       * I don't know yet how to reintroduce this feature..\n       *\n       * Older clients won't be able to read updates when we reintroduce this feature. So this should probably be done using a flag.\n       *\n       */ // this.keyMap.set(key, this.keyClock)\n            this.keyClockEncoder.write(this.keyClock++);\n            this.stringEncoder.write(key);\n        } else {\n            this.keyClockEncoder.write(clock);\n        }\n    }\n}\n/**\n * @module encoding\n */ /*\n * We use the first five bits in the info flag for determining the type of the struct.\n *\n * 0: GC\n * 1: Item with Deleted content\n * 2: Item with JSON content\n * 3: Item with Binary content\n * 4: Item with String content\n * 5: Item with Embed content (for richtext content)\n * 6: Item with Format content (a formatting marker for richtext content)\n * 7: Item with Type\n */ /**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Array<GC|Item>} structs All structs by `client`\n * @param {number} client\n * @param {number} clock write structs starting with `ID(client,clock)`\n *\n * @function\n */ const writeStructs = (encoder, structs, client, clock)=>{\n    // write first id\n    clock = lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(clock, structs[0].id.clock); // make sure the first id exists\n    const startNewStructs = findIndexSS(structs, clock);\n    // write # encoded structs\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, structs.length - startNewStructs);\n    encoder.writeClient(client);\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, clock);\n    const firstStruct = structs[startNewStructs];\n    // write first struct with an offset\n    firstStruct.write(encoder, clock - firstStruct.id.clock);\n    for(let i = startNewStructs + 1; i < structs.length; i++){\n        structs[i].write(encoder, 0);\n    }\n};\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {StructStore} store\n * @param {Map<number,number>} _sm\n *\n * @private\n * @function\n */ const writeClientsStructs = (encoder, store, _sm)=>{\n    // we filter all valid _sm entries into sm\n    const sm = new Map();\n    _sm.forEach((clock, client)=>{\n        // only write if new structs are available\n        if (getState(store, client) > clock) {\n            sm.set(client, clock);\n        }\n    });\n    getStateVector(store).forEach((_clock, client)=>{\n        if (!_sm.has(client)) {\n            sm.set(client, 0);\n        }\n    });\n    // write # states that were updated\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, sm.size);\n    // Write items with higher client ids first\n    // This heavily improves the conflict algorithm.\n    lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(sm.entries()).sort((a, b)=>b[0] - a[0]).forEach(([client, clock])=>{\n        writeStructs(encoder, /** @type {Array<GC|Item>} */ store.clients.get(client), client, clock);\n    });\n};\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder The decoder object to read data from.\n * @param {Doc} doc\n * @return {Map<number, { i: number, refs: Array<Item | GC> }>}\n *\n * @private\n * @function\n */ const readClientsStructRefs = (decoder, doc)=>{\n    /**\n   * @type {Map<number, { i: number, refs: Array<Item | GC> }>}\n   */ const clientRefs = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n    const numOfStateUpdates = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    for(let i = 0; i < numOfStateUpdates; i++){\n        const numberOfStructs = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        /**\n     * @type {Array<GC|Item>}\n     */ const refs = new Array(numberOfStructs);\n        const client = decoder.readClient();\n        let clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        // const start = performance.now()\n        clientRefs.set(client, {\n            i: 0,\n            refs\n        });\n        for(let i = 0; i < numberOfStructs; i++){\n            const info = decoder.readInfo();\n            switch(lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BITS5 & info){\n                case 0:\n                    {\n                        const len = decoder.readLen();\n                        refs[i] = new GC(createID(client, clock), len);\n                        clock += len;\n                        break;\n                    }\n                case 10:\n                    {\n                        // @todo we could reduce the amount of checks by adding Skip struct to clientRefs so we know that something is missing.\n                        const len = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n                        refs[i] = new Skip(createID(client, clock), len);\n                        clock += len;\n                        break;\n                    }\n                default:\n                    {\n                        /**\n           * The optimized implementation doesn't use any variables because inlining variables is faster.\n           * Below a non-optimized version is shown that implements the basic algorithm with\n           * a few comments\n           */ const cantCopyParentInfo = (info & (lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7 | lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8)) === 0;\n                        // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n                        // and we read the next string as parentYKey.\n                        // It indicates how we store/retrieve parent from `y.share`\n                        // @type {string|null}\n                        const struct = new Item(createID(client, clock), null, (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8 ? decoder.readLeftID() : null, null, (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7 ? decoder.readRightID() : null, cantCopyParentInfo ? decoder.readParentInfo() ? doc.get(decoder.readString()) : decoder.readLeftID() : null, cantCopyParentInfo && (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6 ? decoder.readString() : null, readItemContent(decoder, info) // item content\n                        );\n                        /* A non-optimized implementation of the above algorithm:\n\n          // The item that was originally to the left of this item.\n          const origin = (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null\n          // The item that was originally to the right of this item.\n          const rightOrigin = (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null\n          const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0\n          const hasParentYKey = cantCopyParentInfo ? decoder.readParentInfo() : false\n          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n          // and we read the next string as parentYKey.\n          // It indicates how we store/retrieve parent from `y.share`\n          // @type {string|null}\n          const parentYKey = cantCopyParentInfo && hasParentYKey ? decoder.readString() : null\n\n          const struct = new Item(\n            createID(client, clock),\n            null, // left\n            origin, // origin\n            null, // right\n            rightOrigin, // right origin\n            cantCopyParentInfo && !hasParentYKey ? decoder.readLeftID() : (parentYKey !== null ? doc.get(parentYKey) : null), // parent\n            cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub\n            readItemContent(decoder, info) // item content\n          )\n          */ refs[i] = struct;\n                        clock += struct.length;\n                    }\n            }\n        }\n    // console.log('time to read: ', performance.now() - start) // @todo remove\n    }\n    return clientRefs;\n};\n/**\n * Resume computing structs generated by struct readers.\n *\n * While there is something to do, we integrate structs in this order\n * 1. top element on stack, if stack is not empty\n * 2. next element from current struct reader (if empty, use next struct reader)\n *\n * If struct causally depends on another struct (ref.missing), we put next reader of\n * `ref.id.client` on top of stack.\n *\n * At some point we find a struct that has no causal dependencies,\n * then we start emptying the stack.\n *\n * It is not possible to have circles: i.e. struct1 (from client1) depends on struct2 (from client2)\n * depends on struct3 (from client1). Therefore the max stack size is equal to `structReaders.length`.\n *\n * This method is implemented in a way so that we can resume computation if this update\n * causally depends on another update.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {Map<number, { i: number, refs: (GC | Item)[] }>} clientsStructRefs\n * @return { null | { update: Uint8Array, missing: Map<number,number> } }\n *\n * @private\n * @function\n */ const integrateStructs = (transaction, store, clientsStructRefs)=>{\n    /**\n   * @type {Array<Item | GC>}\n   */ const stack = [];\n    // sort them so that we take the higher id first, in case of conflicts the lower id will probably not conflict with the id from the higher user.\n    let clientsStructRefsIds = lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(clientsStructRefs.keys()).sort((a, b)=>a - b);\n    if (clientsStructRefsIds.length === 0) {\n        return null;\n    }\n    const getNextStructTarget = ()=>{\n        if (clientsStructRefsIds.length === 0) {\n            return null;\n        }\n        let nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);\n        while(nextStructsTarget.refs.length === nextStructsTarget.i){\n            clientsStructRefsIds.pop();\n            if (clientsStructRefsIds.length > 0) {\n                nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);\n            } else {\n                return null;\n            }\n        }\n        return nextStructsTarget;\n    };\n    let curStructsTarget = getNextStructTarget();\n    if (curStructsTarget === null) {\n        return null;\n    }\n    /**\n   * @type {StructStore}\n   */ const restStructs = new StructStore();\n    const missingSV = new Map();\n    /**\n   * @param {number} client\n   * @param {number} clock\n   */ const updateMissingSv = (client, clock)=>{\n        const mclock = missingSV.get(client);\n        if (mclock == null || mclock > clock) {\n            missingSV.set(client, clock);\n        }\n    };\n    /**\n   * @type {GC|Item}\n   */ let stackHead = /** @type {any} */ curStructsTarget.refs[/** @type {any} */ curStructsTarget.i++];\n    // caching the state because it is used very often\n    const state = new Map();\n    const addStackToRestSS = ()=>{\n        for (const item of stack){\n            const client = item.id.client;\n            const inapplicableItems = clientsStructRefs.get(client);\n            if (inapplicableItems) {\n                // decrement because we weren't able to apply previous operation\n                inapplicableItems.i--;\n                restStructs.clients.set(client, inapplicableItems.refs.slice(inapplicableItems.i));\n                clientsStructRefs.delete(client);\n                inapplicableItems.i = 0;\n                inapplicableItems.refs = [];\n            } else {\n                // item was the last item on clientsStructRefs and the field was already cleared. Add item to restStructs and continue\n                restStructs.clients.set(client, [\n                    item\n                ]);\n            }\n            // remove client from clientsStructRefsIds to prevent users from applying the same update again\n            clientsStructRefsIds = clientsStructRefsIds.filter((c)=>c !== client);\n        }\n        stack.length = 0;\n    };\n    // iterate over all struct readers until we are done\n    while(true){\n        if (stackHead.constructor !== Skip) {\n            const localClock = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(state, stackHead.id.client, ()=>getState(store, stackHead.id.client));\n            const offset = localClock - stackHead.id.clock;\n            if (offset < 0) {\n                // update from the same client is missing\n                stack.push(stackHead);\n                updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);\n                // hid a dead wall, add all items from stack to restSS\n                addStackToRestSS();\n            } else {\n                const missing = stackHead.getMissing(transaction, store);\n                if (missing !== null) {\n                    stack.push(stackHead);\n                    // get the struct reader that has the missing struct\n                    /**\n           * @type {{ refs: Array<GC|Item>, i: number }}\n           */ const structRefs = clientsStructRefs.get(/** @type {number} */ missing) || {\n                        refs: [],\n                        i: 0\n                    };\n                    if (structRefs.refs.length === structRefs.i) {\n                        // This update message causally depends on another update message that doesn't exist yet\n                        updateMissingSv(/** @type {number} */ missing, getState(store, missing));\n                        addStackToRestSS();\n                    } else {\n                        stackHead = structRefs.refs[structRefs.i++];\n                        continue;\n                    }\n                } else if (offset === 0 || offset < stackHead.length) {\n                    // all fine, apply the stackhead\n                    stackHead.integrate(transaction, offset);\n                    state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);\n                }\n            }\n        }\n        // iterate to next stackHead\n        if (stack.length > 0) {\n            stackHead = /** @type {GC|Item} */ stack.pop();\n        } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {\n            stackHead = /** @type {GC|Item} */ curStructsTarget.refs[curStructsTarget.i++];\n        } else {\n            curStructsTarget = getNextStructTarget();\n            if (curStructsTarget === null) {\n                break;\n            } else {\n                stackHead = /** @type {GC|Item} */ curStructsTarget.refs[curStructsTarget.i++];\n            }\n        }\n    }\n    if (restStructs.clients.size > 0) {\n        const encoder = new UpdateEncoderV2();\n        writeClientsStructs(encoder, restStructs, new Map());\n        // write empty deleteset\n        // writeDeleteSet(encoder, new DeleteSet())\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, 0); // => no need for an extra function call, just write 0 deletes\n        return {\n            missing: missingSV,\n            update: encoder.toUint8Array()\n        };\n    }\n    return null;\n};\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n *\n * @private\n * @function\n */ const writeStructsFromTransaction = (encoder, transaction)=>writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts a decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {UpdateDecoderV1 | UpdateDecoderV2} [structDecoder]\n *\n * @function\n */ const readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder))=>transact(ydoc, (transaction)=>{\n        // force that transaction.local is set to non-local\n        transaction.local = false;\n        let retry = false;\n        const doc = transaction.doc;\n        const store = doc.store;\n        // let start = performance.now()\n        const ss = readClientsStructRefs(structDecoder, doc);\n        // console.log('time to read structs: ', performance.now() - start) // @todo remove\n        // start = performance.now()\n        // console.log('time to merge: ', performance.now() - start) // @todo remove\n        // start = performance.now()\n        const restStructs = integrateStructs(transaction, store, ss);\n        const pending = store.pendingStructs;\n        if (pending) {\n            // check if we can apply something\n            for (const [client, clock] of pending.missing){\n                if (clock < getState(store, client)) {\n                    retry = true;\n                    break;\n                }\n            }\n            if (restStructs) {\n                // merge restStructs into store.pending\n                for (const [client, clock] of restStructs.missing){\n                    const mclock = pending.missing.get(client);\n                    if (mclock == null || mclock > clock) {\n                        pending.missing.set(client, clock);\n                    }\n                }\n                pending.update = mergeUpdatesV2([\n                    pending.update,\n                    restStructs.update\n                ]);\n            }\n        } else {\n            store.pendingStructs = restStructs;\n        }\n        // console.log('time to integrate: ', performance.now() - start) // @todo remove\n        // start = performance.now()\n        const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);\n        if (store.pendingDs) {\n            // @todo we could make a lower-bound state-vector check as we do above\n            const pendingDSUpdate = new UpdateDecoderV2(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(store.pendingDs));\n            lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(pendingDSUpdate.restDecoder); // read 0 structs, because we only encode deletes in pendingdsupdate\n            const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);\n            if (dsRest && dsRest2) {\n                // case 1: ds1 != null && ds2 != null\n                store.pendingDs = mergeUpdatesV2([\n                    dsRest,\n                    dsRest2\n                ]);\n            } else {\n                // case 2: ds1 != null\n                // case 3: ds2 != null\n                // case 4: ds1 == null && ds2 == null\n                store.pendingDs = dsRest || dsRest2;\n            }\n        } else {\n            // Either dsRest == null && pendingDs == null OR dsRest != null\n            store.pendingDs = dsRest;\n        }\n        // console.log('time to cleanup: ', performance.now() - start) // @todo remove\n        // start = performance.now()\n        // console.log('time to resume delete readers: ', performance.now() - start) // @todo remove\n        // start = performance.now()\n        if (retry) {\n            const update = /** @type {{update: Uint8Array}} */ store.pendingStructs.update;\n            store.pendingStructs = null;\n            applyUpdateV2(transaction.doc, update);\n        }\n    }, transactionOrigin, false);\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts a decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */ const readUpdate = (decoder, ydoc, transactionOrigin)=>readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder));\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n *\n * @function\n */ const applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2)=>{\n    const decoder = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update);\n    readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));\n};\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */ const applyUpdate = (ydoc, update, transactionOrigin)=>applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);\n/**\n * Write all the document as a single update message. If you specify the state of the remote client (`targetStateVector`) it will\n * only write the operations that are missing.\n *\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Doc} doc\n * @param {Map<number,number>} [targetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n *\n * @function\n */ const writeStateAsUpdate = (encoder, doc, targetStateVector = new Map())=>{\n    writeClientsStructs(encoder, doc.store, targetStateVector);\n    writeDeleteSet(encoder, createDeleteSetFromStructStore(doc.store));\n};\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @param {UpdateEncoderV1 | UpdateEncoderV2} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */ const encodeStateAsUpdateV2 = (doc, encodedTargetStateVector = new Uint8Array([\n    0\n]), encoder = new UpdateEncoderV2())=>{\n    const targetStateVector = decodeStateVector(encodedTargetStateVector);\n    writeStateAsUpdate(encoder, doc, targetStateVector);\n    const updates = [\n        encoder.toUint8Array()\n    ];\n    // also add the pending updates (if there are any)\n    if (doc.store.pendingDs) {\n        updates.push(doc.store.pendingDs);\n    }\n    if (doc.store.pendingStructs) {\n        updates.push(diffUpdateV2(doc.store.pendingStructs.update, encodedTargetStateVector));\n    }\n    if (updates.length > 1) {\n        if (encoder.constructor === UpdateEncoderV1) {\n            return mergeUpdates(updates.map((update, i)=>i === 0 ? update : convertUpdateFormatV2ToV1(update)));\n        } else if (encoder.constructor === UpdateEncoderV2) {\n            return mergeUpdatesV2(updates);\n        }\n    }\n    return updates[0];\n};\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @return {Uint8Array}\n *\n * @function\n */ const encodeStateAsUpdate = (doc, encodedTargetStateVector)=>encodeStateAsUpdateV2(doc, encodedTargetStateVector, new UpdateEncoderV1());\n/**\n * Read state vector from Decoder and return as Map\n *\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */ const readStateVector = (decoder)=>{\n    const ss = new Map();\n    const ssLength = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    for(let i = 0; i < ssLength; i++){\n        const client = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        const clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        ss.set(client, clock);\n    }\n    return ss;\n};\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */ // export const decodeStateVectorV2 = decodedState => readStateVector(new DSDecoderV2(decoding.createDecoder(decodedState)))\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */ const decodeStateVector = (decodedState)=>readStateVector(new DSDecoderV1(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(decodedState)));\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {Map<number,number>} sv\n * @function\n */ const writeStateVector = (encoder, sv)=>{\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, sv.size);\n    lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(sv.entries()).sort((a, b)=>b[0] - a[0]).forEach(([client, clock])=>{\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, client); // @todo use a special client decoder that is based on mapping\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, clock);\n    });\n    return encoder;\n};\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {Doc} doc\n *\n * @function\n */ const writeDocumentStateVector = (encoder, doc)=>writeStateVector(encoder, getStateVector(doc.store));\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @param {DSEncoderV1 | DSEncoderV2} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */ const encodeStateVectorV2 = (doc, encoder = new DSEncoderV2())=>{\n    if (doc instanceof Map) {\n        writeStateVector(encoder, doc);\n    } else {\n        writeDocumentStateVector(encoder, doc);\n    }\n    return encoder.toUint8Array();\n};\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @return {Uint8Array}\n *\n * @function\n */ const encodeStateVector = (doc)=>encodeStateVectorV2(doc, new DSEncoderV1());\n/**\n * General event handler implementation.\n *\n * @template ARG0, ARG1\n *\n * @private\n */ class EventHandler {\n    constructor(){\n        /**\n     * @type {Array<function(ARG0, ARG1):void>}\n     */ this.l = [];\n    }\n}\n/**\n * @template ARG0,ARG1\n * @returns {EventHandler<ARG0,ARG1>}\n *\n * @private\n * @function\n */ const createEventHandler = ()=>new EventHandler();\n/**\n * Adds an event listener that is called when\n * {@link EventHandler#callEventListeners} is called.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler.\n *\n * @private\n * @function\n */ const addEventHandlerListener = (eventHandler, f)=>eventHandler.l.push(f);\n/**\n * Removes an event listener.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler that was added with\n *                     {@link EventHandler#addEventListener}\n *\n * @private\n * @function\n */ const removeEventHandlerListener = (eventHandler, f)=>{\n    const l = eventHandler.l;\n    const len = l.length;\n    eventHandler.l = l.filter((g)=>f !== g);\n    if (len === eventHandler.l.length) {\n        console.error(\"[yjs] Tried to remove event handler that doesn't exist.\");\n    }\n};\n/**\n * Call all event listeners that were added via\n * {@link EventHandler#addEventListener}.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {ARG0} arg0\n * @param {ARG1} arg1\n *\n * @private\n * @function\n */ const callEventHandlerListeners = (eventHandler, arg0, arg1)=>lib0_function__WEBPACK_IMPORTED_MODULE_11__.callAll(eventHandler.l, [\n        arg0,\n        arg1\n    ]);\nclass ID {\n    /**\n   * @param {number} client client id\n   * @param {number} clock unique per client id, continuous number\n   */ constructor(client, clock){\n        /**\n     * Client id\n     * @type {number}\n     */ this.client = client;\n        /**\n     * unique per client id, continuous number\n     * @type {number}\n     */ this.clock = clock;\n    }\n}\n/**\n * @param {ID | null} a\n * @param {ID | null} b\n * @return {boolean}\n *\n * @function\n */ const compareIDs = (a, b)=>a === b || a !== null && b !== null && a.client === b.client && a.clock === b.clock;\n/**\n * @param {number} client\n * @param {number} clock\n *\n * @private\n * @function\n */ const createID = (client, clock)=>new ID(client, clock);\n/**\n * @param {encoding.Encoder} encoder\n * @param {ID} id\n *\n * @private\n * @function\n */ const writeID = (encoder, id)=>{\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, id.client);\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, id.clock);\n};\n/**\n * Read ID.\n * * If first varUint read is 0xFFFFFF a RootID is returned.\n * * Otherwise an ID is returned\n *\n * @param {decoding.Decoder} decoder\n * @return {ID}\n *\n * @private\n * @function\n */ const readID = (decoder)=>createID(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder));\n/**\n * The top types are mapped from y.share.get(keyname) => type.\n * `type` does not store any information about the `keyname`.\n * This function finds the correct `keyname` for `type` and throws otherwise.\n *\n * @param {AbstractType<any>} type\n * @return {string}\n *\n * @private\n * @function\n */ const findRootTypeKey = (type)=>{\n    // @ts-ignore _y must be defined, otherwise unexpected case\n    for (const [key, value] of type.doc.share.entries()){\n        if (value === type) {\n            return key;\n        }\n    }\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n};\n/**\n * Check if `parent` is a parent of `child`.\n *\n * @param {AbstractType<any>} parent\n * @param {Item|null} child\n * @return {Boolean} Whether `parent` is a parent of `child`.\n *\n * @private\n * @function\n */ const isParentOf = (parent, child)=>{\n    while(child !== null){\n        if (child.parent === parent) {\n            return true;\n        }\n        child = /** @type {AbstractType<any>} */ child.parent._item;\n    }\n    return false;\n};\n/**\n * Convenient helper to log type information.\n *\n * Do not use in productive systems as the output can be immense!\n *\n * @param {AbstractType<any>} type\n */ const logType = (type)=>{\n    const res = [];\n    let n = type._start;\n    while(n){\n        res.push(n);\n        n = n.right;\n    }\n    console.log(\"Children: \", res);\n    console.log(\"Children content: \", res.filter((m)=>!m.deleted).map((m)=>m.content));\n};\nclass PermanentUserData {\n    /**\n   * @param {Doc} doc\n   * @param {YMap<any>} [storeType]\n   */ constructor(doc, storeType = doc.getMap(\"users\")){\n        /**\n     * @type {Map<string,DeleteSet>}\n     */ const dss = new Map();\n        this.yusers = storeType;\n        this.doc = doc;\n        /**\n     * Maps from clientid to userDescription\n     *\n     * @type {Map<number,string>}\n     */ this.clients = new Map();\n        this.dss = dss;\n        /**\n     * @param {YMap<any>} user\n     * @param {string} userDescription\n     */ const initUser = (user, userDescription)=>{\n            /**\n       * @type {YArray<Uint8Array>}\n       */ const ds = user.get(\"ds\");\n            const ids = user.get(\"ids\");\n            const addClientId = /** @param {number} clientid */ (clientid)=>this.clients.set(clientid, userDescription);\n            ds.observe(/** @param {YArrayEvent<any>} event */ (event)=>{\n                event.changes.added.forEach((item)=>{\n                    item.content.getContent().forEach((encodedDs)=>{\n                        if (encodedDs instanceof Uint8Array) {\n                            this.dss.set(userDescription, mergeDeleteSets([\n                                this.dss.get(userDescription) || createDeleteSet(),\n                                readDeleteSet(new DSDecoderV1(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(encodedDs)))\n                            ]));\n                        }\n                    });\n                });\n            });\n            this.dss.set(userDescription, mergeDeleteSets(ds.map((encodedDs)=>readDeleteSet(new DSDecoderV1(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(encodedDs))))));\n            ids.observe(/** @param {YArrayEvent<any>} event */ (event)=>event.changes.added.forEach((item)=>item.content.getContent().forEach(addClientId)));\n            ids.forEach(addClientId);\n        };\n        // observe users\n        storeType.observe((event)=>{\n            event.keysChanged.forEach((userDescription)=>initUser(storeType.get(userDescription), userDescription));\n        });\n        // add initial data\n        storeType.forEach(initUser);\n    }\n    /**\n   * @param {Doc} doc\n   * @param {number} clientid\n   * @param {string} userDescription\n   * @param {Object} conf\n   * @param {function(Transaction, DeleteSet):boolean} [conf.filter]\n   */ setUserMapping(doc, clientid, userDescription, { filter = ()=>true } = {}) {\n        const users = this.yusers;\n        let user = users.get(userDescription);\n        if (!user) {\n            user = new YMap();\n            user.set(\"ids\", new YArray());\n            user.set(\"ds\", new YArray());\n            users.set(userDescription, user);\n        }\n        user.get(\"ids\").push([\n            clientid\n        ]);\n        users.observe((_event)=>{\n            setTimeout(()=>{\n                const userOverwrite = users.get(userDescription);\n                if (userOverwrite !== user) {\n                    // user was overwritten, port all data over to the next user object\n                    // @todo Experiment with Y.Sets here\n                    user = userOverwrite;\n                    // @todo iterate over old type\n                    this.clients.forEach((_userDescription, clientid)=>{\n                        if (userDescription === _userDescription) {\n                            user.get(\"ids\").push([\n                                clientid\n                            ]);\n                        }\n                    });\n                    const encoder = new DSEncoderV1();\n                    const ds = this.dss.get(userDescription);\n                    if (ds) {\n                        writeDeleteSet(encoder, ds);\n                        user.get(\"ds\").push([\n                            encoder.toUint8Array()\n                        ]);\n                    }\n                }\n            }, 0);\n        });\n        doc.on(\"afterTransaction\", /** @param {Transaction} transaction */ (transaction)=>{\n            setTimeout(()=>{\n                const yds = user.get(\"ds\");\n                const ds = transaction.deleteSet;\n                if (transaction.local && ds.clients.size > 0 && filter(transaction, ds)) {\n                    const encoder = new DSEncoderV1();\n                    writeDeleteSet(encoder, ds);\n                    yds.push([\n                        encoder.toUint8Array()\n                    ]);\n                }\n            });\n        });\n    }\n    /**\n   * @param {number} clientid\n   * @return {any}\n   */ getUserByClientId(clientid) {\n        return this.clients.get(clientid) || null;\n    }\n    /**\n   * @param {ID} id\n   * @return {string | null}\n   */ getUserByDeletedId(id) {\n        for (const [userDescription, ds] of this.dss.entries()){\n            if (isDeleted(ds, id)) {\n                return userDescription;\n            }\n        }\n        return null;\n    }\n}\n/**\n * A relative position is based on the Yjs model and is not affected by document changes.\n * E.g. If you place a relative position before a certain character, it will always point to this character.\n * If you place a relative position at the end of a type, it will always point to the end of the type.\n *\n * A numeric position is often unsuited for user selections, because it does not change when content is inserted\n * before or after.\n *\n * ```Insert(0, 'x')('a|bc') = 'xa|bc'``` Where | is the relative position.\n *\n * One of the properties must be defined.\n *\n * @example\n *   // Current cursor position is at position 10\n *   const relativePosition = createRelativePositionFromIndex(yText, 10)\n *   // modify yText\n *   yText.insert(0, 'abc')\n *   yText.delete(3, 10)\n *   // Compute the cursor position\n *   const absolutePosition = createAbsolutePositionFromRelativePosition(y, relativePosition)\n *   absolutePosition.type === yText // => true\n *   console.log('cursor location is ' + absolutePosition.index) // => cursor location is 3\n *\n */ class RelativePosition {\n    /**\n   * @param {ID|null} type\n   * @param {string|null} tname\n   * @param {ID|null} item\n   * @param {number} assoc\n   */ constructor(type, tname, item, assoc = 0){\n        /**\n     * @type {ID|null}\n     */ this.type = type;\n        /**\n     * @type {string|null}\n     */ this.tname = tname;\n        /**\n     * @type {ID | null}\n     */ this.item = item;\n        /**\n     * A relative position is associated to a specific character. By default\n     * assoc >= 0, the relative position is associated to the character\n     * after the meant position.\n     * I.e. position 1 in 'ab' is associated to character 'b'.\n     *\n     * If assoc < 0, then the relative position is associated to the character\n     * before the meant position.\n     *\n     * @type {number}\n     */ this.assoc = assoc;\n    }\n}\n/**\n * @param {RelativePosition} rpos\n * @return {any}\n */ const relativePositionToJSON = (rpos)=>{\n    const json = {};\n    if (rpos.type) {\n        json.type = rpos.type;\n    }\n    if (rpos.tname) {\n        json.tname = rpos.tname;\n    }\n    if (rpos.item) {\n        json.item = rpos.item;\n    }\n    if (rpos.assoc != null) {\n        json.assoc = rpos.assoc;\n    }\n    return json;\n};\n/**\n * @param {any} json\n * @return {RelativePosition}\n *\n * @function\n */ const createRelativePositionFromJSON = (json)=>new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname ?? null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);\nclass AbsolutePosition {\n    /**\n   * @param {AbstractType<any>} type\n   * @param {number} index\n   * @param {number} [assoc]\n   */ constructor(type, index, assoc = 0){\n        /**\n     * @type {AbstractType<any>}\n     */ this.type = type;\n        /**\n     * @type {number}\n     */ this.index = index;\n        this.assoc = assoc;\n    }\n}\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @param {number} [assoc]\n *\n * @function\n */ const createAbsolutePosition = (type, index, assoc = 0)=>new AbsolutePosition(type, index, assoc);\n/**\n * @param {AbstractType<any>} type\n * @param {ID|null} item\n * @param {number} [assoc]\n *\n * @function\n */ const createRelativePosition = (type, item, assoc)=>{\n    let typeid = null;\n    let tname = null;\n    if (type._item === null) {\n        tname = findRootTypeKey(type);\n    } else {\n        typeid = createID(type._item.id.client, type._item.id.clock);\n    }\n    return new RelativePosition(typeid, tname, item, assoc);\n};\n/**\n * Create a relativePosition based on a absolute position.\n *\n * @param {AbstractType<any>} type The base type (e.g. YText or YArray).\n * @param {number} index The absolute position.\n * @param {number} [assoc]\n * @return {RelativePosition}\n *\n * @function\n */ const createRelativePositionFromTypeIndex = (type, index, assoc = 0)=>{\n    let t = type._start;\n    if (assoc < 0) {\n        // associated to the left character or the beginning of a type, increment index if possible.\n        if (index === 0) {\n            return createRelativePosition(type, null, assoc);\n        }\n        index--;\n    }\n    while(t !== null){\n        if (!t.deleted && t.countable) {\n            if (t.length > index) {\n                // case 1: found position somewhere in the linked list\n                return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc);\n            }\n            index -= t.length;\n        }\n        if (t.right === null && assoc < 0) {\n            // left-associated position, return last available id\n            return createRelativePosition(type, t.lastId, assoc);\n        }\n        t = t.right;\n    }\n    return createRelativePosition(type, null, assoc);\n};\n/**\n * @param {encoding.Encoder} encoder\n * @param {RelativePosition} rpos\n *\n * @function\n */ const writeRelativePosition = (encoder, rpos)=>{\n    const { type, tname, item, assoc } = rpos;\n    if (item !== null) {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, 0);\n        writeID(encoder, item);\n    } else if (tname !== null) {\n        // case 2: found position at the end of the list and type is stored in y.share\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8(encoder, 1);\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(encoder, tname);\n    } else if (type !== null) {\n        // case 3: found position at the end of the list and type is attached to an item\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8(encoder, 2);\n        writeID(encoder, type);\n    } else {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n    }\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarInt(encoder, assoc);\n    return encoder;\n};\n/**\n * @param {RelativePosition} rpos\n * @return {Uint8Array}\n */ const encodeRelativePosition = (rpos)=>{\n    const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();\n    writeRelativePosition(encoder, rpos);\n    return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder);\n};\n/**\n * @param {decoding.Decoder} decoder\n * @return {RelativePosition}\n *\n * @function\n */ const readRelativePosition = (decoder)=>{\n    let type = null;\n    let tname = null;\n    let itemID = null;\n    switch(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)){\n        case 0:\n            // case 1: found position somewhere in the linked list\n            itemID = readID(decoder);\n            break;\n        case 1:\n            // case 2: found position at the end of the list and type is stored in y.share\n            tname = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(decoder);\n            break;\n        case 2:\n            {\n                // case 3: found position at the end of the list and type is attached to an item\n                type = readID(decoder);\n            }\n    }\n    const assoc = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.hasContent(decoder) ? lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarInt(decoder) : 0;\n    return new RelativePosition(type, tname, itemID, assoc);\n};\n/**\n * @param {Uint8Array} uint8Array\n * @return {RelativePosition}\n */ const decodeRelativePosition = (uint8Array)=>readRelativePosition(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(uint8Array));\n/**\n * @param {StructStore} store\n * @param {ID} id\n */ const getItemWithOffset = (store, id)=>{\n    const item = getItem(store, id);\n    const diff = id.clock - item.id.clock;\n    return {\n        item,\n        diff\n    };\n};\n/**\n * Transform a relative position to an absolute position.\n *\n * If you want to share the relative position with other users, you should set\n * `followUndoneDeletions` to false to get consistent results across all clients.\n *\n * When calculating the absolute position, we try to follow the \"undone deletions\". This yields\n * better results for the user who performed undo. However, only the user who performed the undo\n * will get the better results, the other users don't know which operations recreated a deleted\n * range of content. There is more information in this ticket: https://github.com/yjs/yjs/issues/638\n *\n * @param {RelativePosition} rpos\n * @param {Doc} doc\n * @param {boolean} followUndoneDeletions - whether to follow undone deletions - see https://github.com/yjs/yjs/issues/638\n * @return {AbsolutePosition|null}\n *\n * @function\n */ const createAbsolutePositionFromRelativePosition = (rpos, doc, followUndoneDeletions = true)=>{\n    const store = doc.store;\n    const rightID = rpos.item;\n    const typeID = rpos.type;\n    const tname = rpos.tname;\n    const assoc = rpos.assoc;\n    let type = null;\n    let index = 0;\n    if (rightID !== null) {\n        if (getState(store, rightID.client) <= rightID.clock) {\n            return null;\n        }\n        const res = followUndoneDeletions ? followRedone(store, rightID) : getItemWithOffset(store, rightID);\n        const right = res.item;\n        if (!(right instanceof Item)) {\n            return null;\n        }\n        type = /** @type {AbstractType<any>} */ right.parent;\n        if (type._item === null || !type._item.deleted) {\n            index = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1); // adjust position based on left association if necessary\n            let n = right.left;\n            while(n !== null){\n                if (!n.deleted && n.countable) {\n                    index += n.length;\n                }\n                n = n.left;\n            }\n        }\n    } else {\n        if (tname !== null) {\n            type = doc.get(tname);\n        } else if (typeID !== null) {\n            if (getState(store, typeID.client) <= typeID.clock) {\n                // type does not exist yet\n                return null;\n            }\n            const { item } = followUndoneDeletions ? followRedone(store, typeID) : {\n                item: getItem(store, typeID)\n            };\n            if (item instanceof Item && item.content instanceof ContentType) {\n                type = item.content.type;\n            } else {\n                // struct is garbage collected\n                return null;\n            }\n        } else {\n            throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n        }\n        if (assoc >= 0) {\n            index = type._length;\n        } else {\n            index = 0;\n        }\n    }\n    return createAbsolutePosition(type, index, rpos.assoc);\n};\n/**\n * @param {RelativePosition|null} a\n * @param {RelativePosition|null} b\n * @return {boolean}\n *\n * @function\n */ const compareRelativePositions = (a, b)=>a === b || a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc;\nclass Snapshot {\n    /**\n   * @param {DeleteSet} ds\n   * @param {Map<number,number>} sv state map\n   */ constructor(ds, sv){\n        /**\n     * @type {DeleteSet}\n     */ this.ds = ds;\n        /**\n     * State Map\n     * @type {Map<number,number>}\n     */ this.sv = sv;\n    }\n}\n/**\n * @param {Snapshot} snap1\n * @param {Snapshot} snap2\n * @return {boolean}\n */ const equalSnapshots = (snap1, snap2)=>{\n    const ds1 = snap1.ds.clients;\n    const ds2 = snap2.ds.clients;\n    const sv1 = snap1.sv;\n    const sv2 = snap2.sv;\n    if (sv1.size !== sv2.size || ds1.size !== ds2.size) {\n        return false;\n    }\n    for (const [key, value] of sv1.entries()){\n        if (sv2.get(key) !== value) {\n            return false;\n        }\n    }\n    for (const [client, dsitems1] of ds1.entries()){\n        const dsitems2 = ds2.get(client) || [];\n        if (dsitems1.length !== dsitems2.length) {\n            return false;\n        }\n        for(let i = 0; i < dsitems1.length; i++){\n            const dsitem1 = dsitems1[i];\n            const dsitem2 = dsitems2[i];\n            if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\n/**\n * @param {Snapshot} snapshot\n * @param {DSEncoderV1 | DSEncoderV2} [encoder]\n * @return {Uint8Array}\n */ const encodeSnapshotV2 = (snapshot, encoder = new DSEncoderV2())=>{\n    writeDeleteSet(encoder, snapshot.ds);\n    writeStateVector(encoder, snapshot.sv);\n    return encoder.toUint8Array();\n};\n/**\n * @param {Snapshot} snapshot\n * @return {Uint8Array}\n */ const encodeSnapshot = (snapshot)=>encodeSnapshotV2(snapshot, new DSEncoderV1());\n/**\n * @param {Uint8Array} buf\n * @param {DSDecoderV1 | DSDecoderV2} [decoder]\n * @return {Snapshot}\n */ const decodeSnapshotV2 = (buf, decoder = new DSDecoderV2(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(buf)))=>{\n    return new Snapshot(readDeleteSet(decoder), readStateVector(decoder));\n};\n/**\n * @param {Uint8Array} buf\n * @return {Snapshot}\n */ const decodeSnapshot = (buf)=>decodeSnapshotV2(buf, new DSDecoderV1(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(buf)));\n/**\n * @param {DeleteSet} ds\n * @param {Map<number,number>} sm\n * @return {Snapshot}\n */ const createSnapshot = (ds, sm)=>new Snapshot(ds, sm);\nconst emptySnapshot = createSnapshot(createDeleteSet(), new Map());\n/**\n * @param {Doc} doc\n * @return {Snapshot}\n */ const snapshot = (doc)=>createSnapshot(createDeleteSetFromStructStore(doc.store), getStateVector(doc.store));\n/**\n * @param {Item} item\n * @param {Snapshot|undefined} snapshot\n *\n * @protected\n * @function\n */ const isVisible = (item, snapshot)=>snapshot === undefined ? !item.deleted : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id);\n/**\n * @param {Transaction} transaction\n * @param {Snapshot} snapshot\n */ const splitSnapshotAffectedStructs = (transaction, snapshot)=>{\n    const meta = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, lib0_set__WEBPACK_IMPORTED_MODULE_12__.create);\n    const store = transaction.doc.store;\n    // check if we already split for this snapshot\n    if (!meta.has(snapshot)) {\n        snapshot.sv.forEach((clock, client)=>{\n            if (clock < getState(store, client)) {\n                getItemCleanStart(transaction, createID(client, clock));\n            }\n        });\n        iterateDeletedStructs(transaction, snapshot.ds, (_item)=>{});\n        meta.add(snapshot);\n    }\n};\n/**\n * @example\n *  const ydoc = new Y.Doc({ gc: false })\n *  ydoc.getText().insert(0, 'world!')\n *  const snapshot = Y.snapshot(ydoc)\n *  ydoc.getText().insert(0, 'hello ')\n *  const restored = Y.createDocFromSnapshot(ydoc, snapshot)\n *  assert(restored.getText().toString() === 'world!')\n *\n * @param {Doc} originDoc\n * @param {Snapshot} snapshot\n * @param {Doc} [newDoc] Optionally, you may define the Yjs document that receives the data from originDoc\n * @return {Doc}\n */ const createDocFromSnapshot = (originDoc, snapshot, newDoc = new Doc())=>{\n    if (originDoc.gc) {\n        // we should not try to restore a GC-ed document, because some of the restored items might have their content deleted\n        throw new Error(\"Garbage-collection must be disabled in `originDoc`!\");\n    }\n    const { sv, ds } = snapshot;\n    const encoder = new UpdateEncoderV2();\n    originDoc.transact((transaction)=>{\n        let size = 0;\n        sv.forEach((clock)=>{\n            if (clock > 0) {\n                size++;\n            }\n        });\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, size);\n        // splitting the structs before writing them to the encoder\n        for (const [client, clock] of sv){\n            if (clock === 0) {\n                continue;\n            }\n            if (clock < getState(originDoc.store, client)) {\n                getItemCleanStart(transaction, createID(client, clock));\n            }\n            const structs = originDoc.store.clients.get(client) || [];\n            const lastStructIndex = findIndexSS(structs, clock - 1);\n            // write # encoded structs\n            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, lastStructIndex + 1);\n            encoder.writeClient(client);\n            // first clock written is 0\n            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, 0);\n            for(let i = 0; i <= lastStructIndex; i++){\n                structs[i].write(encoder, 0);\n            }\n        }\n        writeDeleteSet(encoder, ds);\n    });\n    applyUpdateV2(newDoc, encoder.toUint8Array(), \"snapshot\");\n    return newDoc;\n};\n/**\n * @param {Snapshot} snapshot\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]\n */ const snapshotContainsUpdateV2 = (snapshot, update, YDecoder = UpdateDecoderV2)=>{\n    const updateDecoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));\n    const lazyDecoder = new LazyStructReader(updateDecoder, false);\n    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()){\n        if ((snapshot.sv.get(curr.id.client) || 0) < curr.id.clock + curr.length) {\n            return false;\n        }\n    }\n    const mergedDS = mergeDeleteSets([\n        snapshot.ds,\n        readDeleteSet(updateDecoder)\n    ]);\n    return equalDeleteSets(snapshot.ds, mergedDS);\n};\n/**\n * @param {Snapshot} snapshot\n * @param {Uint8Array} update\n */ const snapshotContainsUpdate = (snapshot, update)=>snapshotContainsUpdateV2(snapshot, update, UpdateDecoderV1);\nclass StructStore {\n    constructor(){\n        /**\n     * @type {Map<number,Array<GC|Item>>}\n     */ this.clients = new Map();\n        /**\n     * @type {null | { missing: Map<number, number>, update: Uint8Array }}\n     */ this.pendingStructs = null;\n        /**\n     * @type {null | Uint8Array}\n     */ this.pendingDs = null;\n    }\n}\n/**\n * Return the states as a Map<client,clock>.\n * Note that clock refers to the next expected clock id.\n *\n * @param {StructStore} store\n * @return {Map<number,number>}\n *\n * @public\n * @function\n */ const getStateVector = (store)=>{\n    const sm = new Map();\n    store.clients.forEach((structs, client)=>{\n        const struct = structs[structs.length - 1];\n        sm.set(client, struct.id.clock + struct.length);\n    });\n    return sm;\n};\n/**\n * @param {StructStore} store\n * @param {number} client\n * @return {number}\n *\n * @public\n * @function\n */ const getState = (store, client)=>{\n    const structs = store.clients.get(client);\n    if (structs === undefined) {\n        return 0;\n    }\n    const lastStruct = structs[structs.length - 1];\n    return lastStruct.id.clock + lastStruct.length;\n};\n/**\n * @param {StructStore} store\n * @param {GC|Item} struct\n *\n * @private\n * @function\n */ const addStruct = (store, struct)=>{\n    let structs = store.clients.get(struct.id.client);\n    if (structs === undefined) {\n        structs = [];\n        store.clients.set(struct.id.client, structs);\n    } else {\n        const lastStruct = structs[structs.length - 1];\n        if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {\n            throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n        }\n    }\n    structs.push(struct);\n};\n/**\n * Perform a binary search on a sorted array\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n * @return {number}\n *\n * @private\n * @function\n */ const findIndexSS = (structs, clock)=>{\n    let left = 0;\n    let right = structs.length - 1;\n    let mid = structs[right];\n    let midclock = mid.id.clock;\n    if (midclock === clock) {\n        return right;\n    }\n    // @todo does it even make sense to pivot the search?\n    // If a good split misses, it might actually increase the time to find the correct item.\n    // Currently, the only advantage is that search with pivoting might find the item on the first try.\n    let midindex = lib0_math__WEBPACK_IMPORTED_MODULE_1__.floor(clock / (midclock + mid.length - 1) * right); // pivoting the search\n    while(left <= right){\n        mid = structs[midindex];\n        midclock = mid.id.clock;\n        if (midclock <= clock) {\n            if (clock < midclock + mid.length) {\n                return midindex;\n            }\n            left = midindex + 1;\n        } else {\n            right = midindex - 1;\n        }\n        midindex = lib0_math__WEBPACK_IMPORTED_MODULE_1__.floor((left + right) / 2);\n    }\n    // Always check state before looking for a struct in StructStore\n    // Therefore the case of not finding a struct is unexpected\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n};\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {GC|Item}\n *\n * @private\n * @function\n */ const find = (store, id)=>{\n    /**\n   * @type {Array<GC|Item>}\n   */ // @ts-ignore\n    const structs = store.clients.get(id.client);\n    return structs[findIndexSS(structs, id.clock)];\n};\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n * @private\n * @function\n */ const getItem = /** @type {function(StructStore,ID):Item} */ find;\n/**\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n */ const findIndexCleanStart = (transaction, structs, clock)=>{\n    const index = findIndexSS(structs, clock);\n    const struct = structs[index];\n    if (struct.id.clock < clock && struct instanceof Item) {\n        structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n        return index + 1;\n    }\n    return index;\n};\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */ const getItemCleanStart = (transaction, id)=>{\n    const structs = /** @type {Array<Item>} */ transaction.doc.store.clients.get(id.client);\n    return structs[findIndexCleanStart(transaction, structs, id.clock)];\n};\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */ const getItemCleanEnd = (transaction, store, id)=>{\n    /**\n   * @type {Array<Item>}\n   */ // @ts-ignore\n    const structs = store.clients.get(id.client);\n    const index = findIndexSS(structs, id.clock);\n    const struct = structs[index];\n    if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {\n        structs.splice(index + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1));\n    }\n    return struct;\n};\n/**\n * Replace `item` with `newitem` in store\n * @param {StructStore} store\n * @param {GC|Item} struct\n * @param {GC|Item} newStruct\n *\n * @private\n * @function\n */ const replaceStruct = (store, struct, newStruct)=>{\n    const structs = /** @type {Array<GC|Item>} */ store.clients.get(struct.id.client);\n    structs[findIndexSS(structs, struct.id.clock)] = newStruct;\n};\n/**\n * Iterate over a range of structs\n *\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clockStart Inclusive start\n * @param {number} len\n * @param {function(GC|Item):void} f\n *\n * @function\n */ const iterateStructs = (transaction, structs, clockStart, len, f)=>{\n    if (len === 0) {\n        return;\n    }\n    const clockEnd = clockStart + len;\n    let index = findIndexCleanStart(transaction, structs, clockStart);\n    let struct;\n    do {\n        struct = structs[index++];\n        if (clockEnd < struct.id.clock + struct.length) {\n            findIndexCleanStart(transaction, structs, clockEnd);\n        }\n        f(struct);\n    }while (index < structs.length && structs[index].id.clock < clockEnd);\n};\n/**\n * A transaction is created for every change on the Yjs model. It is possible\n * to bundle changes on the Yjs model in a single transaction to\n * minimize the number on messages sent and the number of observer calls.\n * If possible the user of this library should bundle as many changes as\n * possible. Here is an example to illustrate the advantages of bundling:\n *\n * @example\n * const ydoc = new Y.Doc()\n * const map = ydoc.getMap('map')\n * // Log content when change is triggered\n * map.observe(() => {\n *   console.log('change triggered')\n * })\n * // Each change on the map type triggers a log message:\n * map.set('a', 0) // => \"change triggered\"\n * map.set('b', 0) // => \"change triggered\"\n * // When put in a transaction, it will trigger the log after the transaction:\n * ydoc.transact(() => {\n *   map.set('a', 1)\n *   map.set('b', 1)\n * }) // => \"change triggered\"\n *\n * @public\n */ class Transaction {\n    /**\n   * @param {Doc} doc\n   * @param {any} origin\n   * @param {boolean} local\n   */ constructor(doc, origin, local){\n        /**\n     * The Yjs instance.\n     * @type {Doc}\n     */ this.doc = doc;\n        /**\n     * Describes the set of deleted items by ids\n     * @type {DeleteSet}\n     */ this.deleteSet = new DeleteSet();\n        /**\n     * Holds the state before the transaction started.\n     * @type {Map<Number,Number>}\n     */ this.beforeState = getStateVector(doc.store);\n        /**\n     * Holds the state after the transaction.\n     * @type {Map<Number,Number>}\n     */ this.afterState = new Map();\n        /**\n     * All types that were directly modified (property added or child\n     * inserted/deleted). New types are not included in this Set.\n     * Maps from type to parentSubs (`item.parentSub = null` for YArray)\n     * @type {Map<AbstractType<YEvent<any>>,Set<String|null>>}\n     */ this.changed = new Map();\n        /**\n     * Stores the events for the types that observe also child elements.\n     * It is mainly used by `observeDeep`.\n     * @type {Map<AbstractType<YEvent<any>>,Array<YEvent<any>>>}\n     */ this.changedParentTypes = new Map();\n        /**\n     * @type {Array<AbstractStruct>}\n     */ this._mergeStructs = [];\n        /**\n     * @type {any}\n     */ this.origin = origin;\n        /**\n     * Stores meta information on the transaction\n     * @type {Map<any,any>}\n     */ this.meta = new Map();\n        /**\n     * Whether this change originates from this doc.\n     * @type {boolean}\n     */ this.local = local;\n        /**\n     * @type {Set<Doc>}\n     */ this.subdocsAdded = new Set();\n        /**\n     * @type {Set<Doc>}\n     */ this.subdocsRemoved = new Set();\n        /**\n     * @type {Set<Doc>}\n     */ this.subdocsLoaded = new Set();\n        /**\n     * @type {boolean}\n     */ this._needFormattingCleanup = false;\n    }\n}\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n * @return {boolean} Whether data was written.\n */ const writeUpdateMessageFromTransaction = (encoder, transaction)=>{\n    if (transaction.deleteSet.clients.size === 0 && !lib0_map__WEBPACK_IMPORTED_MODULE_3__.any(transaction.afterState, (clock, client)=>transaction.beforeState.get(client) !== clock)) {\n        return false;\n    }\n    sortAndMergeDeleteSet(transaction.deleteSet);\n    writeStructsFromTransaction(encoder, transaction);\n    writeDeleteSet(encoder, transaction.deleteSet);\n    return true;\n};\n/**\n * If `type.parent` was added in current transaction, `type` technically\n * did not change, it was just added and we should not fire events for `type`.\n *\n * @param {Transaction} transaction\n * @param {AbstractType<YEvent<any>>} type\n * @param {string|null} parentSub\n */ const addChangedTypeToTransaction = (transaction, type, parentSub)=>{\n    const item = type._item;\n    if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {\n        lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(transaction.changed, type, lib0_set__WEBPACK_IMPORTED_MODULE_12__.create).add(parentSub);\n    }\n};\n/**\n * @param {Array<AbstractStruct>} structs\n * @param {number} pos\n * @return {number} # of merged structs\n */ const tryToMergeWithLefts = (structs, pos)=>{\n    let right = structs[pos];\n    let left = structs[pos - 1];\n    let i = pos;\n    for(; i > 0; right = left, left = structs[--i - 1]){\n        if (left.deleted === right.deleted && left.constructor === right.constructor) {\n            if (left.mergeWith(right)) {\n                if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */ right.parent._map.get(right.parentSub) === right) {\n                    /** @type {AbstractType<any>} */ right.parent._map.set(right.parentSub, /** @type {Item} */ left);\n                }\n                continue;\n            }\n        }\n        break;\n    }\n    const merged = pos - i;\n    if (merged) {\n        // remove all merged structs from the array\n        structs.splice(pos + 1 - merged, merged);\n    }\n    return merged;\n};\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */ const tryGcDeleteSet = (ds, store, gcFilter)=>{\n    for (const [client, deleteItems] of ds.clients.entries()){\n        const structs = /** @type {Array<GC|Item>} */ store.clients.get(client);\n        for(let di = deleteItems.length - 1; di >= 0; di--){\n            const deleteItem = deleteItems[di];\n            const endDeleteItemClock = deleteItem.clock + deleteItem.len;\n            for(let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]){\n                const struct = structs[si];\n                if (deleteItem.clock + deleteItem.len <= struct.id.clock) {\n                    break;\n                }\n                if (struct instanceof Item && struct.deleted && !struct.keep && gcFilter(struct)) {\n                    struct.gc(store, false);\n                }\n            }\n        }\n    }\n};\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n */ const tryMergeDeleteSet = (ds, store)=>{\n    // try to merge deleted / gc'd items\n    // merge from right to left for better efficiency and so we don't miss any merge targets\n    ds.clients.forEach((deleteItems, client)=>{\n        const structs = /** @type {Array<GC|Item>} */ store.clients.get(client);\n        for(let di = deleteItems.length - 1; di >= 0; di--){\n            const deleteItem = deleteItems[di];\n            // start with merging the item next to the last deleted item\n            const mostRightIndexToCheck = lib0_math__WEBPACK_IMPORTED_MODULE_1__.min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));\n            for(let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si]){\n                si -= 1 + tryToMergeWithLefts(structs, si);\n            }\n        }\n    });\n};\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */ const tryGc = (ds, store, gcFilter)=>{\n    tryGcDeleteSet(ds, store, gcFilter);\n    tryMergeDeleteSet(ds, store);\n};\n/**\n * @param {Array<Transaction>} transactionCleanups\n * @param {number} i\n */ const cleanupTransactions = (transactionCleanups, i)=>{\n    if (i < transactionCleanups.length) {\n        const transaction = transactionCleanups[i];\n        const doc = transaction.doc;\n        const store = doc.store;\n        const ds = transaction.deleteSet;\n        const mergeStructs = transaction._mergeStructs;\n        try {\n            sortAndMergeDeleteSet(ds);\n            transaction.afterState = getStateVector(transaction.doc.store);\n            doc.emit(\"beforeObserverCalls\", [\n                transaction,\n                doc\n            ]);\n            /**\n       * An array of event callbacks.\n       *\n       * Each callback is called even if the other ones throw errors.\n       *\n       * @type {Array<function():void>}\n       */ const fs = [];\n            // observe events on changed types\n            transaction.changed.forEach((subs, itemtype)=>fs.push(()=>{\n                    if (itemtype._item === null || !itemtype._item.deleted) {\n                        itemtype._callObserver(transaction, subs);\n                    }\n                }));\n            fs.push(()=>{\n                // deep observe events\n                transaction.changedParentTypes.forEach((events, type)=>{\n                    // We need to think about the possibility that the user transforms the\n                    // Y.Doc in the event.\n                    if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {\n                        events = events.filter((event)=>event.target._item === null || !event.target._item.deleted);\n                        events.forEach((event)=>{\n                            event.currentTarget = type;\n                            // path is relative to the current target\n                            event._path = null;\n                        });\n                        // sort events by path length so that top-level events are fired first.\n                        events.sort((event1, event2)=>event1.path.length - event2.path.length);\n                        // We don't need to check for events.length\n                        // because we know it has at least one element\n                        callEventHandlerListeners(type._dEH, events, transaction);\n                    }\n                });\n            });\n            fs.push(()=>doc.emit(\"afterTransaction\", [\n                    transaction,\n                    doc\n                ]));\n            (0,lib0_function__WEBPACK_IMPORTED_MODULE_11__.callAll)(fs, []);\n            if (transaction._needFormattingCleanup) {\n                cleanupYTextAfterTransaction(transaction);\n            }\n        } finally{\n            // Replace deleted items with ItemDeleted / GC.\n            // This is where content is actually remove from the Yjs Doc.\n            if (doc.gc) {\n                tryGcDeleteSet(ds, store, doc.gcFilter);\n            }\n            tryMergeDeleteSet(ds, store);\n            // on all affected store.clients props, try to merge\n            transaction.afterState.forEach((clock, client)=>{\n                const beforeClock = transaction.beforeState.get(client) || 0;\n                if (beforeClock !== clock) {\n                    const structs = /** @type {Array<GC|Item>} */ store.clients.get(client);\n                    // we iterate from right to left so we can safely remove entries\n                    const firstChangePos = lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(findIndexSS(structs, beforeClock), 1);\n                    for(let i = structs.length - 1; i >= firstChangePos;){\n                        i -= 1 + tryToMergeWithLefts(structs, i);\n                    }\n                }\n            });\n            // try to merge mergeStructs\n            // @todo: it makes more sense to transform mergeStructs to a DS, sort it, and merge from right to left\n            //        but at the moment DS does not handle duplicates\n            for(let i = mergeStructs.length - 1; i >= 0; i--){\n                const { client, clock } = mergeStructs[i].id;\n                const structs = /** @type {Array<GC|Item>} */ store.clients.get(client);\n                const replacedStructPos = findIndexSS(structs, clock);\n                if (replacedStructPos + 1 < structs.length) {\n                    if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {\n                        continue; // no need to perform next check, both are already merged\n                    }\n                }\n                if (replacedStructPos > 0) {\n                    tryToMergeWithLefts(structs, replacedStructPos);\n                }\n            }\n            if (!transaction.local && transaction.afterState.get(doc.clientID) !== transaction.beforeState.get(doc.clientID)) {\n                lib0_logging__WEBPACK_IMPORTED_MODULE_13__.print(lib0_logging__WEBPACK_IMPORTED_MODULE_14__.ORANGE, lib0_logging__WEBPACK_IMPORTED_MODULE_14__.BOLD, \"[yjs] \", lib0_logging__WEBPACK_IMPORTED_MODULE_14__.UNBOLD, lib0_logging__WEBPACK_IMPORTED_MODULE_14__.RED, \"Changed the client-id because another client seems to be using it.\");\n                doc.clientID = generateNewClientId();\n            }\n            // @todo Merge all the transactions into one and provide send the data as a single update message\n            doc.emit(\"afterTransactionCleanup\", [\n                transaction,\n                doc\n            ]);\n            if (doc._observers.has(\"update\")) {\n                const encoder = new UpdateEncoderV1();\n                const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);\n                if (hasContent) {\n                    doc.emit(\"update\", [\n                        encoder.toUint8Array(),\n                        transaction.origin,\n                        doc,\n                        transaction\n                    ]);\n                }\n            }\n            if (doc._observers.has(\"updateV2\")) {\n                const encoder = new UpdateEncoderV2();\n                const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);\n                if (hasContent) {\n                    doc.emit(\"updateV2\", [\n                        encoder.toUint8Array(),\n                        transaction.origin,\n                        doc,\n                        transaction\n                    ]);\n                }\n            }\n            const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;\n            if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {\n                subdocsAdded.forEach((subdoc)=>{\n                    subdoc.clientID = doc.clientID;\n                    if (subdoc.collectionid == null) {\n                        subdoc.collectionid = doc.collectionid;\n                    }\n                    doc.subdocs.add(subdoc);\n                });\n                subdocsRemoved.forEach((subdoc)=>doc.subdocs.delete(subdoc));\n                doc.emit(\"subdocs\", [\n                    {\n                        loaded: subdocsLoaded,\n                        added: subdocsAdded,\n                        removed: subdocsRemoved\n                    },\n                    doc,\n                    transaction\n                ]);\n                subdocsRemoved.forEach((subdoc)=>subdoc.destroy());\n            }\n            if (transactionCleanups.length <= i + 1) {\n                doc._transactionCleanups = [];\n                doc.emit(\"afterAllTransactions\", [\n                    doc,\n                    transactionCleanups\n                ]);\n            } else {\n                cleanupTransactions(transactionCleanups, i + 1);\n            }\n        }\n    }\n};\n/**\n * Implements the functionality of `y.transact(()=>{..})`\n *\n * @template T\n * @param {Doc} doc\n * @param {function(Transaction):T} f\n * @param {any} [origin=true]\n * @return {T}\n *\n * @function\n */ const transact = (doc, f, origin = null, local = true)=>{\n    const transactionCleanups = doc._transactionCleanups;\n    let initialCall = false;\n    /**\n   * @type {any}\n   */ let result = null;\n    if (doc._transaction === null) {\n        initialCall = true;\n        doc._transaction = new Transaction(doc, origin, local);\n        transactionCleanups.push(doc._transaction);\n        if (transactionCleanups.length === 1) {\n            doc.emit(\"beforeAllTransactions\", [\n                doc\n            ]);\n        }\n        doc.emit(\"beforeTransaction\", [\n            doc._transaction,\n            doc\n        ]);\n    }\n    try {\n        result = f(doc._transaction);\n    } finally{\n        if (initialCall) {\n            const finishCleanup = doc._transaction === transactionCleanups[0];\n            doc._transaction = null;\n            if (finishCleanup) {\n                // The first transaction ended, now process observer calls.\n                // Observer call may create new transactions for which we need to call the observers and do cleanup.\n                // We don't want to nest these calls, so we execute these calls one after\n                // another.\n                // Also we need to ensure that all cleanups are called, even if the\n                // observes throw errors.\n                // This file is full of hacky try {} finally {} blocks to ensure that an\n                // event can throw errors and also that the cleanup is called.\n                cleanupTransactions(transactionCleanups, 0);\n            }\n        }\n    }\n    return result;\n};\nclass StackItem {\n    /**\n   * @param {DeleteSet} deletions\n   * @param {DeleteSet} insertions\n   */ constructor(deletions, insertions){\n        this.insertions = insertions;\n        this.deletions = deletions;\n        /**\n     * Use this to save and restore metadata like selection range\n     */ this.meta = new Map();\n    }\n}\n/**\n * @param {Transaction} tr\n * @param {UndoManager} um\n * @param {StackItem} stackItem\n */ const clearUndoManagerStackItem = (tr, um, stackItem)=>{\n    iterateDeletedStructs(tr, stackItem.deletions, (item)=>{\n        if (item instanceof Item && um.scope.some((type)=>type === tr.doc || isParentOf(/** @type {AbstractType<any>} */ type, item))) {\n            keepItem(item, false);\n        }\n    });\n};\n/**\n * @param {UndoManager} undoManager\n * @param {Array<StackItem>} stack\n * @param {'undo'|'redo'} eventType\n * @return {StackItem?}\n */ const popStackItem = (undoManager, stack, eventType)=>{\n    /**\n   * Keep a reference to the transaction so we can fire the event with the changedParentTypes\n   * @type {any}\n   */ let _tr = null;\n    const doc = undoManager.doc;\n    const scope = undoManager.scope;\n    transact(doc, (transaction)=>{\n        while(stack.length > 0 && undoManager.currStackItem === null){\n            const store = doc.store;\n            const stackItem = /** @type {StackItem} */ stack.pop();\n            /**\n       * @type {Set<Item>}\n       */ const itemsToRedo = new Set();\n            /**\n       * @type {Array<Item>}\n       */ const itemsToDelete = [];\n            let performedChange = false;\n            iterateDeletedStructs(transaction, stackItem.insertions, (struct)=>{\n                if (struct instanceof Item) {\n                    if (struct.redone !== null) {\n                        let { item, diff } = followRedone(store, struct.id);\n                        if (diff > 0) {\n                            item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));\n                        }\n                        struct = item;\n                    }\n                    if (!struct.deleted && scope.some((type)=>type === transaction.doc || isParentOf(/** @type {AbstractType<any>} */ type, /** @type {Item} */ struct))) {\n                        itemsToDelete.push(struct);\n                    }\n                }\n            });\n            iterateDeletedStructs(transaction, stackItem.deletions, (struct)=>{\n                if (struct instanceof Item && scope.some((type)=>type === transaction.doc || isParentOf(/** @type {AbstractType<any>} */ type, struct)) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.\n                !isDeleted(stackItem.insertions, struct.id)) {\n                    itemsToRedo.add(struct);\n                }\n            });\n            itemsToRedo.forEach((struct)=>{\n                performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;\n            });\n            // We want to delete in reverse order so that children are deleted before\n            // parents, so we have more information available when items are filtered.\n            for(let i = itemsToDelete.length - 1; i >= 0; i--){\n                const item = itemsToDelete[i];\n                if (undoManager.deleteFilter(item)) {\n                    item.delete(transaction);\n                    performedChange = true;\n                }\n            }\n            undoManager.currStackItem = performedChange ? stackItem : null;\n        }\n        transaction.changed.forEach((subProps, type)=>{\n            // destroy search marker if necessary\n            if (subProps.has(null) && type._searchMarker) {\n                type._searchMarker.length = 0;\n            }\n        });\n        _tr = transaction;\n    }, undoManager);\n    const res = undoManager.currStackItem;\n    if (res != null) {\n        const changedParentTypes = _tr.changedParentTypes;\n        undoManager.emit(\"stack-item-popped\", [\n            {\n                stackItem: res,\n                type: eventType,\n                changedParentTypes,\n                origin: undoManager\n            },\n            undoManager\n        ]);\n        undoManager.currStackItem = null;\n    }\n    return res;\n};\n/**\n * @typedef {Object} UndoManagerOptions\n * @property {number} [UndoManagerOptions.captureTimeout=500]\n * @property {function(Transaction):boolean} [UndoManagerOptions.captureTransaction] Do not capture changes of a Transaction if result false.\n * @property {function(Item):boolean} [UndoManagerOptions.deleteFilter=()=>true] Sometimes\n * it is necessary to filter what an Undo/Redo operation can delete. If this\n * filter returns false, the type/item won't be deleted even it is in the\n * undo/redo scope.\n * @property {Set<any>} [UndoManagerOptions.trackedOrigins=new Set([null])]\n * @property {boolean} [ignoreRemoteMapChanges] Experimental. By default, the UndoManager will never overwrite remote changes. Enable this property to enable overwriting remote changes on key-value changes (Y.Map, properties on Y.Xml, etc..).\n * @property {Doc} [doc] The document that this UndoManager operates on. Only needed if typeScope is empty.\n */ /**\n * @typedef {Object} StackItemEvent\n * @property {StackItem} StackItemEvent.stackItem\n * @property {any} StackItemEvent.origin\n * @property {'undo'|'redo'} StackItemEvent.type\n * @property {Map<AbstractType<YEvent<any>>,Array<YEvent<any>>>} StackItemEvent.changedParentTypes\n */ /**\n * Fires 'stack-item-added' event when a stack item was added to either the undo- or\n * the redo-stack. You may store additional stack information via the\n * metadata property on `event.stackItem.meta` (it is a `Map` of metadata properties).\n * Fires 'stack-item-popped' event when a stack item was popped from either the\n * undo- or the redo-stack. You may restore the saved stack information from `event.stackItem.meta`.\n *\n * @extends {ObservableV2<{'stack-item-added':function(StackItemEvent, UndoManager):void, 'stack-item-popped': function(StackItemEvent, UndoManager):void, 'stack-cleared': function({ undoStackCleared: boolean, redoStackCleared: boolean }):void, 'stack-item-updated': function(StackItemEvent, UndoManager):void }>}\n */ class UndoManager extends lib0_observable__WEBPACK_IMPORTED_MODULE_0__.ObservableV2 {\n    /**\n   * @param {Doc|AbstractType<any>|Array<AbstractType<any>>} typeScope Limits the scope of the UndoManager. If this is set to a ydoc instance, all changes on that ydoc will be undone. If set to a specific type, only changes on that type or its children will be undone. Also accepts an array of types.\n   * @param {UndoManagerOptions} options\n   */ constructor(typeScope, { captureTimeout = 500, captureTransaction = (_tr)=>true, deleteFilter = ()=>true, trackedOrigins = new Set([\n        null\n    ]), ignoreRemoteMapChanges = false, doc = /** @type {Doc} */ lib0_array__WEBPACK_IMPORTED_MODULE_2__.isArray(typeScope) ? typeScope[0].doc : typeScope instanceof Doc ? typeScope : typeScope.doc } = {}){\n        super();\n        /**\n     * @type {Array<AbstractType<any> | Doc>}\n     */ this.scope = [];\n        this.doc = doc;\n        this.addToScope(typeScope);\n        this.deleteFilter = deleteFilter;\n        trackedOrigins.add(this);\n        this.trackedOrigins = trackedOrigins;\n        this.captureTransaction = captureTransaction;\n        /**\n     * @type {Array<StackItem>}\n     */ this.undoStack = [];\n        /**\n     * @type {Array<StackItem>}\n     */ this.redoStack = [];\n        /**\n     * Whether the client is currently undoing (calling UndoManager.undo)\n     *\n     * @type {boolean}\n     */ this.undoing = false;\n        this.redoing = false;\n        /**\n     * The currently popped stack item if UndoManager.undoing or UndoManager.redoing\n     *\n     * @type {StackItem|null}\n     */ this.currStackItem = null;\n        this.lastChange = 0;\n        this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;\n        this.captureTimeout = captureTimeout;\n        /**\n     * @param {Transaction} transaction\n     */ this.afterTransactionHandler = (transaction)=>{\n            // Only track certain transactions\n            if (!this.captureTransaction(transaction) || !this.scope.some((type)=>transaction.changedParentTypes.has(/** @type {AbstractType<any>} */ type) || type === this.doc) || !this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor))) {\n                return;\n            }\n            const undoing = this.undoing;\n            const redoing = this.redoing;\n            const stack = undoing ? this.redoStack : this.undoStack;\n            if (undoing) {\n                this.stopCapturing(); // next undo should not be appended to last stack item\n            } else if (!redoing) {\n                // neither undoing nor redoing: delete redoStack\n                this.clear(false, true);\n            }\n            const insertions = new DeleteSet();\n            transaction.afterState.forEach((endClock, client)=>{\n                const startClock = transaction.beforeState.get(client) || 0;\n                const len = endClock - startClock;\n                if (len > 0) {\n                    addToDeleteSet(insertions, client, startClock, len);\n                }\n            });\n            const now = lib0_time__WEBPACK_IMPORTED_MODULE_15__.getUnixTime();\n            let didAdd = false;\n            if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {\n                // append change to last stack op\n                const lastOp = stack[stack.length - 1];\n                lastOp.deletions = mergeDeleteSets([\n                    lastOp.deletions,\n                    transaction.deleteSet\n                ]);\n                lastOp.insertions = mergeDeleteSets([\n                    lastOp.insertions,\n                    insertions\n                ]);\n            } else {\n                // create a new stack op\n                stack.push(new StackItem(transaction.deleteSet, insertions));\n                didAdd = true;\n            }\n            if (!undoing && !redoing) {\n                this.lastChange = now;\n            }\n            // make sure that deleted structs are not gc'd\n            iterateDeletedStructs(transaction, transaction.deleteSet, /** @param {Item|GC} item */ (item)=>{\n                if (item instanceof Item && this.scope.some((type)=>type === transaction.doc || isParentOf(/** @type {AbstractType<any>} */ type, item))) {\n                    keepItem(item, true);\n                }\n            });\n            /**\n       * @type {[StackItemEvent, UndoManager]}\n       */ const changeEvent = [\n                {\n                    stackItem: stack[stack.length - 1],\n                    origin: transaction.origin,\n                    type: undoing ? \"redo\" : \"undo\",\n                    changedParentTypes: transaction.changedParentTypes\n                },\n                this\n            ];\n            if (didAdd) {\n                this.emit(\"stack-item-added\", changeEvent);\n            } else {\n                this.emit(\"stack-item-updated\", changeEvent);\n            }\n        };\n        this.doc.on(\"afterTransaction\", this.afterTransactionHandler);\n        this.doc.on(\"destroy\", ()=>{\n            this.destroy();\n        });\n    }\n    /**\n   * Extend the scope.\n   *\n   * @param {Array<AbstractType<any> | Doc> | AbstractType<any> | Doc} ytypes\n   */ addToScope(ytypes) {\n        const tmpSet = new Set(this.scope);\n        ytypes = lib0_array__WEBPACK_IMPORTED_MODULE_2__.isArray(ytypes) ? ytypes : [\n            ytypes\n        ];\n        ytypes.forEach((ytype)=>{\n            if (!tmpSet.has(ytype)) {\n                tmpSet.add(ytype);\n                if (ytype instanceof AbstractType ? ytype.doc !== this.doc : ytype !== this.doc) lib0_logging__WEBPACK_IMPORTED_MODULE_13__.warn(\"[yjs#509] Not same Y.Doc\"); // use MultiDocUndoManager instead. also see https://github.com/yjs/yjs/issues/509\n                this.scope.push(ytype);\n            }\n        });\n    }\n    /**\n   * @param {any} origin\n   */ addTrackedOrigin(origin) {\n        this.trackedOrigins.add(origin);\n    }\n    /**\n   * @param {any} origin\n   */ removeTrackedOrigin(origin) {\n        this.trackedOrigins.delete(origin);\n    }\n    clear(clearUndoStack = true, clearRedoStack = true) {\n        if (clearUndoStack && this.canUndo() || clearRedoStack && this.canRedo()) {\n            this.doc.transact((tr)=>{\n                if (clearUndoStack) {\n                    this.undoStack.forEach((item)=>clearUndoManagerStackItem(tr, this, item));\n                    this.undoStack = [];\n                }\n                if (clearRedoStack) {\n                    this.redoStack.forEach((item)=>clearUndoManagerStackItem(tr, this, item));\n                    this.redoStack = [];\n                }\n                this.emit(\"stack-cleared\", [\n                    {\n                        undoStackCleared: clearUndoStack,\n                        redoStackCleared: clearRedoStack\n                    }\n                ]);\n            });\n        }\n    }\n    /**\n   * UndoManager merges Undo-StackItem if they are created within time-gap\n   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next\n   * StackItem won't be merged.\n   *\n   *\n   * @example\n   *     // without stopCapturing\n   *     ytext.insert(0, 'a')\n   *     ytext.insert(1, 'b')\n   *     um.undo()\n   *     ytext.toString() // => '' (note that 'ab' was removed)\n   *     // with stopCapturing\n   *     ytext.insert(0, 'a')\n   *     um.stopCapturing()\n   *     ytext.insert(0, 'b')\n   *     um.undo()\n   *     ytext.toString() // => 'a' (note that only 'b' was removed)\n   *\n   */ stopCapturing() {\n        this.lastChange = 0;\n    }\n    /**\n   * Undo last changes on type.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */ undo() {\n        this.undoing = true;\n        let res;\n        try {\n            res = popStackItem(this, this.undoStack, \"undo\");\n        } finally{\n            this.undoing = false;\n        }\n        return res;\n    }\n    /**\n   * Redo last undo operation.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */ redo() {\n        this.redoing = true;\n        let res;\n        try {\n            res = popStackItem(this, this.redoStack, \"redo\");\n        } finally{\n            this.redoing = false;\n        }\n        return res;\n    }\n    /**\n   * Are undo steps available?\n   *\n   * @return {boolean} `true` if undo is possible\n   */ canUndo() {\n        return this.undoStack.length > 0;\n    }\n    /**\n   * Are redo steps available?\n   *\n   * @return {boolean} `true` if redo is possible\n   */ canRedo() {\n        return this.redoStack.length > 0;\n    }\n    destroy() {\n        this.trackedOrigins.delete(this);\n        this.doc.off(\"afterTransaction\", this.afterTransactionHandler);\n        super.destroy();\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n */ function* lazyStructReaderGenerator(decoder) {\n    const numOfStateUpdates = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    for(let i = 0; i < numOfStateUpdates; i++){\n        const numberOfStructs = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        const client = decoder.readClient();\n        let clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        for(let i = 0; i < numberOfStructs; i++){\n            const info = decoder.readInfo();\n            // @todo use switch instead of ifs\n            if (info === 10) {\n                const len = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n                yield new Skip(createID(client, clock), len);\n                clock += len;\n            } else if ((lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BITS5 & info) !== 0) {\n                const cantCopyParentInfo = (info & (lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7 | lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8)) === 0;\n                // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n                // and we read the next string as parentYKey.\n                // It indicates how we store/retrieve parent from `y.share`\n                // @type {string|null}\n                const struct = new Item(createID(client, clock), null, (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8 ? decoder.readLeftID() : null, null, (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7 ? decoder.readRightID() : null, // @ts-ignore Force writing a string here.\n                cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null, cantCopyParentInfo && (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6 ? decoder.readString() : null, readItemContent(decoder, info) // item content\n                );\n                yield struct;\n                clock += struct.length;\n            } else {\n                const len = decoder.readLen();\n                yield new GC(createID(client, clock), len);\n                clock += len;\n            }\n        }\n    }\n}\nclass LazyStructReader {\n    /**\n   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n   * @param {boolean} filterSkips\n   */ constructor(decoder, filterSkips){\n        this.gen = lazyStructReaderGenerator(decoder);\n        /**\n     * @type {null | Item | Skip | GC}\n     */ this.curr = null;\n        this.done = false;\n        this.filterSkips = filterSkips;\n        this.next();\n    }\n    /**\n   * @return {Item | GC | Skip |null}\n   */ next() {\n        // ignore \"Skip\" structs\n        do {\n            this.curr = this.gen.next().value || null;\n        }while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);\n        return this.curr;\n    }\n}\n/**\n * @param {Uint8Array} update\n *\n */ const logUpdate = (update)=>logUpdateV2(update, UpdateDecoderV1);\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]\n *\n */ const logUpdateV2 = (update, YDecoder = UpdateDecoderV2)=>{\n    const structs = [];\n    const updateDecoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));\n    const lazyDecoder = new LazyStructReader(updateDecoder, false);\n    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()){\n        structs.push(curr);\n    }\n    lib0_logging__WEBPACK_IMPORTED_MODULE_13__.print(\"Structs: \", structs);\n    const ds = readDeleteSet(updateDecoder);\n    lib0_logging__WEBPACK_IMPORTED_MODULE_13__.print(\"DeleteSet: \", ds);\n};\n/**\n * @param {Uint8Array} update\n *\n */ const decodeUpdate = (update)=>decodeUpdateV2(update, UpdateDecoderV1);\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]\n *\n */ const decodeUpdateV2 = (update, YDecoder = UpdateDecoderV2)=>{\n    const structs = [];\n    const updateDecoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));\n    const lazyDecoder = new LazyStructReader(updateDecoder, false);\n    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()){\n        structs.push(curr);\n    }\n    return {\n        structs,\n        ds: readDeleteSet(updateDecoder)\n    };\n};\nclass LazyStructWriter {\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */ constructor(encoder){\n        this.currClient = 0;\n        this.startClock = 0;\n        this.written = 0;\n        this.encoder = encoder;\n        /**\n     * We want to write operations lazily, but also we need to know beforehand how many operations we want to write for each client.\n     *\n     * This kind of meta-information (#clients, #structs-per-client-written) is written to the restEncoder.\n     *\n     * We fragment the restEncoder and store a slice of it per-client until we know how many clients there are.\n     * When we flush (toUint8Array) we write the restEncoder using the fragments and the meta-information.\n     *\n     * @type {Array<{ written: number, restEncoder: Uint8Array }>}\n     */ this.clientStructs = [];\n    }\n}\n/**\n * @param {Array<Uint8Array>} updates\n * @return {Uint8Array}\n */ const mergeUpdates = (updates)=>mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);\n/**\n * @param {Uint8Array} update\n * @param {typeof DSEncoderV1 | typeof DSEncoderV2} YEncoder\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder\n * @return {Uint8Array}\n */ const encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2)=>{\n    const encoder = new YEncoder();\n    const updateDecoder = new LazyStructReader(new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)), false);\n    let curr = updateDecoder.curr;\n    if (curr !== null) {\n        let size = 0;\n        let currClient = curr.id.client;\n        let stopCounting = curr.id.clock !== 0; // must start at 0\n        let currClock = stopCounting ? 0 : curr.id.clock + curr.length;\n        for(; curr !== null; curr = updateDecoder.next()){\n            if (currClient !== curr.id.client) {\n                if (currClock !== 0) {\n                    size++;\n                    // We found a new client\n                    // write what we have to the encoder\n                    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, currClient);\n                    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, currClock);\n                }\n                currClient = curr.id.client;\n                currClock = 0;\n                stopCounting = curr.id.clock !== 0;\n            }\n            // we ignore skips\n            if (curr.constructor === Skip) {\n                stopCounting = true;\n            }\n            if (!stopCounting) {\n                currClock = curr.id.clock + curr.length;\n            }\n        }\n        // write what we have\n        if (currClock !== 0) {\n            size++;\n            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, currClient);\n            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, currClock);\n        }\n        // prepend the size of the state vector\n        const enc = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(enc, size);\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeBinaryEncoder(enc, encoder.restEncoder);\n        encoder.restEncoder = enc;\n        return encoder.toUint8Array();\n    } else {\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, 0);\n        return encoder.toUint8Array();\n    }\n};\n/**\n * @param {Uint8Array} update\n * @return {Uint8Array}\n */ const encodeStateVectorFromUpdate = (update)=>encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1);\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder\n * @return {{ from: Map<number,number>, to: Map<number,number> }}\n */ const parseUpdateMetaV2 = (update, YDecoder = UpdateDecoderV2)=>{\n    /**\n   * @type {Map<number, number>}\n   */ const from = new Map();\n    /**\n   * @type {Map<number, number>}\n   */ const to = new Map();\n    const updateDecoder = new LazyStructReader(new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)), false);\n    let curr = updateDecoder.curr;\n    if (curr !== null) {\n        let currClient = curr.id.client;\n        let currClock = curr.id.clock;\n        // write the beginning to `from`\n        from.set(currClient, currClock);\n        for(; curr !== null; curr = updateDecoder.next()){\n            if (currClient !== curr.id.client) {\n                // We found a new client\n                // write the end to `to`\n                to.set(currClient, currClock);\n                // write the beginning to `from`\n                from.set(curr.id.client, curr.id.clock);\n                // update currClient\n                currClient = curr.id.client;\n            }\n            currClock = curr.id.clock + curr.length;\n        }\n        // write the end to `to`\n        to.set(currClient, currClock);\n    }\n    return {\n        from,\n        to\n    };\n};\n/**\n * @param {Uint8Array} update\n * @return {{ from: Map<number,number>, to: Map<number,number> }}\n */ const parseUpdateMeta = (update)=>parseUpdateMetaV2(update, UpdateDecoderV1);\n/**\n * This method is intended to slice any kind of struct and retrieve the right part.\n * It does not handle side-effects, so it should only be used by the lazy-encoder.\n *\n * @param {Item | GC | Skip} left\n * @param {number} diff\n * @return {Item | GC}\n */ const sliceStruct = (left, diff)=>{\n    if (left.constructor === GC) {\n        const { client, clock } = left.id;\n        return new GC(createID(client, clock + diff), left.length - diff);\n    } else if (left.constructor === Skip) {\n        const { client, clock } = left.id;\n        return new Skip(createID(client, clock + diff), left.length - diff);\n    } else {\n        const leftItem = /** @type {Item} */ left;\n        const { client, clock } = leftItem.id;\n        return new Item(createID(client, clock + diff), null, createID(client, clock + diff - 1), null, leftItem.rightOrigin, leftItem.parent, leftItem.parentSub, leftItem.content.splice(diff));\n    }\n};\n/**\n *\n * This function works similarly to `readUpdateV2`.\n *\n * @param {Array<Uint8Array>} updates\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n * @return {Uint8Array}\n */ const mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2)=>{\n    if (updates.length === 1) {\n        return updates[0];\n    }\n    const updateDecoders = updates.map((update)=>new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)));\n    let lazyStructDecoders = updateDecoders.map((decoder)=>new LazyStructReader(decoder, true));\n    /**\n   * @todo we don't need offset because we always slice before\n   * @type {null | { struct: Item | GC | Skip, offset: number }}\n   */ let currWrite = null;\n    const updateEncoder = new YEncoder();\n    // write structs lazily\n    const lazyStructEncoder = new LazyStructWriter(updateEncoder);\n    // Note: We need to ensure that all lazyStructDecoders are fully consumed\n    // Note: Should merge document updates whenever possible - even from different updates\n    // Note: Should handle that some operations cannot be applied yet ()\n    while(true){\n        // Write higher clients first ⇒ sort by clientID & clock and remove decoders without content\n        lazyStructDecoders = lazyStructDecoders.filter((dec)=>dec.curr !== null);\n        lazyStructDecoders.sort(/** @type {function(any,any):number} */ (dec1, dec2)=>{\n            if (dec1.curr.id.client === dec2.curr.id.client) {\n                const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;\n                if (clockDiff === 0) {\n                    // @todo remove references to skip since the structDecoders must filter Skips.\n                    return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1 // we are filtering skips anyway.\n                    ;\n                } else {\n                    return clockDiff;\n                }\n            } else {\n                return dec2.curr.id.client - dec1.curr.id.client;\n            }\n        });\n        if (lazyStructDecoders.length === 0) {\n            break;\n        }\n        const currDecoder = lazyStructDecoders[0];\n        // write from currDecoder until the next operation is from another client or if filler-struct\n        // then we need to reorder the decoders and find the next operation to write\n        const firstClient = /** @type {Item | GC} */ currDecoder.curr.id.client;\n        if (currWrite !== null) {\n            let curr = /** @type {Item | GC | null} */ currDecoder.curr;\n            let iterated = false;\n            // iterate until we find something that we haven't written already\n            // remember: first the high client-ids are written\n            while(curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client){\n                curr = currDecoder.next();\n                iterated = true;\n            }\n            if (curr === null || // current decoder is empty\n            curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`\n            iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length // the above while loop was used and we are potentially missing updates\n            ) {\n                continue;\n            }\n            if (firstClient !== currWrite.struct.id.client) {\n                writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n                currWrite = {\n                    struct: curr,\n                    offset: 0\n                };\n                currDecoder.next();\n            } else {\n                if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {\n                    // @todo write currStruct & set currStruct = Skip(clock = currStruct.id.clock + currStruct.length, length = curr.id.clock - self.clock)\n                    if (currWrite.struct.constructor === Skip) {\n                        // extend existing skip\n                        currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;\n                    } else {\n                        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n                        const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;\n                        /**\n             * @type {Skip}\n             */ const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);\n                        currWrite = {\n                            struct,\n                            offset: 0\n                        };\n                    }\n                } else {\n                    const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;\n                    if (diff > 0) {\n                        if (currWrite.struct.constructor === Skip) {\n                            // prefer to slice Skip because the other struct might contain more information\n                            currWrite.struct.length -= diff;\n                        } else {\n                            curr = sliceStruct(curr, diff);\n                        }\n                    }\n                    if (!currWrite.struct.mergeWith(/** @type {any} */ curr)) {\n                        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n                        currWrite = {\n                            struct: curr,\n                            offset: 0\n                        };\n                        currDecoder.next();\n                    }\n                }\n            }\n        } else {\n            currWrite = {\n                struct: /** @type {Item | GC} */ currDecoder.curr,\n                offset: 0\n            };\n            currDecoder.next();\n        }\n        for(let next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()){\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n            currWrite = {\n                struct: next,\n                offset: 0\n            };\n        }\n    }\n    if (currWrite !== null) {\n        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n        currWrite = null;\n    }\n    finishLazyStructWriting(lazyStructEncoder);\n    const dss = updateDecoders.map((decoder)=>readDeleteSet(decoder));\n    const ds = mergeDeleteSets(dss);\n    writeDeleteSet(updateEncoder, ds);\n    return updateEncoder.toUint8Array();\n};\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n */ const diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2)=>{\n    const state = decodeStateVector(sv);\n    const encoder = new YEncoder();\n    const lazyStructWriter = new LazyStructWriter(encoder);\n    const decoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));\n    const reader = new LazyStructReader(decoder, false);\n    while(reader.curr){\n        const curr = reader.curr;\n        const currClient = curr.id.client;\n        const svClock = state.get(currClient) || 0;\n        if (reader.curr.constructor === Skip) {\n            // the first written struct shouldn't be a skip\n            reader.next();\n            continue;\n        }\n        if (curr.id.clock + curr.length > svClock) {\n            writeStructToLazyStructWriter(lazyStructWriter, curr, lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(svClock - curr.id.clock, 0));\n            reader.next();\n            while(reader.curr && reader.curr.id.client === currClient){\n                writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);\n                reader.next();\n            }\n        } else {\n            // read until something new comes up\n            while(reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock){\n                reader.next();\n            }\n        }\n    }\n    finishLazyStructWriting(lazyStructWriter);\n    // write ds\n    const ds = readDeleteSet(decoder);\n    writeDeleteSet(encoder, ds);\n    return encoder.toUint8Array();\n};\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n */ const diffUpdate = (update, sv)=>diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);\n/**\n * @param {LazyStructWriter} lazyWriter\n */ const flushLazyStructWriter = (lazyWriter)=>{\n    if (lazyWriter.written > 0) {\n        lazyWriter.clientStructs.push({\n            written: lazyWriter.written,\n            restEncoder: lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(lazyWriter.encoder.restEncoder)\n        });\n        lazyWriter.encoder.restEncoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();\n        lazyWriter.written = 0;\n    }\n};\n/**\n * @param {LazyStructWriter} lazyWriter\n * @param {Item | GC} struct\n * @param {number} offset\n */ const writeStructToLazyStructWriter = (lazyWriter, struct, offset)=>{\n    // flush curr if we start another client\n    if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {\n        flushLazyStructWriter(lazyWriter);\n    }\n    if (lazyWriter.written === 0) {\n        lazyWriter.currClient = struct.id.client;\n        // write next client\n        lazyWriter.encoder.writeClient(struct.id.client);\n        // write startClock\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);\n    }\n    struct.write(lazyWriter.encoder, offset);\n    lazyWriter.written++;\n};\n/**\n * Call this function when we collected all parts and want to\n * put all the parts together. After calling this method,\n * you can continue using the UpdateEncoder.\n *\n * @param {LazyStructWriter} lazyWriter\n */ const finishLazyStructWriting = (lazyWriter)=>{\n    flushLazyStructWriter(lazyWriter);\n    // this is a fresh encoder because we called flushCurr\n    const restEncoder = lazyWriter.encoder.restEncoder;\n    /**\n   * Now we put all the fragments together.\n   * This works similarly to `writeClientsStructs`\n   */ // write # states that were updated - i.e. the clients\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(restEncoder, lazyWriter.clientStructs.length);\n    for(let i = 0; i < lazyWriter.clientStructs.length; i++){\n        const partStructs = lazyWriter.clientStructs[i];\n        /**\n     * Works similarly to `writeStructs`\n     */ // write # encoded structs\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(restEncoder, partStructs.written);\n        // write the rest of the fragment\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8Array(restEncoder, partStructs.restEncoder);\n    }\n};\n/**\n * @param {Uint8Array} update\n * @param {function(Item|GC|Skip):Item|GC|Skip} blockTransformer\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} YDecoder\n * @param {typeof UpdateEncoderV2 | typeof UpdateEncoderV1 } YEncoder\n */ const convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder)=>{\n    const updateDecoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));\n    const lazyDecoder = new LazyStructReader(updateDecoder, false);\n    const updateEncoder = new YEncoder();\n    const lazyWriter = new LazyStructWriter(updateEncoder);\n    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()){\n        writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);\n    }\n    finishLazyStructWriting(lazyWriter);\n    const ds = readDeleteSet(updateDecoder);\n    writeDeleteSet(updateEncoder, ds);\n    return updateEncoder.toUint8Array();\n};\n/**\n * @typedef {Object} ObfuscatorOptions\n * @property {boolean} [ObfuscatorOptions.formatting=true]\n * @property {boolean} [ObfuscatorOptions.subdocs=true]\n * @property {boolean} [ObfuscatorOptions.yxml=true] Whether to obfuscate nodeName / hookName\n */ /**\n * @param {ObfuscatorOptions} obfuscator\n */ const createObfuscator = ({ formatting = true, subdocs = true, yxml = true } = {})=>{\n    let i = 0;\n    const mapKeyCache = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n    const nodeNameCache = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n    const formattingKeyCache = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n    const formattingValueCache = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n    formattingValueCache.set(null, null); // end of a formatting range should always be the end of a formatting range\n    /**\n   * @param {Item|GC|Skip} block\n   * @return {Item|GC|Skip}\n   */ return (block)=>{\n        switch(block.constructor){\n            case GC:\n            case Skip:\n                return block;\n            case Item:\n                {\n                    const item = /** @type {Item} */ block;\n                    const content = item.content;\n                    switch(content.constructor){\n                        case ContentDeleted:\n                            break;\n                        case ContentType:\n                            {\n                                if (yxml) {\n                                    const type = /** @type {ContentType} */ content.type;\n                                    if (type instanceof YXmlElement) {\n                                        type.nodeName = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(nodeNameCache, type.nodeName, ()=>\"node-\" + i);\n                                    }\n                                    if (type instanceof YXmlHook) {\n                                        type.hookName = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(nodeNameCache, type.hookName, ()=>\"hook-\" + i);\n                                    }\n                                }\n                                break;\n                            }\n                        case ContentAny:\n                            {\n                                const c = /** @type {ContentAny} */ content;\n                                c.arr = c.arr.map(()=>i);\n                                break;\n                            }\n                        case ContentBinary:\n                            {\n                                const c = /** @type {ContentBinary} */ content;\n                                c.content = new Uint8Array([\n                                    i\n                                ]);\n                                break;\n                            }\n                        case ContentDoc:\n                            {\n                                const c = /** @type {ContentDoc} */ content;\n                                if (subdocs) {\n                                    c.opts = {};\n                                    c.doc.guid = i + \"\";\n                                }\n                                break;\n                            }\n                        case ContentEmbed:\n                            {\n                                const c = /** @type {ContentEmbed} */ content;\n                                c.embed = {};\n                                break;\n                            }\n                        case ContentFormat:\n                            {\n                                const c = /** @type {ContentFormat} */ content;\n                                if (formatting) {\n                                    c.key = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(formattingKeyCache, c.key, ()=>i + \"\");\n                                    c.value = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(formattingValueCache, c.value, ()=>({\n                                            i\n                                        }));\n                                }\n                                break;\n                            }\n                        case ContentJSON:\n                            {\n                                const c = /** @type {ContentJSON} */ content;\n                                c.arr = c.arr.map(()=>i);\n                                break;\n                            }\n                        case ContentString:\n                            {\n                                const c = /** @type {ContentString} */ content;\n                                c.str = lib0_string__WEBPACK_IMPORTED_MODULE_16__.repeat(i % 10 + \"\", c.str.length);\n                                break;\n                            }\n                        default:\n                            // unknown content type\n                            lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n                    }\n                    if (item.parentSub) {\n                        item.parentSub = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(mapKeyCache, item.parentSub, ()=>i + \"\");\n                    }\n                    i++;\n                    return block;\n                }\n            default:\n                // unknown block-type\n                lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n        }\n    };\n};\n/**\n * This function obfuscates the content of a Yjs update. This is useful to share\n * buggy Yjs documents while significantly limiting the possibility that a\n * developer can on the user. Note that it might still be possible to deduce\n * some information by analyzing the \"structure\" of the document or by analyzing\n * the typing behavior using the CRDT-related metadata that is still kept fully\n * intact.\n *\n * @param {Uint8Array} update\n * @param {ObfuscatorOptions} [opts]\n */ const obfuscateUpdate = (update, opts)=>convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV1, UpdateEncoderV1);\n/**\n * @param {Uint8Array} update\n * @param {ObfuscatorOptions} [opts]\n */ const obfuscateUpdateV2 = (update, opts)=>convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV2, UpdateEncoderV2);\n/**\n * @param {Uint8Array} update\n */ const convertUpdateFormatV1ToV2 = (update)=>convertUpdateFormat(update, lib0_function__WEBPACK_IMPORTED_MODULE_11__.id, UpdateDecoderV1, UpdateEncoderV2);\n/**\n * @param {Uint8Array} update\n */ const convertUpdateFormatV2ToV1 = (update)=>convertUpdateFormat(update, lib0_function__WEBPACK_IMPORTED_MODULE_11__.id, UpdateDecoderV2, UpdateEncoderV1);\nconst errorComputeChanges = \"You must not compute changes after the event-handler fired.\";\n/**\n * @template {AbstractType<any>} T\n * YEvent describes the changes on a YType.\n */ class YEvent {\n    /**\n   * @param {T} target The changed type.\n   * @param {Transaction} transaction\n   */ constructor(target, transaction){\n        /**\n     * The type on which this event was created on.\n     * @type {T}\n     */ this.target = target;\n        /**\n     * The current target on which the observe callback is called.\n     * @type {AbstractType<any>}\n     */ this.currentTarget = target;\n        /**\n     * The transaction that triggered this event.\n     * @type {Transaction}\n     */ this.transaction = transaction;\n        /**\n     * @type {Object|null}\n     */ this._changes = null;\n        /**\n     * @type {null | Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}\n     */ this._keys = null;\n        /**\n     * @type {null | Array<{ insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any> }>}\n     */ this._delta = null;\n        /**\n     * @type {Array<string|number>|null}\n     */ this._path = null;\n    }\n    /**\n   * Computes the path from `y` to the changed type.\n   *\n   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.\n   *\n   * The following property holds:\n   * @example\n   *   let type = y\n   *   event.path.forEach(dir => {\n   *     type = type.get(dir)\n   *   })\n   *   type === event.target // => true\n   */ get path() {\n        return this._path || (this._path = getPathTo(this.currentTarget, this.target));\n    }\n    /**\n   * Check if a struct is deleted by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */ deletes(struct) {\n        return isDeleted(this.transaction.deleteSet, struct.id);\n    }\n    /**\n   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}\n   */ get keys() {\n        if (this._keys === null) {\n            if (this.transaction.doc._transactionCleanups.length === 0) {\n                throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.create(errorComputeChanges);\n            }\n            const keys = new Map();\n            const target = this.target;\n            const changed = /** @type Set<string|null> */ this.transaction.changed.get(target);\n            changed.forEach((key)=>{\n                if (key !== null) {\n                    const item = /** @type {Item} */ target._map.get(key);\n                    /**\n           * @type {'delete' | 'add' | 'update'}\n           */ let action;\n                    let oldValue;\n                    if (this.adds(item)) {\n                        let prev = item.left;\n                        while(prev !== null && this.adds(prev)){\n                            prev = prev.left;\n                        }\n                        if (this.deletes(item)) {\n                            if (prev !== null && this.deletes(prev)) {\n                                action = \"delete\";\n                                oldValue = lib0_array__WEBPACK_IMPORTED_MODULE_2__.last(prev.content.getContent());\n                            } else {\n                                return;\n                            }\n                        } else {\n                            if (prev !== null && this.deletes(prev)) {\n                                action = \"update\";\n                                oldValue = lib0_array__WEBPACK_IMPORTED_MODULE_2__.last(prev.content.getContent());\n                            } else {\n                                action = \"add\";\n                                oldValue = undefined;\n                            }\n                        }\n                    } else {\n                        if (this.deletes(item)) {\n                            action = \"delete\";\n                            oldValue = lib0_array__WEBPACK_IMPORTED_MODULE_2__.last(/** @type {Item} */ item.content.getContent());\n                        } else {\n                            return; // nop\n                        }\n                    }\n                    keys.set(key, {\n                        action,\n                        oldValue\n                    });\n                }\n            });\n            this._keys = keys;\n        }\n        return this._keys;\n    }\n    /**\n   * This is a computed property. Note that this can only be safely computed during the\n   * event call. Computing this property after other changes happened might result in\n   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes\n   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.\n   *\n   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}\n   */ get delta() {\n        return this.changes.delta;\n    }\n    /**\n   * Check if a struct is added by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */ adds(struct) {\n        return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);\n    }\n    /**\n   * This is a computed property. Note that this can only be safely computed during the\n   * event call. Computing this property after other changes happened might result in\n   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes\n   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.\n   *\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */ get changes() {\n        let changes = this._changes;\n        if (changes === null) {\n            if (this.transaction.doc._transactionCleanups.length === 0) {\n                throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.create(errorComputeChanges);\n            }\n            const target = this.target;\n            const added = lib0_set__WEBPACK_IMPORTED_MODULE_12__.create();\n            const deleted = lib0_set__WEBPACK_IMPORTED_MODULE_12__.create();\n            /**\n       * @type {Array<{insert:Array<any>}|{delete:number}|{retain:number}>}\n       */ const delta = [];\n            changes = {\n                added,\n                deleted,\n                delta,\n                keys: this.keys\n            };\n            const changed = /** @type Set<string|null> */ this.transaction.changed.get(target);\n            if (changed.has(null)) {\n                /**\n         * @type {any}\n         */ let lastOp = null;\n                const packOp = ()=>{\n                    if (lastOp) {\n                        delta.push(lastOp);\n                    }\n                };\n                for(let item = target._start; item !== null; item = item.right){\n                    if (item.deleted) {\n                        if (this.deletes(item) && !this.adds(item)) {\n                            if (lastOp === null || lastOp.delete === undefined) {\n                                packOp();\n                                lastOp = {\n                                    delete: 0\n                                };\n                            }\n                            lastOp.delete += item.length;\n                            deleted.add(item);\n                        } // else nop\n                    } else {\n                        if (this.adds(item)) {\n                            if (lastOp === null || lastOp.insert === undefined) {\n                                packOp();\n                                lastOp = {\n                                    insert: []\n                                };\n                            }\n                            lastOp.insert = lastOp.insert.concat(item.content.getContent());\n                            added.add(item);\n                        } else {\n                            if (lastOp === null || lastOp.retain === undefined) {\n                                packOp();\n                                lastOp = {\n                                    retain: 0\n                                };\n                            }\n                            lastOp.retain += item.length;\n                        }\n                    }\n                }\n                if (lastOp !== null && lastOp.retain === undefined) {\n                    packOp();\n                }\n            }\n            this._changes = changes;\n        }\n        return /** @type {any} */ changes;\n    }\n}\n/**\n * Compute the path from this type to the specified target.\n *\n * @example\n *   // `child` should be accessible via `type.get(path[0]).get(path[1])..`\n *   const path = type.getPathTo(child)\n *   // assuming `type instanceof YArray`\n *   console.log(path) // might look like => [2, 'key1']\n *   child === type.get(path[0]).get(path[1])\n *\n * @param {AbstractType<any>} parent\n * @param {AbstractType<any>} child target\n * @return {Array<string|number>} Path to the target\n *\n * @private\n * @function\n */ const getPathTo = (parent, child)=>{\n    const path = [];\n    while(child._item !== null && child !== parent){\n        if (child._item.parentSub !== null) {\n            // parent is map-ish\n            path.unshift(child._item.parentSub);\n        } else {\n            // parent is array-ish\n            let i = 0;\n            let c = /** @type {AbstractType<any>} */ child._item.parent._start;\n            while(c !== child._item && c !== null){\n                if (!c.deleted && c.countable) {\n                    i += c.length;\n                }\n                c = c.right;\n            }\n            path.unshift(i);\n        }\n        child = /** @type {AbstractType<any>} */ child._item.parent;\n    }\n    return path;\n};\n/**\n * https://docs.yjs.dev/getting-started/working-with-shared-types#caveats\n */ const warnPrematureAccess = ()=>{\n    lib0_logging__WEBPACK_IMPORTED_MODULE_13__.warn(\"Invalid access: Add Yjs type to a document before reading data.\");\n};\nconst maxSearchMarker = 80;\n/**\n * A unique timestamp that identifies each marker.\n *\n * Time is relative,.. this is more like an ever-increasing clock.\n *\n * @type {number}\n */ let globalSearchMarkerTimestamp = 0;\nclass ArraySearchMarker {\n    /**\n   * @param {Item} p\n   * @param {number} index\n   */ constructor(p, index){\n        p.marker = true;\n        this.p = p;\n        this.index = index;\n        this.timestamp = globalSearchMarkerTimestamp++;\n    }\n}\n/**\n * @param {ArraySearchMarker} marker\n */ const refreshMarkerTimestamp = (marker)=>{\n    marker.timestamp = globalSearchMarkerTimestamp++;\n};\n/**\n * This is rather complex so this function is the only thing that should overwrite a marker\n *\n * @param {ArraySearchMarker} marker\n * @param {Item} p\n * @param {number} index\n */ const overwriteMarker = (marker, p, index)=>{\n    marker.p.marker = false;\n    marker.p = p;\n    p.marker = true;\n    marker.index = index;\n    marker.timestamp = globalSearchMarkerTimestamp++;\n};\n/**\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {Item} p\n * @param {number} index\n */ const markPosition = (searchMarker, p, index)=>{\n    if (searchMarker.length >= maxSearchMarker) {\n        // override oldest marker (we don't want to create more objects)\n        const marker = searchMarker.reduce((a, b)=>a.timestamp < b.timestamp ? a : b);\n        overwriteMarker(marker, p, index);\n        return marker;\n    } else {\n        // create new marker\n        const pm = new ArraySearchMarker(p, index);\n        searchMarker.push(pm);\n        return pm;\n    }\n};\n/**\n * Search marker help us to find positions in the associative array faster.\n *\n * They speed up the process of finding a position without much bookkeeping.\n *\n * A maximum of `maxSearchMarker` objects are created.\n *\n * This function always returns a refreshed marker (updated timestamp)\n *\n * @param {AbstractType<any>} yarray\n * @param {number} index\n */ const findMarker = (yarray, index)=>{\n    if (yarray._start === null || index === 0 || yarray._searchMarker === null) {\n        return null;\n    }\n    const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b)=>lib0_math__WEBPACK_IMPORTED_MODULE_1__.abs(index - a.index) < lib0_math__WEBPACK_IMPORTED_MODULE_1__.abs(index - b.index) ? a : b);\n    let p = yarray._start;\n    let pindex = 0;\n    if (marker !== null) {\n        p = marker.p;\n        pindex = marker.index;\n        refreshMarkerTimestamp(marker); // we used it, we might need to use it again\n    }\n    // iterate to right if possible\n    while(p.right !== null && pindex < index){\n        if (!p.deleted && p.countable) {\n            if (index < pindex + p.length) {\n                break;\n            }\n            pindex += p.length;\n        }\n        p = p.right;\n    }\n    // iterate to left if necessary (might be that pindex > index)\n    while(p.left !== null && pindex > index){\n        p = p.left;\n        if (!p.deleted && p.countable) {\n            pindex -= p.length;\n        }\n    }\n    // we want to make sure that p can't be merged with left, because that would screw up everything\n    // in that cas just return what we have (it is most likely the best marker anyway)\n    // iterate to left until p can't be merged with left\n    while(p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock){\n        p = p.left;\n        if (!p.deleted && p.countable) {\n            pindex -= p.length;\n        }\n    }\n    // @todo remove!\n    // assure position\n    // {\n    //   let start = yarray._start\n    //   let pos = 0\n    //   while (start !== p) {\n    //     if (!start.deleted && start.countable) {\n    //       pos += start.length\n    //     }\n    //     start = /** @type {Item} */ (start.right)\n    //   }\n    //   if (pos !== pindex) {\n    //     debugger\n    //     throw new Error('Gotcha position fail!')\n    //   }\n    // }\n    // if (marker) {\n    //   if (window.lengths == null) {\n    //     window.lengths = []\n    //     window.getLengths = () => window.lengths.sort((a, b) => a - b)\n    //   }\n    //   window.lengths.push(marker.index - pindex)\n    //   console.log('distance', marker.index - pindex, 'len', p && p.parent.length)\n    // }\n    if (marker !== null && lib0_math__WEBPACK_IMPORTED_MODULE_1__.abs(marker.index - pindex) < /** @type {YText|YArray<any>} */ p.parent.length / maxSearchMarker) {\n        // adjust existing marker\n        overwriteMarker(marker, p, pindex);\n        return marker;\n    } else {\n        // create new marker\n        return markPosition(yarray._searchMarker, p, pindex);\n    }\n};\n/**\n * Update markers when a change happened.\n *\n * This should be called before doing a deletion!\n *\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {number} index\n * @param {number} len If insertion, len is positive. If deletion, len is negative.\n */ const updateMarkerChanges = (searchMarker, index, len)=>{\n    for(let i = searchMarker.length - 1; i >= 0; i--){\n        const m = searchMarker[i];\n        if (len > 0) {\n            /**\n       * @type {Item|null}\n       */ let p = m.p;\n            p.marker = false;\n            // Ideally we just want to do a simple position comparison, but this will only work if\n            // search markers don't point to deleted items for formats.\n            // Iterate marker to prev undeleted countable position so we know what to do when updating a position\n            while(p && (p.deleted || !p.countable)){\n                p = p.left;\n                if (p && !p.deleted && p.countable) {\n                    // adjust position. the loop should break now\n                    m.index -= p.length;\n                }\n            }\n            if (p === null || p.marker === true) {\n                // remove search marker if updated position is null or if position is already marked\n                searchMarker.splice(i, 1);\n                continue;\n            }\n            m.p = p;\n            p.marker = true;\n        }\n        if (index < m.index || len > 0 && index === m.index) {\n            m.index = lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(index, m.index + len);\n        }\n    }\n};\n/**\n * Accumulate all (list) children of a type and return them as an Array.\n *\n * @param {AbstractType<any>} t\n * @return {Array<Item>}\n */ const getTypeChildren = (t)=>{\n    t.doc ?? warnPrematureAccess();\n    let s = t._start;\n    const arr = [];\n    while(s){\n        arr.push(s);\n        s = s.right;\n    }\n    return arr;\n};\n/**\n * Call event listeners with an event. This will also add an event to all\n * parents (for `.observeDeep` handlers).\n *\n * @template EventType\n * @param {AbstractType<EventType>} type\n * @param {Transaction} transaction\n * @param {EventType} event\n */ const callTypeObservers = (type, transaction, event)=>{\n    const changedType = type;\n    const changedParentTypes = transaction.changedParentTypes;\n    while(true){\n        // @ts-ignore\n        lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(changedParentTypes, type, ()=>[]).push(event);\n        if (type._item === null) {\n            break;\n        }\n        type = /** @type {AbstractType<any>} */ type._item.parent;\n    }\n    callEventHandlerListeners(changedType._eH, event, transaction);\n};\n/**\n * @template EventType\n * Abstract Yjs Type class\n */ class AbstractType {\n    constructor(){\n        /**\n     * @type {Item|null}\n     */ this._item = null;\n        /**\n     * @type {Map<string,Item>}\n     */ this._map = new Map();\n        /**\n     * @type {Item|null}\n     */ this._start = null;\n        /**\n     * @type {Doc|null}\n     */ this.doc = null;\n        this._length = 0;\n        /**\n     * Event handlers\n     * @type {EventHandler<EventType,Transaction>}\n     */ this._eH = createEventHandler();\n        /**\n     * Deep event handlers\n     * @type {EventHandler<Array<YEvent<any>>,Transaction>}\n     */ this._dEH = createEventHandler();\n        /**\n     * @type {null | Array<ArraySearchMarker>}\n     */ this._searchMarker = null;\n    }\n    /**\n   * @return {AbstractType<any>|null}\n   */ get parent() {\n        return this._item ? /** @type {AbstractType<any>} */ this._item.parent : null;\n    }\n    /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item|null} item\n   */ _integrate(y, item) {\n        this.doc = y;\n        this._item = item;\n    }\n    /**\n   * @return {AbstractType<EventType>}\n   */ _copy() {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();\n    }\n    /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {AbstractType<EventType>}\n   */ clone() {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();\n    }\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder\n   */ _write(_encoder) {}\n    /**\n   * The first non-deleted item\n   */ get _first() {\n        let n = this._start;\n        while(n !== null && n.deleted){\n            n = n.right;\n        }\n        return n;\n    }\n    /**\n   * Creates YEvent and calls all type observers.\n   * Must be implemented by each type.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.\n   */ _callObserver(transaction, _parentSubs) {\n        if (!transaction.local && this._searchMarker) {\n            this._searchMarker.length = 0;\n        }\n    }\n    /**\n   * Observe all events that are created on this type.\n   *\n   * @param {function(EventType, Transaction):void} f Observer function\n   */ observe(f) {\n        addEventHandlerListener(this._eH, f);\n    }\n    /**\n   * Observe all events that are created by this type and its children.\n   *\n   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function\n   */ observeDeep(f) {\n        addEventHandlerListener(this._dEH, f);\n    }\n    /**\n   * Unregister an observer function.\n   *\n   * @param {function(EventType,Transaction):void} f Observer function\n   */ unobserve(f) {\n        removeEventHandlerListener(this._eH, f);\n    }\n    /**\n   * Unregister an observer function.\n   *\n   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function\n   */ unobserveDeep(f) {\n        removeEventHandlerListener(this._dEH, f);\n    }\n    /**\n   * @abstract\n   * @return {any}\n   */ toJSON() {}\n}\n/**\n * @param {AbstractType<any>} type\n * @param {number} start\n * @param {number} end\n * @return {Array<any>}\n *\n * @private\n * @function\n */ const typeListSlice = (type, start, end)=>{\n    type.doc ?? warnPrematureAccess();\n    if (start < 0) {\n        start = type._length + start;\n    }\n    if (end < 0) {\n        end = type._length + end;\n    }\n    let len = end - start;\n    const cs = [];\n    let n = type._start;\n    while(n !== null && len > 0){\n        if (n.countable && !n.deleted) {\n            const c = n.content.getContent();\n            if (c.length <= start) {\n                start -= c.length;\n            } else {\n                for(let i = start; i < c.length && len > 0; i++){\n                    cs.push(c[i]);\n                    len--;\n                }\n                start = 0;\n            }\n        }\n        n = n.right;\n    }\n    return cs;\n};\n/**\n * @param {AbstractType<any>} type\n * @return {Array<any>}\n *\n * @private\n * @function\n */ const typeListToArray = (type)=>{\n    type.doc ?? warnPrematureAccess();\n    const cs = [];\n    let n = type._start;\n    while(n !== null){\n        if (n.countable && !n.deleted) {\n            const c = n.content.getContent();\n            for(let i = 0; i < c.length; i++){\n                cs.push(c[i]);\n            }\n        }\n        n = n.right;\n    }\n    return cs;\n};\n/**\n * @param {AbstractType<any>} type\n * @param {Snapshot} snapshot\n * @return {Array<any>}\n *\n * @private\n * @function\n */ const typeListToArraySnapshot = (type, snapshot)=>{\n    const cs = [];\n    let n = type._start;\n    while(n !== null){\n        if (n.countable && isVisible(n, snapshot)) {\n            const c = n.content.getContent();\n            for(let i = 0; i < c.length; i++){\n                cs.push(c[i]);\n            }\n        }\n        n = n.right;\n    }\n    return cs;\n};\n/**\n * Executes a provided function on once on every element of this YArray.\n *\n * @param {AbstractType<any>} type\n * @param {function(any,number,any):void} f A function to execute on every element of this YArray.\n *\n * @private\n * @function\n */ const typeListForEach = (type, f)=>{\n    let index = 0;\n    let n = type._start;\n    type.doc ?? warnPrematureAccess();\n    while(n !== null){\n        if (n.countable && !n.deleted) {\n            const c = n.content.getContent();\n            for(let i = 0; i < c.length; i++){\n                f(c[i], index++, type);\n            }\n        }\n        n = n.right;\n    }\n};\n/**\n * @template C,R\n * @param {AbstractType<any>} type\n * @param {function(C,number,AbstractType<any>):R} f\n * @return {Array<R>}\n *\n * @private\n * @function\n */ const typeListMap = (type, f)=>{\n    /**\n   * @type {Array<any>}\n   */ const result = [];\n    typeListForEach(type, (c, i)=>{\n        result.push(f(c, i, type));\n    });\n    return result;\n};\n/**\n * @param {AbstractType<any>} type\n * @return {IterableIterator<any>}\n *\n * @private\n * @function\n */ const typeListCreateIterator = (type)=>{\n    let n = type._start;\n    /**\n   * @type {Array<any>|null}\n   */ let currentContent = null;\n    let currentContentIndex = 0;\n    return {\n        [Symbol.iterator] () {\n            return this;\n        },\n        next: ()=>{\n            // find some content\n            if (currentContent === null) {\n                while(n !== null && n.deleted){\n                    n = n.right;\n                }\n                // check if we reached the end, no need to check currentContent, because it does not exist\n                if (n === null) {\n                    return {\n                        done: true,\n                        value: undefined\n                    };\n                }\n                // we found n, so we can set currentContent\n                currentContent = n.content.getContent();\n                currentContentIndex = 0;\n                n = n.right; // we used the content of n, now iterate to next\n            }\n            const value = currentContent[currentContentIndex++];\n            // check if we need to empty currentContent\n            if (currentContent.length <= currentContentIndex) {\n                currentContent = null;\n            }\n            return {\n                done: false,\n                value\n            };\n        }\n    };\n};\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @return {any}\n *\n * @private\n * @function\n */ const typeListGet = (type, index)=>{\n    type.doc ?? warnPrematureAccess();\n    const marker = findMarker(type, index);\n    let n = type._start;\n    if (marker !== null) {\n        n = marker.p;\n        index -= marker.index;\n    }\n    for(; n !== null; n = n.right){\n        if (!n.deleted && n.countable) {\n            if (index < n.length) {\n                return n.content.getContent()[index];\n            }\n            index -= n.length;\n        }\n    }\n};\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {Item?} referenceItem\n * @param {Array<Object<string,any>|Array<any>|boolean|number|null|string|Uint8Array>} content\n *\n * @private\n * @function\n */ const typeListInsertGenericsAfter = (transaction, parent, referenceItem, content)=>{\n    let left = referenceItem;\n    const doc = transaction.doc;\n    const ownClientId = doc.clientID;\n    const store = doc.store;\n    const right = referenceItem === null ? parent._start : referenceItem.right;\n    /**\n   * @type {Array<Object|Array<any>|number|null>}\n   */ let jsonContent = [];\n    const packJsonContent = ()=>{\n        if (jsonContent.length > 0) {\n            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));\n            left.integrate(transaction, 0);\n            jsonContent = [];\n        }\n    };\n    content.forEach((c)=>{\n        if (c === null) {\n            jsonContent.push(c);\n        } else {\n            switch(c.constructor){\n                case Number:\n                case Object:\n                case Boolean:\n                case Array:\n                case String:\n                    jsonContent.push(c);\n                    break;\n                default:\n                    packJsonContent();\n                    switch(c.constructor){\n                        case Uint8Array:\n                        case ArrayBuffer:\n                            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(/** @type {Uint8Array} */ c)));\n                            left.integrate(transaction, 0);\n                            break;\n                        case Doc:\n                            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(/** @type {Doc} */ c));\n                            left.integrate(transaction, 0);\n                            break;\n                        default:\n                            if (c instanceof AbstractType) {\n                                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));\n                                left.integrate(transaction, 0);\n                            } else {\n                                throw new Error(\"Unexpected content type in insert operation\");\n                            }\n                    }\n            }\n        }\n    });\n    packJsonContent();\n};\nconst lengthExceeded = ()=>lib0_error__WEBPACK_IMPORTED_MODULE_9__.create(\"Length exceeded!\");\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content\n *\n * @private\n * @function\n */ const typeListInsertGenerics = (transaction, parent, index, content)=>{\n    if (index > parent._length) {\n        throw lengthExceeded();\n    }\n    if (index === 0) {\n        if (parent._searchMarker) {\n            updateMarkerChanges(parent._searchMarker, index, content.length);\n        }\n        return typeListInsertGenericsAfter(transaction, parent, null, content);\n    }\n    const startIndex = index;\n    const marker = findMarker(parent, index);\n    let n = parent._start;\n    if (marker !== null) {\n        n = marker.p;\n        index -= marker.index;\n        // we need to iterate one to the left so that the algorithm works\n        if (index === 0) {\n            // @todo refactor this as it actually doesn't consider formats\n            n = n.prev; // important! get the left undeleted item so that we can actually decrease index\n            index += n && n.countable && !n.deleted ? n.length : 0;\n        }\n    }\n    for(; n !== null; n = n.right){\n        if (!n.deleted && n.countable) {\n            if (index <= n.length) {\n                if (index < n.length) {\n                    // insert in-between\n                    getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n                }\n                break;\n            }\n            index -= n.length;\n        }\n    }\n    if (parent._searchMarker) {\n        updateMarkerChanges(parent._searchMarker, startIndex, content.length);\n    }\n    return typeListInsertGenericsAfter(transaction, parent, n, content);\n};\n/**\n * Pushing content is special as we generally want to push after the last item. So we don't have to update\n * the search marker.\n *\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content\n *\n * @private\n * @function\n */ const typeListPushGenerics = (transaction, parent, content)=>{\n    // Use the marker with the highest index and iterate to the right.\n    const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker)=>currMarker.index > maxMarker.index ? currMarker : maxMarker, {\n        index: 0,\n        p: parent._start\n    });\n    let n = marker.p;\n    if (n) {\n        while(n.right){\n            n = n.right;\n        }\n    }\n    return typeListInsertGenericsAfter(transaction, parent, n, content);\n};\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {number} length\n *\n * @private\n * @function\n */ const typeListDelete = (transaction, parent, index, length)=>{\n    if (length === 0) {\n        return;\n    }\n    const startIndex = index;\n    const startLength = length;\n    const marker = findMarker(parent, index);\n    let n = parent._start;\n    if (marker !== null) {\n        n = marker.p;\n        index -= marker.index;\n    }\n    // compute the first item to be deleted\n    for(; n !== null && index > 0; n = n.right){\n        if (!n.deleted && n.countable) {\n            if (index < n.length) {\n                getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n            }\n            index -= n.length;\n        }\n    }\n    // delete all items until done\n    while(length > 0 && n !== null){\n        if (!n.deleted) {\n            if (length < n.length) {\n                getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length));\n            }\n            n.delete(transaction);\n            length -= n.length;\n        }\n        n = n.right;\n    }\n    if (length > 0) {\n        throw lengthExceeded();\n    }\n    if (parent._searchMarker) {\n        updateMarkerChanges(parent._searchMarker, startIndex, -startLength + length /* in case we remove the above exception */ );\n    }\n};\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n *\n * @private\n * @function\n */ const typeMapDelete = (transaction, parent, key)=>{\n    const c = parent._map.get(key);\n    if (c !== undefined) {\n        c.delete(transaction);\n    }\n};\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Object|number|null|Array<any>|string|Uint8Array|AbstractType<any>} value\n *\n * @private\n * @function\n */ const typeMapSet = (transaction, parent, key, value)=>{\n    const left = parent._map.get(key) || null;\n    const doc = transaction.doc;\n    const ownClientId = doc.clientID;\n    let content;\n    if (value == null) {\n        content = new ContentAny([\n            value\n        ]);\n    } else {\n        switch(value.constructor){\n            case Number:\n            case Object:\n            case Boolean:\n            case Array:\n            case String:\n                content = new ContentAny([\n                    value\n                ]);\n                break;\n            case Uint8Array:\n                content = new ContentBinary(/** @type {Uint8Array} */ value);\n                break;\n            case Doc:\n                content = new ContentDoc(/** @type {Doc} */ value);\n                break;\n            default:\n                if (value instanceof AbstractType) {\n                    content = new ContentType(value);\n                } else {\n                    throw new Error(\"Unexpected content type\");\n                }\n        }\n    }\n    new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);\n};\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */ const typeMapGet = (parent, key)=>{\n    parent.doc ?? warnPrematureAccess();\n    const val = parent._map.get(key);\n    return val !== undefined && !val.deleted ? val.content.getContent()[val.length - 1] : undefined;\n};\n/**\n * @param {AbstractType<any>} parent\n * @return {Object<string,Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}\n *\n * @private\n * @function\n */ const typeMapGetAll = (parent)=>{\n    /**\n   * @type {Object<string,any>}\n   */ const res = {};\n    parent.doc ?? warnPrematureAccess();\n    parent._map.forEach((value, key)=>{\n        if (!value.deleted) {\n            res[key] = value.content.getContent()[value.length - 1];\n        }\n    });\n    return res;\n};\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {boolean}\n *\n * @private\n * @function\n */ const typeMapHas = (parent, key)=>{\n    parent.doc ?? warnPrematureAccess();\n    const val = parent._map.get(key);\n    return val !== undefined && !val.deleted;\n};\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Snapshot} snapshot\n * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */ const typeMapGetSnapshot = (parent, key, snapshot)=>{\n    let v = parent._map.get(key) || null;\n    while(v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))){\n        v = v.left;\n    }\n    return v !== null && isVisible(v, snapshot) ? v.content.getContent()[v.length - 1] : undefined;\n};\n/**\n * @param {AbstractType<any>} parent\n * @param {Snapshot} snapshot\n * @return {Object<string,Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}\n *\n * @private\n * @function\n */ const typeMapGetAllSnapshot = (parent, snapshot)=>{\n    /**\n   * @type {Object<string,any>}\n   */ const res = {};\n    parent._map.forEach((value, key)=>{\n        /**\n     * @type {Item|null}\n     */ let v = value;\n        while(v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))){\n            v = v.left;\n        }\n        if (v !== null && isVisible(v, snapshot)) {\n            res[key] = v.content.getContent()[v.length - 1];\n        }\n    });\n    return res;\n};\n/**\n * @param {AbstractType<any> & { _map: Map<string, Item> }} type\n * @return {IterableIterator<Array<any>>}\n *\n * @private\n * @function\n */ const createMapIterator = (type)=>{\n    type.doc ?? warnPrematureAccess();\n    return lib0_iterator__WEBPACK_IMPORTED_MODULE_17__.iteratorFilter(type._map.entries(), /** @param {any} entry */ (entry)=>!entry[1].deleted);\n};\n/**\n * @module YArray\n */ /**\n * Event that describes the changes on a YArray\n * @template T\n * @extends YEvent<YArray<T>>\n */ class YArrayEvent extends YEvent {\n}\n/**\n * A shared Array implementation.\n * @template T\n * @extends AbstractType<YArrayEvent<T>>\n * @implements {Iterable<T>}\n */ class YArray extends AbstractType {\n    constructor(){\n        super();\n        /**\n     * @type {Array<any>?}\n     * @private\n     */ this._prelimContent = [];\n        /**\n     * @type {Array<ArraySearchMarker>}\n     */ this._searchMarker = [];\n    }\n    /**\n   * Construct a new YArray containing the specified items.\n   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T\n   * @param {Array<T>} items\n   * @return {YArray<T>}\n   */ static from(items) {\n        /**\n     * @type {YArray<T>}\n     */ const a = new YArray();\n        a.push(items);\n        return a;\n    }\n    /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */ _integrate(y, item) {\n        super._integrate(y, item);\n        this.insert(0, /** @type {Array<any>} */ this._prelimContent);\n        this._prelimContent = null;\n    }\n    /**\n   * @return {YArray<T>}\n   */ _copy() {\n        return new YArray();\n    }\n    /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {YArray<T>}\n   */ clone() {\n        /**\n     * @type {YArray<T>}\n     */ const arr = new YArray();\n        arr.insert(0, this.toArray().map((el)=>el instanceof AbstractType ? /** @type {typeof el} */ el.clone() : el));\n        return arr;\n    }\n    get length() {\n        this.doc ?? warnPrematureAccess();\n        return this._length;\n    }\n    /**\n   * Creates YArrayEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */ _callObserver(transaction, parentSubs) {\n        super._callObserver(transaction, parentSubs);\n        callTypeObservers(this, transaction, new YArrayEvent(this, transaction));\n    }\n    /**\n   * Inserts new content at an index.\n   *\n   * Important: This function expects an array of content. Not just a content\n   * object. The reason for this \"weirdness\" is that inserting several elements\n   * is very efficient when it is done as a single operation.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  yarray.insert(0, ['a'])\n   *  // Insert numbers 1, 2 at position 1\n   *  yarray.insert(1, [1, 2])\n   *\n   * @param {number} index The index to insert content at.\n   * @param {Array<T>} content The array of content\n   */ insert(index, content) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeListInsertGenerics(transaction, this, index, /** @type {any} */ content);\n            });\n        } else {\n            /** @type {Array<any>} */ this._prelimContent.splice(index, 0, ...content);\n        }\n    }\n    /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to append.\n   *\n   * @todo Use the following implementation in all types.\n   */ push(content) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeListPushGenerics(transaction, this, /** @type {any} */ content);\n            });\n        } else {\n            /** @type {Array<any>} */ this._prelimContent.push(...content);\n        }\n    }\n    /**\n   * Prepends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to prepend.\n   */ unshift(content) {\n        this.insert(0, content);\n    }\n    /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} length The number of elements to remove. Defaults to 1.\n   */ delete(index, length = 1) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeListDelete(transaction, this, index, length);\n            });\n        } else {\n            /** @type {Array<any>} */ this._prelimContent.splice(index, length);\n        }\n    }\n    /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {T}\n   */ get(index) {\n        return typeListGet(this, index);\n    }\n    /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<T>}\n   */ toArray() {\n        return typeListToArray(this);\n    }\n    /**\n   * Returns a portion of this YArray into a JavaScript Array selected\n   * from start to end (end not included).\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<T>}\n   */ slice(start = 0, end = this.length) {\n        return typeListSlice(this, start, end);\n    }\n    /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Array<any>}\n   */ toJSON() {\n        return this.map((c)=>c instanceof AbstractType ? c.toJSON() : c);\n    }\n    /**\n   * Returns an Array with the result of calling a provided function on every\n   * element of this YArray.\n   *\n   * @template M\n   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array\n   * @return {Array<M>} A new array with each element being the result of the\n   *                 callback function\n   */ map(f) {\n        return typeListMap(this, /** @type {any} */ f);\n    }\n    /**\n   * Executes a provided function once on every element of this YArray.\n   *\n   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.\n   */ forEach(f) {\n        typeListForEach(this, f);\n    }\n    /**\n   * @return {IterableIterator<T>}\n   */ [Symbol.iterator]() {\n        return typeListCreateIterator(this);\n    }\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */ _write(encoder) {\n        encoder.writeTypeRef(YArrayRefID);\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder\n *\n * @private\n * @function\n */ const readYArray = (_decoder)=>new YArray();\n/**\n * @module YMap\n */ /**\n * @template T\n * @extends YEvent<YMap<T>>\n * Event that describes the changes on a YMap.\n */ class YMapEvent extends YEvent {\n    /**\n   * @param {YMap<T>} ymap The YArray that changed.\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed.\n   */ constructor(ymap, transaction, subs){\n        super(ymap, transaction);\n        this.keysChanged = subs;\n    }\n}\n/**\n * @template MapType\n * A shared Map implementation.\n *\n * @extends AbstractType<YMapEvent<MapType>>\n * @implements {Iterable<[string, MapType]>}\n */ class YMap extends AbstractType {\n    /**\n   *\n   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap\n   */ constructor(entries){\n        super();\n        /**\n     * @type {Map<string,any>?}\n     * @private\n     */ this._prelimContent = null;\n        if (entries === undefined) {\n            this._prelimContent = new Map();\n        } else {\n            this._prelimContent = new Map(entries);\n        }\n    }\n    /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */ _integrate(y, item) {\n        super._integrate(y, item); /** @type {Map<string, any>} */ \n        this._prelimContent.forEach((value, key)=>{\n            this.set(key, value);\n        });\n        this._prelimContent = null;\n    }\n    /**\n   * @return {YMap<MapType>}\n   */ _copy() {\n        return new YMap();\n    }\n    /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {YMap<MapType>}\n   */ clone() {\n        /**\n     * @type {YMap<MapType>}\n     */ const map = new YMap();\n        this.forEach((value, key)=>{\n            map.set(key, value instanceof AbstractType ? /** @type {typeof value} */ value.clone() : value);\n        });\n        return map;\n    }\n    /**\n   * Creates YMapEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */ _callObserver(transaction, parentSubs) {\n        callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));\n    }\n    /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Object<string,any>}\n   */ toJSON() {\n        this.doc ?? warnPrematureAccess();\n        /**\n     * @type {Object<string,MapType>}\n     */ const map = {};\n        this._map.forEach((item, key)=>{\n            if (!item.deleted) {\n                const v = item.content.getContent()[item.length - 1];\n                map[key] = v instanceof AbstractType ? v.toJSON() : v;\n            }\n        });\n        return map;\n    }\n    /**\n   * Returns the size of the YMap (count of key/value pairs)\n   *\n   * @return {number}\n   */ get size() {\n        return [\n            ...createMapIterator(this)\n        ].length;\n    }\n    /**\n   * Returns the keys for each element in the YMap Type.\n   *\n   * @return {IterableIterator<string>}\n   */ keys() {\n        return lib0_iterator__WEBPACK_IMPORTED_MODULE_17__.iteratorMap(createMapIterator(this), /** @param {any} v */ (v)=>v[0]);\n    }\n    /**\n   * Returns the values for each element in the YMap Type.\n   *\n   * @return {IterableIterator<MapType>}\n   */ values() {\n        return lib0_iterator__WEBPACK_IMPORTED_MODULE_17__.iteratorMap(createMapIterator(this), /** @param {any} v */ (v)=>v[1].content.getContent()[v[1].length - 1]);\n    }\n    /**\n   * Returns an Iterator of [key, value] pairs\n   *\n   * @return {IterableIterator<[string, MapType]>}\n   */ entries() {\n        return lib0_iterator__WEBPACK_IMPORTED_MODULE_17__.iteratorMap(createMapIterator(this), /** @param {any} v */ (v)=>/** @type {any} */ [\n                v[0],\n                v[1].content.getContent()[v[1].length - 1]\n            ]);\n    }\n    /**\n   * Executes a provided function on once on every key-value pair.\n   *\n   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.\n   */ forEach(f) {\n        this.doc ?? warnPrematureAccess();\n        this._map.forEach((item, key)=>{\n            if (!item.deleted) {\n                f(item.content.getContent()[item.length - 1], key, this);\n            }\n        });\n    }\n    /**\n   * Returns an Iterator of [key, value] pairs\n   *\n   * @return {IterableIterator<[string, MapType]>}\n   */ [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n   * Remove a specified element from this YMap.\n   *\n   * @param {string} key The key of the element to remove.\n   */ delete(key) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeMapDelete(transaction, this, key);\n            });\n        } else {\n            /** @type {Map<string, any>} */ this._prelimContent.delete(key);\n        }\n    }\n    /**\n   * Adds or updates an element with a specified key and value.\n   * @template {MapType} VAL\n   *\n   * @param {string} key The key of the element to add to this YMap\n   * @param {VAL} value The value of the element to add\n   * @return {VAL}\n   */ set(key, value) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeMapSet(transaction, this, key, /** @type {any} */ value);\n            });\n        } else {\n            /** @type {Map<string, any>} */ this._prelimContent.set(key, value);\n        }\n        return value;\n    }\n    /**\n   * Returns a specified element from this YMap.\n   *\n   * @param {string} key\n   * @return {MapType|undefined}\n   */ get(key) {\n        return /** @type {any} */ typeMapGet(this, key);\n    }\n    /**\n   * Returns a boolean indicating whether the specified key exists or not.\n   *\n   * @param {string} key The key to test.\n   * @return {boolean}\n   */ has(key) {\n        return typeMapHas(this, key);\n    }\n    /**\n   * Removes all elements from this YMap.\n   */ clear() {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                this.forEach(function(_value, key, map) {\n                    typeMapDelete(transaction, map, key);\n                });\n            });\n        } else {\n            /** @type {Map<string, any>} */ this._prelimContent.clear();\n        }\n    }\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */ _write(encoder) {\n        encoder.writeTypeRef(YMapRefID);\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder\n *\n * @private\n * @function\n */ const readYMap = (_decoder)=>new YMap();\n/**\n * @module YText\n */ /**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */ const equalAttrs = (a, b)=>a === b || typeof a === \"object\" && typeof b === \"object\" && a && b && lib0_object__WEBPACK_IMPORTED_MODULE_18__.equalFlat(a, b);\nclass ItemTextListPosition {\n    /**\n   * @param {Item|null} left\n   * @param {Item|null} right\n   * @param {number} index\n   * @param {Map<string,any>} currentAttributes\n   */ constructor(left, right, index, currentAttributes){\n        this.left = left;\n        this.right = right;\n        this.index = index;\n        this.currentAttributes = currentAttributes;\n    }\n    /**\n   * Only call this if you know that this.right is defined\n   */ forward() {\n        if (this.right === null) {\n            lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n        }\n        switch(this.right.content.constructor){\n            case ContentFormat:\n                if (!this.right.deleted) {\n                    updateCurrentAttributes(this.currentAttributes, /** @type {ContentFormat} */ this.right.content);\n                }\n                break;\n            default:\n                if (!this.right.deleted) {\n                    this.index += this.right.length;\n                }\n                break;\n        }\n        this.left = this.right;\n        this.right = this.right.right;\n    }\n}\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} pos\n * @param {number} count steps to move forward\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */ const findNextPosition = (transaction, pos, count)=>{\n    while(pos.right !== null && count > 0){\n        switch(pos.right.content.constructor){\n            case ContentFormat:\n                if (!pos.right.deleted) {\n                    updateCurrentAttributes(pos.currentAttributes, /** @type {ContentFormat} */ pos.right.content);\n                }\n                break;\n            default:\n                if (!pos.right.deleted) {\n                    if (count < pos.right.length) {\n                        // split right\n                        getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));\n                    }\n                    pos.index += pos.right.length;\n                    count -= pos.right.length;\n                }\n                break;\n        }\n        pos.left = pos.right;\n        pos.right = pos.right.right;\n    // pos.forward() - we don't forward because that would halve the performance because we already do the checks above\n    }\n    return pos;\n};\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {boolean} useSearchMarker\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */ const findPosition = (transaction, parent, index, useSearchMarker)=>{\n    const currentAttributes = new Map();\n    const marker = useSearchMarker ? findMarker(parent, index) : null;\n    if (marker) {\n        const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);\n        return findNextPosition(transaction, pos, index - marker.index);\n    } else {\n        const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);\n        return findNextPosition(transaction, pos, index);\n    }\n};\n/**\n * Negate applied formats\n *\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Map<string,any>} negatedAttributes\n *\n * @private\n * @function\n */ const insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes)=>{\n    // check if we really need to remove attributes\n    while(currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(negatedAttributes.get(/** @type {ContentFormat} */ currPos.right.content.key), /** @type {ContentFormat} */ currPos.right.content.value))){\n        if (!currPos.right.deleted) {\n            negatedAttributes.delete(/** @type {ContentFormat} */ currPos.right.content.key);\n        }\n        currPos.forward();\n    }\n    const doc = transaction.doc;\n    const ownClientId = doc.clientID;\n    negatedAttributes.forEach((val, key)=>{\n        const left = currPos.left;\n        const right = currPos.right;\n        const nextFormat = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n        nextFormat.integrate(transaction, 0);\n        currPos.right = nextFormat;\n        currPos.forward();\n    });\n};\n/**\n * @param {Map<string,any>} currentAttributes\n * @param {ContentFormat} format\n *\n * @private\n * @function\n */ const updateCurrentAttributes = (currentAttributes, format)=>{\n    const { key, value } = format;\n    if (value === null) {\n        currentAttributes.delete(key);\n    } else {\n        currentAttributes.set(key, value);\n    }\n};\n/**\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */ const minimizeAttributeChanges = (currPos, attributes)=>{\n    // go right while attributes[right.key] === right.value (or right is deleted)\n    while(true){\n        if (currPos.right === null) {\n            break;\n        } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(attributes[/** @type {ContentFormat} */ currPos.right.content.key] ?? null, /** @type {ContentFormat} */ currPos.right.content.value)) ;\n        else {\n            break;\n        }\n        currPos.forward();\n    }\n};\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n * @return {Map<string,any>}\n *\n * @private\n * @function\n **/ const insertAttributes = (transaction, parent, currPos, attributes)=>{\n    const doc = transaction.doc;\n    const ownClientId = doc.clientID;\n    const negatedAttributes = new Map();\n    // insert format-start items\n    for(const key in attributes){\n        const val = attributes[key];\n        const currentVal = currPos.currentAttributes.get(key) ?? null;\n        if (!equalAttrs(currentVal, val)) {\n            // save negated attribute (set null if currentVal undefined)\n            negatedAttributes.set(key, currentVal);\n            const { left, right } = currPos;\n            currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n            currPos.right.integrate(transaction, 0);\n            currPos.forward();\n        }\n    }\n    return negatedAttributes;\n};\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {string|object|AbstractType<any>} text\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n **/ const insertText = (transaction, parent, currPos, text, attributes)=>{\n    currPos.currentAttributes.forEach((_val, key)=>{\n        if (attributes[key] === undefined) {\n            attributes[key] = null;\n        }\n    });\n    const doc = transaction.doc;\n    const ownClientId = doc.clientID;\n    minimizeAttributeChanges(currPos, attributes);\n    const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n    // insert content\n    const content = text.constructor === String ? new ContentString(/** @type {string} */ text) : text instanceof AbstractType ? new ContentType(text) : new ContentEmbed(text);\n    let { left, right, index } = currPos;\n    if (parent._searchMarker) {\n        updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());\n    }\n    right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);\n    right.integrate(transaction, 0);\n    currPos.right = right;\n    currPos.index = index;\n    currPos.forward();\n    insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */ const formatText = (transaction, parent, currPos, length, attributes)=>{\n    const doc = transaction.doc;\n    const ownClientId = doc.clientID;\n    minimizeAttributeChanges(currPos, attributes);\n    const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n    // iterate until first non-format or null is found\n    // delete all formats with attributes[format.key] != null\n    // also check the attributes after the first non-format as we do not want to insert redundant negated attributes there\n    // eslint-disable-next-line no-labels\n    iterationLoop: while(currPos.right !== null && (length > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))){\n        if (!currPos.right.deleted) {\n            switch(currPos.right.content.constructor){\n                case ContentFormat:\n                    {\n                        const { key, value } = /** @type {ContentFormat} */ currPos.right.content;\n                        const attr = attributes[key];\n                        if (attr !== undefined) {\n                            if (equalAttrs(attr, value)) {\n                                negatedAttributes.delete(key);\n                            } else {\n                                if (length === 0) {\n                                    break iterationLoop;\n                                }\n                                negatedAttributes.set(key, value);\n                            }\n                            currPos.right.delete(transaction);\n                        } else {\n                            currPos.currentAttributes.set(key, value);\n                        }\n                        break;\n                    }\n                default:\n                    if (length < currPos.right.length) {\n                        getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));\n                    }\n                    length -= currPos.right.length;\n                    break;\n            }\n        }\n        currPos.forward();\n    }\n    // Quill just assumes that the editor starts with a newline and that it always\n    // ends with a newline. We only insert that newline when a new newline is\n    // inserted - i.e when length is bigger than type.length\n    if (length > 0) {\n        let newlines = \"\";\n        for(; length > 0; length--){\n            newlines += \"\\n\";\n        }\n        currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));\n        currPos.right.integrate(transaction, 0);\n        currPos.forward();\n    }\n    insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\n/**\n * Call this function after string content has been deleted in order to\n * clean up formatting Items.\n *\n * @param {Transaction} transaction\n * @param {Item} start\n * @param {Item|null} curr exclusive end, automatically iterates to the next Content Item\n * @param {Map<string,any>} startAttributes\n * @param {Map<string,any>} currAttributes\n * @return {number} The amount of formatting Items deleted.\n *\n * @function\n */ const cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes)=>{\n    /**\n   * @type {Item|null}\n   */ let end = start;\n    /**\n   * @type {Map<string,ContentFormat>}\n   */ const endFormats = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n    while(end && (!end.countable || end.deleted)){\n        if (!end.deleted && end.content.constructor === ContentFormat) {\n            const cf = /** @type {ContentFormat} */ end.content;\n            endFormats.set(cf.key, cf);\n        }\n        end = end.right;\n    }\n    let cleanups = 0;\n    let reachedCurr = false;\n    while(start !== end){\n        if (curr === start) {\n            reachedCurr = true;\n        }\n        if (!start.deleted) {\n            const content = start.content;\n            switch(content.constructor){\n                case ContentFormat:\n                    {\n                        const { key, value } = /** @type {ContentFormat} */ content;\n                        const startAttrValue = startAttributes.get(key) ?? null;\n                        if (endFormats.get(key) !== content || startAttrValue === value) {\n                            // Either this format is overwritten or it is not necessary because the attribute already existed.\n                            start.delete(transaction);\n                            cleanups++;\n                            if (!reachedCurr && (currAttributes.get(key) ?? null) === value && startAttrValue !== value) {\n                                if (startAttrValue === null) {\n                                    currAttributes.delete(key);\n                                } else {\n                                    currAttributes.set(key, startAttrValue);\n                                }\n                            }\n                        }\n                        if (!reachedCurr && !start.deleted) {\n                            updateCurrentAttributes(currAttributes, /** @type {ContentFormat} */ content);\n                        }\n                        break;\n                    }\n            }\n        }\n        start = /** @type {Item} */ start.right;\n    }\n    return cleanups;\n};\n/**\n * @param {Transaction} transaction\n * @param {Item | null} item\n */ const cleanupContextlessFormattingGap = (transaction, item)=>{\n    // iterate until item.right is null or content\n    while(item && item.right && (item.right.deleted || !item.right.countable)){\n        item = item.right;\n    }\n    const attrs = new Set();\n    // iterate back until a content item is found\n    while(item && (item.deleted || !item.countable)){\n        if (!item.deleted && item.content.constructor === ContentFormat) {\n            const key = /** @type {ContentFormat} */ item.content.key;\n            if (attrs.has(key)) {\n                item.delete(transaction);\n            } else {\n                attrs.add(key);\n            }\n        }\n        item = item.left;\n    }\n};\n/**\n * This function is experimental and subject to change / be removed.\n *\n * Ideally, we don't need this function at all. Formatting attributes should be cleaned up\n * automatically after each change. This function iterates twice over the complete YText type\n * and removes unnecessary formatting attributes. This is also helpful for testing.\n *\n * This function won't be exported anymore as soon as there is confidence that the YText type works as intended.\n *\n * @param {YText} type\n * @return {number} How many formatting attributes have been cleaned up.\n */ const cleanupYTextFormatting = (type)=>{\n    let res = 0;\n    transact(/** @type {Doc} */ type.doc, (transaction)=>{\n        let start = /** @type {Item} */ type._start;\n        let end = type._start;\n        let startAttributes = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n        const currentAttributes = lib0_map__WEBPACK_IMPORTED_MODULE_3__.copy(startAttributes);\n        while(end){\n            if (end.deleted === false) {\n                switch(end.content.constructor){\n                    case ContentFormat:\n                        updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ end.content);\n                        break;\n                    default:\n                        res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);\n                        startAttributes = lib0_map__WEBPACK_IMPORTED_MODULE_3__.copy(currentAttributes);\n                        start = end;\n                        break;\n                }\n            }\n            end = end.right;\n        }\n    });\n    return res;\n};\n/**\n * This will be called by the transaction once the event handlers are called to potentially cleanup\n * formatting attributes.\n *\n * @param {Transaction} transaction\n */ const cleanupYTextAfterTransaction = (transaction)=>{\n    /**\n   * @type {Set<YText>}\n   */ const needFullCleanup = new Set();\n    // check if another formatting item was inserted\n    const doc = transaction.doc;\n    for (const [client, afterClock] of transaction.afterState.entries()){\n        const clock = transaction.beforeState.get(client) || 0;\n        if (afterClock === clock) {\n            continue;\n        }\n        iterateStructs(transaction, /** @type {Array<Item|GC>} */ doc.store.clients.get(client), clock, afterClock, (item)=>{\n            if (!item.deleted && /** @type {Item} */ item.content.constructor === ContentFormat && item.constructor !== GC) {\n                needFullCleanup.add(/** @type {any} */ item.parent);\n            }\n        });\n    }\n    // cleanup in a new transaction\n    transact(doc, (t)=>{\n        iterateDeletedStructs(transaction, transaction.deleteSet, (item)=>{\n            if (item instanceof GC || !/** @type {YText} */ item.parent._hasFormatting || needFullCleanup.has(/** @type {YText} */ item.parent)) {\n                return;\n            }\n            const parent = /** @type {YText} */ item.parent;\n            if (item.content.constructor === ContentFormat) {\n                needFullCleanup.add(parent);\n            } else {\n                // If no formatting attribute was inserted or deleted, we can make due with contextless\n                // formatting cleanups.\n                // Contextless: it is not necessary to compute currentAttributes for the affected position.\n                cleanupContextlessFormattingGap(t, item);\n            }\n        });\n        // If a formatting item was inserted, we simply clean the whole type.\n        // We need to compute currentAttributes for the current position anyway.\n        for (const yText of needFullCleanup){\n            cleanupYTextFormatting(yText);\n        }\n    });\n};\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */ const deleteText = (transaction, currPos, length)=>{\n    const startLength = length;\n    const startAttrs = lib0_map__WEBPACK_IMPORTED_MODULE_3__.copy(currPos.currentAttributes);\n    const start = currPos.right;\n    while(length > 0 && currPos.right !== null){\n        if (currPos.right.deleted === false) {\n            switch(currPos.right.content.constructor){\n                case ContentType:\n                case ContentEmbed:\n                case ContentString:\n                    if (length < currPos.right.length) {\n                        getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));\n                    }\n                    length -= currPos.right.length;\n                    currPos.right.delete(transaction);\n                    break;\n            }\n        }\n        currPos.forward();\n    }\n    if (start) {\n        cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);\n    }\n    const parent = /** @type {AbstractType<any>} */ /** @type {Item} */ (currPos.left || currPos.right).parent;\n    if (parent._searchMarker) {\n        updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length);\n    }\n    return currPos;\n};\n/**\n * The Quill Delta format represents changes on a text document with\n * formatting information. For more information visit {@link https://quilljs.com/docs/delta/|Quill Delta}\n *\n * @example\n *   {\n *     ops: [\n *       { insert: 'Gandalf', attributes: { bold: true } },\n *       { insert: ' the ' },\n *       { insert: 'Grey', attributes: { color: '#cccccc' } }\n *     ]\n *   }\n *\n */ /**\n  * Attributes that can be assigned to a selection of text.\n  *\n  * @example\n  *   {\n  *     bold: true,\n  *     font-size: '40px'\n  *   }\n  *\n  * @typedef {Object} TextAttributes\n  */ /**\n * @extends YEvent<YText>\n * Event that describes the changes on a YText type.\n */ class YTextEvent extends YEvent {\n    /**\n   * @param {YText} ytext\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed\n   */ constructor(ytext, transaction, subs){\n        super(ytext, transaction);\n        /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */ this.childListChanged = false;\n        /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */ this.keysChanged = new Set();\n        subs.forEach((sub)=>{\n            if (sub === null) {\n                this.childListChanged = true;\n            } else {\n                this.keysChanged.add(sub);\n            }\n        });\n    }\n    /**\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */ get changes() {\n        if (this._changes === null) {\n            /**\n       * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string|AbstractType<any>|object, delete?:number, retain?:number}>}}\n       */ const changes = {\n                keys: this.keys,\n                delta: this.delta,\n                added: new Set(),\n                deleted: new Set()\n            };\n            this._changes = changes;\n        }\n        return /** @type {any} */ this._changes;\n    }\n    /**\n   * Compute the changes in the delta format.\n   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.\n   *\n   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n   *\n   * @public\n   */ get delta() {\n        if (this._delta === null) {\n            const y = /** @type {Doc} */ this.target.doc;\n            /**\n       * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n       */ const delta = [];\n            transact(y, (transaction)=>{\n                const currentAttributes = new Map(); // saves all current attributes for insert\n                const oldAttributes = new Map();\n                let item = this.target._start;\n                /**\n         * @type {string?}\n         */ let action = null;\n                /**\n         * @type {Object<string,any>}\n         */ const attributes = {}; // counts added or removed new attributes for retain\n                /**\n         * @type {string|object}\n         */ let insert = \"\";\n                let retain = 0;\n                let deleteLen = 0;\n                const addOp = ()=>{\n                    if (action !== null) {\n                        /**\n             * @type {any}\n             */ let op = null;\n                        switch(action){\n                            case \"delete\":\n                                if (deleteLen > 0) {\n                                    op = {\n                                        delete: deleteLen\n                                    };\n                                }\n                                deleteLen = 0;\n                                break;\n                            case \"insert\":\n                                if (typeof insert === \"object\" || insert.length > 0) {\n                                    op = {\n                                        insert\n                                    };\n                                    if (currentAttributes.size > 0) {\n                                        op.attributes = {};\n                                        currentAttributes.forEach((value, key)=>{\n                                            if (value !== null) {\n                                                op.attributes[key] = value;\n                                            }\n                                        });\n                                    }\n                                }\n                                insert = \"\";\n                                break;\n                            case \"retain\":\n                                if (retain > 0) {\n                                    op = {\n                                        retain\n                                    };\n                                    if (!lib0_object__WEBPACK_IMPORTED_MODULE_18__.isEmpty(attributes)) {\n                                        op.attributes = lib0_object__WEBPACK_IMPORTED_MODULE_18__.assign({}, attributes);\n                                    }\n                                }\n                                retain = 0;\n                                break;\n                        }\n                        if (op) delta.push(op);\n                        action = null;\n                    }\n                };\n                while(item !== null){\n                    switch(item.content.constructor){\n                        case ContentType:\n                        case ContentEmbed:\n                            if (this.adds(item)) {\n                                if (!this.deletes(item)) {\n                                    addOp();\n                                    action = \"insert\";\n                                    insert = item.content.getContent()[0];\n                                    addOp();\n                                }\n                            } else if (this.deletes(item)) {\n                                if (action !== \"delete\") {\n                                    addOp();\n                                    action = \"delete\";\n                                }\n                                deleteLen += 1;\n                            } else if (!item.deleted) {\n                                if (action !== \"retain\") {\n                                    addOp();\n                                    action = \"retain\";\n                                }\n                                retain += 1;\n                            }\n                            break;\n                        case ContentString:\n                            if (this.adds(item)) {\n                                if (!this.deletes(item)) {\n                                    if (action !== \"insert\") {\n                                        addOp();\n                                        action = \"insert\";\n                                    }\n                                    insert += /** @type {ContentString} */ item.content.str;\n                                }\n                            } else if (this.deletes(item)) {\n                                if (action !== \"delete\") {\n                                    addOp();\n                                    action = \"delete\";\n                                }\n                                deleteLen += item.length;\n                            } else if (!item.deleted) {\n                                if (action !== \"retain\") {\n                                    addOp();\n                                    action = \"retain\";\n                                }\n                                retain += item.length;\n                            }\n                            break;\n                        case ContentFormat:\n                            {\n                                const { key, value } = /** @type {ContentFormat} */ item.content;\n                                if (this.adds(item)) {\n                                    if (!this.deletes(item)) {\n                                        const curVal = currentAttributes.get(key) ?? null;\n                                        if (!equalAttrs(curVal, value)) {\n                                            if (action === \"retain\") {\n                                                addOp();\n                                            }\n                                            if (equalAttrs(value, oldAttributes.get(key) ?? null)) {\n                                                delete attributes[key];\n                                            } else {\n                                                attributes[key] = value;\n                                            }\n                                        } else if (value !== null) {\n                                            item.delete(transaction);\n                                        }\n                                    }\n                                } else if (this.deletes(item)) {\n                                    oldAttributes.set(key, value);\n                                    const curVal = currentAttributes.get(key) ?? null;\n                                    if (!equalAttrs(curVal, value)) {\n                                        if (action === \"retain\") {\n                                            addOp();\n                                        }\n                                        attributes[key] = curVal;\n                                    }\n                                } else if (!item.deleted) {\n                                    oldAttributes.set(key, value);\n                                    const attr = attributes[key];\n                                    if (attr !== undefined) {\n                                        if (!equalAttrs(attr, value)) {\n                                            if (action === \"retain\") {\n                                                addOp();\n                                            }\n                                            if (value === null) {\n                                                delete attributes[key];\n                                            } else {\n                                                attributes[key] = value;\n                                            }\n                                        } else if (attr !== null) {\n                                            item.delete(transaction);\n                                        }\n                                    }\n                                }\n                                if (!item.deleted) {\n                                    if (action === \"insert\") {\n                                        addOp();\n                                    }\n                                    updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ item.content);\n                                }\n                                break;\n                            }\n                    }\n                    item = item.right;\n                }\n                addOp();\n                while(delta.length > 0){\n                    const lastOp = delta[delta.length - 1];\n                    if (lastOp.retain !== undefined && lastOp.attributes === undefined) {\n                        // retain delta's if they don't assign attributes\n                        delta.pop();\n                    } else {\n                        break;\n                    }\n                }\n            });\n            this._delta = delta;\n        }\n        return /** @type {any} */ this._delta;\n    }\n}\n/**\n * Type that represents text with formatting information.\n *\n * This type replaces y-richtext as this implementation is able to handle\n * block formats (format information on a paragraph), embeds (complex elements\n * like pictures and videos), and text formats (**bold**, *italic*).\n *\n * @extends AbstractType<YTextEvent>\n */ class YText extends AbstractType {\n    /**\n   * @param {String} [string] The initial value of the YText.\n   */ constructor(string){\n        super();\n        /**\n     * Array of pending operations on this type\n     * @type {Array<function():void>?}\n     */ this._pending = string !== undefined ? [\n            ()=>this.insert(0, string)\n        ] : [];\n        /**\n     * @type {Array<ArraySearchMarker>|null}\n     */ this._searchMarker = [];\n        /**\n     * Whether this YText contains formatting attributes.\n     * This flag is updated when a formatting item is integrated (see ContentFormat.integrate)\n     */ this._hasFormatting = false;\n    }\n    /**\n   * Number of characters of this text type.\n   *\n   * @type {number}\n   */ get length() {\n        this.doc ?? warnPrematureAccess();\n        return this._length;\n    }\n    /**\n   * @param {Doc} y\n   * @param {Item} item\n   */ _integrate(y, item) {\n        super._integrate(y, item);\n        try {\n            /** @type {Array<function>} */ this._pending.forEach((f)=>f());\n        } catch (e) {\n            console.error(e);\n        }\n        this._pending = null;\n    }\n    _copy() {\n        return new YText();\n    }\n    /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {YText}\n   */ clone() {\n        const text = new YText();\n        text.applyDelta(this.toDelta());\n        return text;\n    }\n    /**\n   * Creates YTextEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */ _callObserver(transaction, parentSubs) {\n        super._callObserver(transaction, parentSubs);\n        const event = new YTextEvent(this, transaction, parentSubs);\n        callTypeObservers(this, transaction, event);\n        // If a remote change happened, we try to cleanup potential formatting duplicates.\n        if (!transaction.local && this._hasFormatting) {\n            transaction._needFormattingCleanup = true;\n        }\n    }\n    /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @public\n   */ toString() {\n        this.doc ?? warnPrematureAccess();\n        let str = \"\";\n        /**\n     * @type {Item|null}\n     */ let n = this._start;\n        while(n !== null){\n            if (!n.deleted && n.countable && n.content.constructor === ContentString) {\n                str += /** @type {ContentString} */ n.content.str;\n            }\n            n = n.right;\n        }\n        return str;\n    }\n    /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @return {string}\n   * @public\n   */ toJSON() {\n        return this.toString();\n    }\n    /**\n   * Apply a {@link Delta} on this shared YText type.\n   *\n   * @param {Array<any>} delta The changes to apply on this element.\n   * @param {object}  opts\n   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.\n   *\n   *\n   * @public\n   */ applyDelta(delta, { sanitize = true } = {}) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                const currPos = new ItemTextListPosition(null, this._start, 0, new Map());\n                for(let i = 0; i < delta.length; i++){\n                    const op = delta[i];\n                    if (op.insert !== undefined) {\n                        // Quill assumes that the content starts with an empty paragraph.\n                        // Yjs/Y.Text assumes that it starts empty. We always hide that\n                        // there is a newline at the end of the content.\n                        // If we omit this step, clients will see a different number of\n                        // paragraphs, but nothing bad will happen.\n                        const ins = !sanitize && typeof op.insert === \"string\" && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === \"\\n\" ? op.insert.slice(0, -1) : op.insert;\n                        if (typeof ins !== \"string\" || ins.length > 0) {\n                            insertText(transaction, this, currPos, ins, op.attributes || {});\n                        }\n                    } else if (op.retain !== undefined) {\n                        formatText(transaction, this, currPos, op.retain, op.attributes || {});\n                    } else if (op.delete !== undefined) {\n                        deleteText(transaction, currPos, op.delete);\n                    }\n                }\n            });\n        } else {\n            /** @type {Array<function>} */ this._pending.push(()=>this.applyDelta(delta));\n        }\n    }\n    /**\n   * Returns the Delta representation of this YText type.\n   *\n   * @param {Snapshot} [snapshot]\n   * @param {Snapshot} [prevSnapshot]\n   * @param {function('removed' | 'added', ID):any} [computeYChange]\n   * @return {any} The Delta representation of this type.\n   *\n   * @public\n   */ toDelta(snapshot, prevSnapshot, computeYChange) {\n        this.doc ?? warnPrematureAccess();\n        /**\n     * @type{Array<any>}\n     */ const ops = [];\n        const currentAttributes = new Map();\n        const doc = /** @type {Doc} */ this.doc;\n        let str = \"\";\n        let n = this._start;\n        function packStr() {\n            if (str.length > 0) {\n                // pack str with attributes to ops\n                /**\n         * @type {Object<string,any>}\n         */ const attributes = {};\n                let addAttributes = false;\n                currentAttributes.forEach((value, key)=>{\n                    addAttributes = true;\n                    attributes[key] = value;\n                });\n                /**\n         * @type {Object<string,any>}\n         */ const op = {\n                    insert: str\n                };\n                if (addAttributes) {\n                    op.attributes = attributes;\n                }\n                ops.push(op);\n                str = \"\";\n            }\n        }\n        const computeDelta = ()=>{\n            while(n !== null){\n                if (isVisible(n, snapshot) || prevSnapshot !== undefined && isVisible(n, prevSnapshot)) {\n                    switch(n.content.constructor){\n                        case ContentString:\n                            {\n                                const cur = currentAttributes.get(\"ychange\");\n                                if (snapshot !== undefined && !isVisible(n, snapshot)) {\n                                    if (cur === undefined || cur.user !== n.id.client || cur.type !== \"removed\") {\n                                        packStr();\n                                        currentAttributes.set(\"ychange\", computeYChange ? computeYChange(\"removed\", n.id) : {\n                                            type: \"removed\"\n                                        });\n                                    }\n                                } else if (prevSnapshot !== undefined && !isVisible(n, prevSnapshot)) {\n                                    if (cur === undefined || cur.user !== n.id.client || cur.type !== \"added\") {\n                                        packStr();\n                                        currentAttributes.set(\"ychange\", computeYChange ? computeYChange(\"added\", n.id) : {\n                                            type: \"added\"\n                                        });\n                                    }\n                                } else if (cur !== undefined) {\n                                    packStr();\n                                    currentAttributes.delete(\"ychange\");\n                                }\n                                str += /** @type {ContentString} */ n.content.str;\n                                break;\n                            }\n                        case ContentType:\n                        case ContentEmbed:\n                            {\n                                packStr();\n                                /**\n               * @type {Object<string,any>}\n               */ const op = {\n                                    insert: n.content.getContent()[0]\n                                };\n                                if (currentAttributes.size > 0) {\n                                    const attrs = /** @type {Object<string,any>} */ {};\n                                    op.attributes = attrs;\n                                    currentAttributes.forEach((value, key)=>{\n                                        attrs[key] = value;\n                                    });\n                                }\n                                ops.push(op);\n                                break;\n                            }\n                        case ContentFormat:\n                            if (isVisible(n, snapshot)) {\n                                packStr();\n                                updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ n.content);\n                            }\n                            break;\n                    }\n                }\n                n = n.right;\n            }\n            packStr();\n        };\n        if (snapshot || prevSnapshot) {\n            // snapshots are merged again after the transaction, so we need to keep the\n            // transaction alive until we are done\n            transact(doc, (transaction)=>{\n                if (snapshot) {\n                    splitSnapshotAffectedStructs(transaction, snapshot);\n                }\n                if (prevSnapshot) {\n                    splitSnapshotAffectedStructs(transaction, prevSnapshot);\n                }\n                computeDelta();\n            }, \"cleanup\");\n        } else {\n            computeDelta();\n        }\n        return ops;\n    }\n    /**\n   * Insert text at a given index.\n   *\n   * @param {number} index The index at which to start inserting.\n   * @param {String} text The text to insert at the specified position.\n   * @param {TextAttributes} [attributes] Optionally define some formatting\n   *                                    information to apply on the inserted\n   *                                    Text.\n   * @public\n   */ insert(index, text, attributes) {\n        if (text.length <= 0) {\n            return;\n        }\n        const y = this.doc;\n        if (y !== null) {\n            transact(y, (transaction)=>{\n                const pos = findPosition(transaction, this, index, !attributes);\n                if (!attributes) {\n                    attributes = {};\n                    // @ts-ignore\n                    pos.currentAttributes.forEach((v, k)=>{\n                        attributes[k] = v;\n                    });\n                }\n                insertText(transaction, this, pos, text, attributes);\n            });\n        } else {\n            /** @type {Array<function>} */ this._pending.push(()=>this.insert(index, text, attributes));\n        }\n    }\n    /**\n   * Inserts an embed at a index.\n   *\n   * @param {number} index The index to insert the embed at.\n   * @param {Object | AbstractType<any>} embed The Object that represents the embed.\n   * @param {TextAttributes} [attributes] Attribute information to apply on the\n   *                                    embed\n   *\n   * @public\n   */ insertEmbed(index, embed, attributes) {\n        const y = this.doc;\n        if (y !== null) {\n            transact(y, (transaction)=>{\n                const pos = findPosition(transaction, this, index, !attributes);\n                insertText(transaction, this, pos, embed, attributes || {});\n            });\n        } else {\n            /** @type {Array<function>} */ this._pending.push(()=>this.insertEmbed(index, embed, attributes || {}));\n        }\n    }\n    /**\n   * Deletes text starting from an index.\n   *\n   * @param {number} index Index at which to start deleting.\n   * @param {number} length The number of characters to remove. Defaults to 1.\n   *\n   * @public\n   */ delete(index, length) {\n        if (length === 0) {\n            return;\n        }\n        const y = this.doc;\n        if (y !== null) {\n            transact(y, (transaction)=>{\n                deleteText(transaction, findPosition(transaction, this, index, true), length);\n            });\n        } else {\n            /** @type {Array<function>} */ this._pending.push(()=>this.delete(index, length));\n        }\n    }\n    /**\n   * Assigns properties to a range of text.\n   *\n   * @param {number} index The position where to start formatting.\n   * @param {number} length The amount of characters to assign properties to.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    text.\n   *\n   * @public\n   */ format(index, length, attributes) {\n        if (length === 0) {\n            return;\n        }\n        const y = this.doc;\n        if (y !== null) {\n            transact(y, (transaction)=>{\n                const pos = findPosition(transaction, this, index, false);\n                if (pos.right === null) {\n                    return;\n                }\n                formatText(transaction, this, pos, length, attributes);\n            });\n        } else {\n            /** @type {Array<function>} */ this._pending.push(()=>this.format(index, length, attributes));\n        }\n    }\n    /**\n   * Removes an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */ removeAttribute(attributeName) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeMapDelete(transaction, this, attributeName);\n            });\n        } else {\n            /** @type {Array<function>} */ this._pending.push(()=>this.removeAttribute(attributeName));\n        }\n    }\n    /**\n   * Sets or updates an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be set.\n   * @param {any} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */ setAttribute(attributeName, attributeValue) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeMapSet(transaction, this, attributeName, attributeValue);\n            });\n        } else {\n            /** @type {Array<function>} */ this._pending.push(()=>this.setAttribute(attributeName, attributeValue));\n        }\n    }\n    /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {any} The queried attribute value.\n   *\n   * @public\n   */ getAttribute(attributeName) {\n        return /** @type {any} */ typeMapGet(this, attributeName);\n    }\n    /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @return {Object<string, any>} A JSON Object that describes the attributes.\n   *\n   * @public\n   */ getAttributes() {\n        return typeMapGetAll(this);\n    }\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */ _write(encoder) {\n        encoder.writeTypeRef(YTextRefID);\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder\n * @return {YText}\n *\n * @private\n * @function\n */ const readYText = (_decoder)=>new YText();\n/**\n * @module YXml\n */ /**\n * Define the elements to which a set of CSS queries apply.\n * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}\n *\n * @example\n *   query = '.classSelector'\n *   query = 'nodeSelector'\n *   query = '#idSelector'\n *\n * @typedef {string} CSS_Selector\n */ /**\n * Dom filter function.\n *\n * @callback domFilter\n * @param {string} nodeName The nodeName of the element\n * @param {Map} attributes The map of attributes.\n * @return {boolean} Whether to include the Dom node in the YXmlElement.\n */ /**\n * Represents a subset of the nodes of a YXmlElement / YXmlFragment and a\n * position within them.\n *\n * Can be created with {@link YXmlFragment#createTreeWalker}\n *\n * @public\n * @implements {Iterable<YXmlElement|YXmlText|YXmlElement|YXmlHook>}\n */ class YXmlTreeWalker {\n    /**\n   * @param {YXmlFragment | YXmlElement} root\n   * @param {function(AbstractType<any>):boolean} [f]\n   */ constructor(root, f = ()=>true){\n        this._filter = f;\n        this._root = root;\n        /**\n     * @type {Item}\n     */ this._currentNode = /** @type {Item} */ root._start;\n        this._firstCall = true;\n        root.doc ?? warnPrematureAccess();\n    }\n    [Symbol.iterator]() {\n        return this;\n    }\n    /**\n   * Get the next node.\n   *\n   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.\n   *\n   * @public\n   */ next() {\n        /**\n     * @type {Item|null}\n     */ let n = this._currentNode;\n        let type = n && n.content && /** @type {any} */ n.content.type;\n        if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) {\n            do {\n                type = /** @type {any} */ n.content.type;\n                if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {\n                    // walk down in the tree\n                    n = type._start;\n                } else {\n                    // walk right or up in the tree\n                    while(n !== null){\n                        /**\n             * @type {Item | null}\n             */ const nxt = n.next;\n                        if (nxt !== null) {\n                            n = nxt;\n                            break;\n                        } else if (n.parent === this._root) {\n                            n = null;\n                        } else {\n                            n = /** @type {AbstractType<any>} */ n.parent._item;\n                        }\n                    }\n                }\n            }while (n !== null && (n.deleted || !this._filter(/** @type {ContentType} */ n.content.type)));\n        }\n        this._firstCall = false;\n        if (n === null) {\n            // @ts-ignore\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        this._currentNode = n;\n        return {\n            value: /** @type {any} */ n.content.type,\n            done: false\n        };\n    }\n}\n/**\n * Represents a list of {@link YXmlElement}.and {@link YXmlText} types.\n * A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a\n * nodeName and it does not have attributes. Though it can be bound to a DOM\n * element - in this case the attributes and the nodeName are not shared.\n *\n * @public\n * @extends AbstractType<YXmlEvent>\n */ class YXmlFragment extends AbstractType {\n    constructor(){\n        super();\n        /**\n     * @type {Array<any>|null}\n     */ this._prelimContent = [];\n    }\n    /**\n   * @type {YXmlElement|YXmlText|null}\n   */ get firstChild() {\n        const first = this._first;\n        return first ? first.content.getContent()[0] : null;\n    }\n    /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */ _integrate(y, item) {\n        super._integrate(y, item);\n        this.insert(0, /** @type {Array<any>} */ this._prelimContent);\n        this._prelimContent = null;\n    }\n    _copy() {\n        return new YXmlFragment();\n    }\n    /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {YXmlFragment}\n   */ clone() {\n        const el = new YXmlFragment();\n        // @ts-ignore\n        el.insert(0, this.toArray().map((item)=>item instanceof AbstractType ? item.clone() : item));\n        return el;\n    }\n    get length() {\n        this.doc ?? warnPrematureAccess();\n        return this._prelimContent === null ? this._length : this._prelimContent.length;\n    }\n    /**\n   * Create a subtree of childNodes.\n   *\n   * @example\n   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')\n   * for (let node in walker) {\n   *   // `node` is a div node\n   *   nop(node)\n   * }\n   *\n   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and\n   *                          returns a Boolean indicating whether the child\n   *                          is to be included in the subtree.\n   * @return {YXmlTreeWalker} A subtree and a position within it.\n   *\n   * @public\n   */ createTreeWalker(filter) {\n        return new YXmlTreeWalker(this, filter);\n    }\n    /**\n   * Returns the first YXmlElement that matches the query.\n   * Similar to DOM's {@link querySelector}.\n   *\n   * Query support:\n   *   - tagname\n   * TODO:\n   *   - id\n   *   - attribute\n   *\n   * @param {CSS_Selector} query The query on the children.\n   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.\n   *\n   * @public\n   */ querySelector(query) {\n        query = query.toUpperCase();\n        // @ts-ignore\n        const iterator = new YXmlTreeWalker(this, (element)=>element.nodeName && element.nodeName.toUpperCase() === query);\n        const next = iterator.next();\n        if (next.done) {\n            return null;\n        } else {\n            return next.value;\n        }\n    }\n    /**\n   * Returns all YXmlElements that match the query.\n   * Similar to Dom's {@link querySelectorAll}.\n   *\n   * @todo Does not yet support all queries. Currently only query by tagName.\n   *\n   * @param {CSS_Selector} query The query on the children\n   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.\n   *\n   * @public\n   */ querySelectorAll(query) {\n        query = query.toUpperCase();\n        // @ts-ignore\n        return lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(new YXmlTreeWalker(this, (element)=>element.nodeName && element.nodeName.toUpperCase() === query));\n    }\n    /**\n   * Creates YXmlEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */ _callObserver(transaction, parentSubs) {\n        callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));\n    }\n    /**\n   * Get the string representation of all the children of this YXmlFragment.\n   *\n   * @return {string} The string representation of all children.\n   */ toString() {\n        return typeListMap(this, (xml)=>xml.toString()).join(\"\");\n    }\n    /**\n   * @return {string}\n   */ toJSON() {\n        return this.toString();\n    }\n    /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */ toDOM(_document = document, hooks = {}, binding) {\n        const fragment = _document.createDocumentFragment();\n        if (binding !== undefined) {\n            binding._createAssociation(fragment, this);\n        }\n        typeListForEach(this, (xmlType)=>{\n            fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);\n        });\n        return fragment;\n    }\n    /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {number} index The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */ insert(index, content) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeListInsertGenerics(transaction, this, index, content);\n            });\n        } else {\n            // @ts-ignore _prelimContent is defined because this is not yet integrated\n            this._prelimContent.splice(index, 0, ...content);\n        }\n    }\n    /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */ insertAfter(ref, content) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                const refItem = ref && ref instanceof AbstractType ? ref._item : ref;\n                typeListInsertGenericsAfter(transaction, this, refItem, content);\n            });\n        } else {\n            const pc = /** @type {Array<any>} */ this._prelimContent;\n            const index = ref === null ? 0 : pc.findIndex((el)=>el === ref) + 1;\n            if (index === 0 && ref !== null) {\n                throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.create(\"Reference item not found\");\n            }\n            pc.splice(index, 0, ...content);\n        }\n    }\n    /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} [length=1] The number of elements to remove. Defaults to 1.\n   */ delete(index, length = 1) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeListDelete(transaction, this, index, length);\n            });\n        } else {\n            // @ts-ignore _prelimContent is defined because this is not yet integrated\n            this._prelimContent.splice(index, length);\n        }\n    }\n    /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<YXmlElement|YXmlText|YXmlHook>}\n   */ toArray() {\n        return typeListToArray(this);\n    }\n    /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.\n   */ push(content) {\n        this.insert(this.length, content);\n    }\n    /**\n   * Prepends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.\n   */ unshift(content) {\n        this.insert(0, content);\n    }\n    /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {YXmlElement|YXmlText}\n   */ get(index) {\n        return typeListGet(this, index);\n    }\n    /**\n   * Returns a portion of this YXmlFragment into a JavaScript Array selected\n   * from start to end (end not included).\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<YXmlElement|YXmlText>}\n   */ slice(start = 0, end = this.length) {\n        return typeListSlice(this, start, end);\n    }\n    /**\n   * Executes a provided function on once on every child element.\n   *\n   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.\n   */ forEach(f) {\n        typeListForEach(this, f);\n    }\n    /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */ _write(encoder) {\n        encoder.writeTypeRef(YXmlFragmentRefID);\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder\n * @return {YXmlFragment}\n *\n * @private\n * @function\n */ const readYXmlFragment = (_decoder)=>new YXmlFragment();\n/**\n * @typedef {Object|number|null|Array<any>|string|Uint8Array|AbstractType<any>} ValueTypes\n */ /**\n * An YXmlElement imitates the behavior of a\n * https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element\n *\n * * An YXmlElement has attributes (key value pairs)\n * * An YXmlElement has childElements that must inherit from YXmlElement\n *\n * @template {{ [key: string]: ValueTypes }} [KV={ [key: string]: string }]\n */ class YXmlElement extends YXmlFragment {\n    constructor(nodeName = \"UNDEFINED\"){\n        super();\n        this.nodeName = nodeName;\n        /**\n     * @type {Map<string, any>|null}\n     */ this._prelimAttrs = new Map();\n    }\n    /**\n   * @type {YXmlElement|YXmlText|null}\n   */ get nextSibling() {\n        const n = this._item ? this._item.next : null;\n        return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */ n.content.type : null;\n    }\n    /**\n   * @type {YXmlElement|YXmlText|null}\n   */ get prevSibling() {\n        const n = this._item ? this._item.prev : null;\n        return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */ n.content.type : null;\n    }\n    /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */ _integrate(y, item) {\n        super._integrate(y, item);\n        /** @type {Map<string, any>} */ this._prelimAttrs.forEach((value, key)=>{\n            this.setAttribute(key, value);\n        });\n        this._prelimAttrs = null;\n    }\n    /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   *\n   * @return {YXmlElement}\n   */ _copy() {\n        return new YXmlElement(this.nodeName);\n    }\n    /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {YXmlElement<KV>}\n   */ clone() {\n        /**\n     * @type {YXmlElement<KV>}\n     */ const el = new YXmlElement(this.nodeName);\n        const attrs = this.getAttributes();\n        lib0_object__WEBPACK_IMPORTED_MODULE_18__.forEach(attrs, (value, key)=>{\n            if (typeof value === \"string\") {\n                el.setAttribute(key, value);\n            }\n        });\n        // @ts-ignore\n        el.insert(0, this.toArray().map((item)=>item instanceof AbstractType ? item.clone() : item));\n        return el;\n    }\n    /**\n   * Returns the XML serialization of this YXmlElement.\n   * The attributes are ordered by attribute-name, so you can easily use this\n   * method to compare YXmlElements\n   *\n   * @return {string} The string representation of this type.\n   *\n   * @public\n   */ toString() {\n        const attrs = this.getAttributes();\n        const stringBuilder = [];\n        const keys = [];\n        for(const key in attrs){\n            keys.push(key);\n        }\n        keys.sort();\n        const keysLen = keys.length;\n        for(let i = 0; i < keysLen; i++){\n            const key = keys[i];\n            stringBuilder.push(key + '=\"' + attrs[key] + '\"');\n        }\n        const nodeName = this.nodeName.toLocaleLowerCase();\n        const attrsString = stringBuilder.length > 0 ? \" \" + stringBuilder.join(\" \") : \"\";\n        return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;\n    }\n    /**\n   * Removes an attribute from this YXmlElement.\n   *\n   * @param {string} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */ removeAttribute(attributeName) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeMapDelete(transaction, this, attributeName);\n            });\n        } else {\n            /** @type {Map<string,any>} */ this._prelimAttrs.delete(attributeName);\n        }\n    }\n    /**\n   * Sets or updates an attribute.\n   *\n   * @template {keyof KV & string} KEY\n   *\n   * @param {KEY} attributeName The attribute name that is to be set.\n   * @param {KV[KEY]} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */ setAttribute(attributeName, attributeValue) {\n        if (this.doc !== null) {\n            transact(this.doc, (transaction)=>{\n                typeMapSet(transaction, this, attributeName, attributeValue);\n            });\n        } else {\n            /** @type {Map<string, any>} */ this._prelimAttrs.set(attributeName, attributeValue);\n        }\n    }\n    /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @template {keyof KV & string} KEY\n   *\n   * @param {KEY} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {KV[KEY]|undefined} The queried attribute value.\n   *\n   * @public\n   */ getAttribute(attributeName) {\n        return /** @type {any} */ typeMapGet(this, attributeName);\n    }\n    /**\n   * Returns whether an attribute exists\n   *\n   * @param {string} attributeName The attribute name to check for existence.\n   * @return {boolean} whether the attribute exists.\n   *\n   * @public\n   */ hasAttribute(attributeName) {\n        return /** @type {any} */ typeMapHas(this, attributeName);\n    }\n    /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @param {Snapshot} [snapshot]\n   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.\n   *\n   * @public\n   */ getAttributes(snapshot) {\n        return /** @type {any} */ snapshot ? typeMapGetAllSnapshot(this, snapshot) : typeMapGetAll(this);\n    }\n    /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */ toDOM(_document = document, hooks = {}, binding) {\n        const dom = _document.createElement(this.nodeName);\n        const attrs = this.getAttributes();\n        for(const key in attrs){\n            const value = attrs[key];\n            if (typeof value === \"string\") {\n                dom.setAttribute(key, value);\n            }\n        }\n        typeListForEach(this, (yxml)=>{\n            dom.appendChild(yxml.toDOM(_document, hooks, binding));\n        });\n        if (binding !== undefined) {\n            binding._createAssociation(dom, this);\n        }\n        return dom;\n    }\n    /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */ _write(encoder) {\n        encoder.writeTypeRef(YXmlElementRefID);\n        encoder.writeKey(this.nodeName);\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlElement}\n *\n * @function\n */ const readYXmlElement = (decoder)=>new YXmlElement(decoder.readKey());\n/**\n * @extends YEvent<YXmlElement|YXmlText|YXmlFragment>\n * An Event that describes changes on a YXml Element or Yxml Fragment\n */ class YXmlEvent extends YEvent {\n    /**\n   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.\n   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the\n   *                   child list changed.\n   * @param {Transaction} transaction The transaction instance with which the\n   *                                  change was created.\n   */ constructor(target, subs, transaction){\n        super(target, transaction);\n        /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */ this.childListChanged = false;\n        /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */ this.attributesChanged = new Set();\n        subs.forEach((sub)=>{\n            if (sub === null) {\n                this.childListChanged = true;\n            } else {\n                this.attributesChanged.add(sub);\n            }\n        });\n    }\n}\n/**\n * You can manage binding to a custom type with YXmlHook.\n *\n * @extends {YMap<any>}\n */ class YXmlHook extends YMap {\n    /**\n   * @param {string} hookName nodeName of the Dom Node.\n   */ constructor(hookName){\n        super();\n        /**\n     * @type {string}\n     */ this.hookName = hookName;\n    }\n    /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   */ _copy() {\n        return new YXmlHook(this.hookName);\n    }\n    /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {YXmlHook}\n   */ clone() {\n        const el = new YXmlHook(this.hookName);\n        this.forEach((value, key)=>{\n            el.set(key, value);\n        });\n        return el;\n    }\n    /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type\n   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */ toDOM(_document = document, hooks = {}, binding) {\n        const hook = hooks[this.hookName];\n        let dom;\n        if (hook !== undefined) {\n            dom = hook.createDom(this);\n        } else {\n            dom = document.createElement(this.hookName);\n        }\n        dom.setAttribute(\"data-yjs-hook\", this.hookName);\n        if (binding !== undefined) {\n            binding._createAssociation(dom, this);\n        }\n        return dom;\n    }\n    /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */ _write(encoder) {\n        encoder.writeTypeRef(YXmlHookRefID);\n        encoder.writeKey(this.hookName);\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlHook}\n *\n * @private\n * @function\n */ const readYXmlHook = (decoder)=>new YXmlHook(decoder.readKey());\n/**\n * Represents text in a Dom Element. In the future this type will also handle\n * simple formatting information like bold and italic.\n */ class YXmlText extends YText {\n    /**\n   * @type {YXmlElement|YXmlText|null}\n   */ get nextSibling() {\n        const n = this._item ? this._item.next : null;\n        return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */ n.content.type : null;\n    }\n    /**\n   * @type {YXmlElement|YXmlText|null}\n   */ get prevSibling() {\n        const n = this._item ? this._item.prev : null;\n        return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */ n.content.type : null;\n    }\n    _copy() {\n        return new YXmlText();\n    }\n    /**\n   * Makes a copy of this data type that can be included somewhere else.\n   *\n   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n   *\n   * @return {YXmlText}\n   */ clone() {\n        const text = new YXmlText();\n        text.applyDelta(this.toDelta());\n        return text;\n    }\n    /**\n   * Creates a Dom Element that mirrors this YXmlText.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */ toDOM(_document = document, hooks, binding) {\n        const dom = _document.createTextNode(this.toString());\n        if (binding !== undefined) {\n            binding._createAssociation(dom, this);\n        }\n        return dom;\n    }\n    toString() {\n        // @ts-ignore\n        return this.toDelta().map((delta)=>{\n            const nestedNodes = [];\n            for(const nodeName in delta.attributes){\n                const attrs = [];\n                for(const key in delta.attributes[nodeName]){\n                    attrs.push({\n                        key,\n                        value: delta.attributes[nodeName][key]\n                    });\n                }\n                // sort attributes to get a unique order\n                attrs.sort((a, b)=>a.key < b.key ? -1 : 1);\n                nestedNodes.push({\n                    nodeName,\n                    attrs\n                });\n            }\n            // sort node order to get a unique order\n            nestedNodes.sort((a, b)=>a.nodeName < b.nodeName ? -1 : 1);\n            // now convert to dom string\n            let str = \"\";\n            for(let i = 0; i < nestedNodes.length; i++){\n                const node = nestedNodes[i];\n                str += `<${node.nodeName}`;\n                for(let j = 0; j < node.attrs.length; j++){\n                    const attr = node.attrs[j];\n                    str += ` ${attr.key}=\"${attr.value}\"`;\n                }\n                str += \">\";\n            }\n            str += delta.insert;\n            for(let i = nestedNodes.length - 1; i >= 0; i--){\n                str += `</${nestedNodes[i].nodeName}>`;\n            }\n            return str;\n        }).join(\"\");\n    }\n    /**\n   * @return {string}\n   */ toJSON() {\n        return this.toString();\n    }\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */ _write(encoder) {\n        encoder.writeTypeRef(YXmlTextRefID);\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlText}\n *\n * @private\n * @function\n */ const readYXmlText = (decoder)=>new YXmlText();\nclass AbstractStruct {\n    /**\n   * @param {ID} id\n   * @param {number} length\n   */ constructor(id, length){\n        this.id = id;\n        this.length = length;\n    }\n    /**\n   * @type {boolean}\n   */ get deleted() {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();\n    }\n    /**\n   * Merge this struct with the item to the right.\n   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.\n   * Also this method does *not* remove right from StructStore!\n   * @param {AbstractStruct} right\n   * @return {boolean} whether this merged with right\n   */ mergeWith(right) {\n        return false;\n    }\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   * @param {number} encodingRef\n   */ write(encoder, offset, encodingRef) {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */ integrate(transaction, offset) {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();\n    }\n}\nconst structGCRefNumber = 0;\n/**\n * @private\n */ class GC extends AbstractStruct {\n    get deleted() {\n        return true;\n    }\n    delete() {}\n    /**\n   * @param {GC} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        if (this.constructor !== right.constructor) {\n            return false;\n        }\n        this.length += right.length;\n        return true;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */ integrate(transaction, offset) {\n        if (offset > 0) {\n            this.id.clock += offset;\n            this.length -= offset;\n        }\n        addStruct(transaction.doc.store, this);\n    }\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        encoder.writeInfo(structGCRefNumber);\n        encoder.writeLen(this.length - offset);\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */ getMissing(transaction, store) {\n        return null;\n    }\n}\nclass ContentBinary {\n    /**\n   * @param {Uint8Array} content\n   */ constructor(content){\n        this.content = content;\n    }\n    /**\n   * @return {number}\n   */ getLength() {\n        return 1;\n    }\n    /**\n   * @return {Array<any>}\n   */ getContent() {\n        return [\n            this.content\n        ];\n    }\n    /**\n   * @return {boolean}\n   */ isCountable() {\n        return true;\n    }\n    /**\n   * @return {ContentBinary}\n   */ copy() {\n        return new ContentBinary(this.content);\n    }\n    /**\n   * @param {number} offset\n   * @return {ContentBinary}\n   */ splice(offset) {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();\n    }\n    /**\n   * @param {ContentBinary} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        return false;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */ integrate(transaction, item) {}\n    /**\n   * @param {Transaction} transaction\n   */ delete(transaction) {}\n    /**\n   * @param {StructStore} store\n   */ gc(store) {}\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        encoder.writeBuf(this.content);\n    }\n    /**\n   * @return {number}\n   */ getRef() {\n        return 3;\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentBinary}\n */ const readContentBinary = (decoder)=>new ContentBinary(decoder.readBuf());\nclass ContentDeleted {\n    /**\n   * @param {number} len\n   */ constructor(len){\n        this.len = len;\n    }\n    /**\n   * @return {number}\n   */ getLength() {\n        return this.len;\n    }\n    /**\n   * @return {Array<any>}\n   */ getContent() {\n        return [];\n    }\n    /**\n   * @return {boolean}\n   */ isCountable() {\n        return false;\n    }\n    /**\n   * @return {ContentDeleted}\n   */ copy() {\n        return new ContentDeleted(this.len);\n    }\n    /**\n   * @param {number} offset\n   * @return {ContentDeleted}\n   */ splice(offset) {\n        const right = new ContentDeleted(this.len - offset);\n        this.len = offset;\n        return right;\n    }\n    /**\n   * @param {ContentDeleted} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        this.len += right.len;\n        return true;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */ integrate(transaction, item) {\n        addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);\n        item.markDeleted();\n    }\n    /**\n   * @param {Transaction} transaction\n   */ delete(transaction) {}\n    /**\n   * @param {StructStore} store\n   */ gc(store) {}\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        encoder.writeLen(this.len - offset);\n    }\n    /**\n   * @return {number}\n   */ getRef() {\n        return 1;\n    }\n}\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentDeleted}\n */ const readContentDeleted = (decoder)=>new ContentDeleted(decoder.readLen());\n/**\n * @param {string} guid\n * @param {Object<string, any>} opts\n */ const createDocFromOpts = (guid, opts)=>new Doc({\n        guid,\n        ...opts,\n        shouldLoad: opts.shouldLoad || opts.autoLoad || false\n    });\n/**\n * @private\n */ class ContentDoc {\n    /**\n   * @param {Doc} doc\n   */ constructor(doc){\n        if (doc._item) {\n            console.error(\"This document was already integrated as a sub-document. You should create a second instance instead with the same guid.\");\n        }\n        /**\n     * @type {Doc}\n     */ this.doc = doc;\n        /**\n     * @type {any}\n     */ const opts = {};\n        this.opts = opts;\n        if (!doc.gc) {\n            opts.gc = false;\n        }\n        if (doc.autoLoad) {\n            opts.autoLoad = true;\n        }\n        if (doc.meta !== null) {\n            opts.meta = doc.meta;\n        }\n    }\n    /**\n   * @return {number}\n   */ getLength() {\n        return 1;\n    }\n    /**\n   * @return {Array<any>}\n   */ getContent() {\n        return [\n            this.doc\n        ];\n    }\n    /**\n   * @return {boolean}\n   */ isCountable() {\n        return true;\n    }\n    /**\n   * @return {ContentDoc}\n   */ copy() {\n        return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts));\n    }\n    /**\n   * @param {number} offset\n   * @return {ContentDoc}\n   */ splice(offset) {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();\n    }\n    /**\n   * @param {ContentDoc} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        return false;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */ integrate(transaction, item) {\n        // this needs to be reflected in doc.destroy as well\n        this.doc._item = item;\n        transaction.subdocsAdded.add(this.doc);\n        if (this.doc.shouldLoad) {\n            transaction.subdocsLoaded.add(this.doc);\n        }\n    }\n    /**\n   * @param {Transaction} transaction\n   */ delete(transaction) {\n        if (transaction.subdocsAdded.has(this.doc)) {\n            transaction.subdocsAdded.delete(this.doc);\n        } else {\n            transaction.subdocsRemoved.add(this.doc);\n        }\n    }\n    /**\n   * @param {StructStore} store\n   */ gc(store) {}\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        encoder.writeString(this.doc.guid);\n        encoder.writeAny(this.opts);\n    }\n    /**\n   * @return {number}\n   */ getRef() {\n        return 9;\n    }\n}\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentDoc}\n */ const readContentDoc = (decoder)=>new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));\n/**\n * @private\n */ class ContentEmbed {\n    /**\n   * @param {Object} embed\n   */ constructor(embed){\n        this.embed = embed;\n    }\n    /**\n   * @return {number}\n   */ getLength() {\n        return 1;\n    }\n    /**\n   * @return {Array<any>}\n   */ getContent() {\n        return [\n            this.embed\n        ];\n    }\n    /**\n   * @return {boolean}\n   */ isCountable() {\n        return true;\n    }\n    /**\n   * @return {ContentEmbed}\n   */ copy() {\n        return new ContentEmbed(this.embed);\n    }\n    /**\n   * @param {number} offset\n   * @return {ContentEmbed}\n   */ splice(offset) {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();\n    }\n    /**\n   * @param {ContentEmbed} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        return false;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */ integrate(transaction, item) {}\n    /**\n   * @param {Transaction} transaction\n   */ delete(transaction) {}\n    /**\n   * @param {StructStore} store\n   */ gc(store) {}\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        encoder.writeJSON(this.embed);\n    }\n    /**\n   * @return {number}\n   */ getRef() {\n        return 5;\n    }\n}\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentEmbed}\n */ const readContentEmbed = (decoder)=>new ContentEmbed(decoder.readJSON());\n/**\n * @private\n */ class ContentFormat {\n    /**\n   * @param {string} key\n   * @param {Object} value\n   */ constructor(key, value){\n        this.key = key;\n        this.value = value;\n    }\n    /**\n   * @return {number}\n   */ getLength() {\n        return 1;\n    }\n    /**\n   * @return {Array<any>}\n   */ getContent() {\n        return [];\n    }\n    /**\n   * @return {boolean}\n   */ isCountable() {\n        return false;\n    }\n    /**\n   * @return {ContentFormat}\n   */ copy() {\n        return new ContentFormat(this.key, this.value);\n    }\n    /**\n   * @param {number} _offset\n   * @return {ContentFormat}\n   */ splice(_offset) {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();\n    }\n    /**\n   * @param {ContentFormat} _right\n   * @return {boolean}\n   */ mergeWith(_right) {\n        return false;\n    }\n    /**\n   * @param {Transaction} _transaction\n   * @param {Item} item\n   */ integrate(_transaction, item) {\n        // @todo searchmarker are currently unsupported for rich text documents\n        const p = /** @type {YText} */ item.parent;\n        p._searchMarker = null;\n        p._hasFormatting = true;\n    }\n    /**\n   * @param {Transaction} transaction\n   */ delete(transaction) {}\n    /**\n   * @param {StructStore} store\n   */ gc(store) {}\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        encoder.writeKey(this.key);\n        encoder.writeJSON(this.value);\n    }\n    /**\n   * @return {number}\n   */ getRef() {\n        return 6;\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentFormat}\n */ const readContentFormat = (decoder)=>new ContentFormat(decoder.readKey(), decoder.readJSON());\n/**\n * @private\n */ class ContentJSON {\n    /**\n   * @param {Array<any>} arr\n   */ constructor(arr){\n        /**\n     * @type {Array<any>}\n     */ this.arr = arr;\n    }\n    /**\n   * @return {number}\n   */ getLength() {\n        return this.arr.length;\n    }\n    /**\n   * @return {Array<any>}\n   */ getContent() {\n        return this.arr;\n    }\n    /**\n   * @return {boolean}\n   */ isCountable() {\n        return true;\n    }\n    /**\n   * @return {ContentJSON}\n   */ copy() {\n        return new ContentJSON(this.arr);\n    }\n    /**\n   * @param {number} offset\n   * @return {ContentJSON}\n   */ splice(offset) {\n        const right = new ContentJSON(this.arr.slice(offset));\n        this.arr = this.arr.slice(0, offset);\n        return right;\n    }\n    /**\n   * @param {ContentJSON} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        this.arr = this.arr.concat(right.arr);\n        return true;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */ integrate(transaction, item) {}\n    /**\n   * @param {Transaction} transaction\n   */ delete(transaction) {}\n    /**\n   * @param {StructStore} store\n   */ gc(store) {}\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        const len = this.arr.length;\n        encoder.writeLen(len - offset);\n        for(let i = offset; i < len; i++){\n            const c = this.arr[i];\n            encoder.writeString(c === undefined ? \"undefined\" : JSON.stringify(c));\n        }\n    }\n    /**\n   * @return {number}\n   */ getRef() {\n        return 2;\n    }\n}\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentJSON}\n */ const readContentJSON = (decoder)=>{\n    const len = decoder.readLen();\n    const cs = [];\n    for(let i = 0; i < len; i++){\n        const c = decoder.readString();\n        if (c === \"undefined\") {\n            cs.push(undefined);\n        } else {\n            cs.push(JSON.parse(c));\n        }\n    }\n    return new ContentJSON(cs);\n};\nconst isDevMode = lib0_environment__WEBPACK_IMPORTED_MODULE_19__.getVariable(\"node_env\") === \"development\";\nclass ContentAny {\n    /**\n   * @param {Array<any>} arr\n   */ constructor(arr){\n        /**\n     * @type {Array<any>}\n     */ this.arr = arr;\n        isDevMode && lib0_object__WEBPACK_IMPORTED_MODULE_18__.deepFreeze(arr);\n    }\n    /**\n   * @return {number}\n   */ getLength() {\n        return this.arr.length;\n    }\n    /**\n   * @return {Array<any>}\n   */ getContent() {\n        return this.arr;\n    }\n    /**\n   * @return {boolean}\n   */ isCountable() {\n        return true;\n    }\n    /**\n   * @return {ContentAny}\n   */ copy() {\n        return new ContentAny(this.arr);\n    }\n    /**\n   * @param {number} offset\n   * @return {ContentAny}\n   */ splice(offset) {\n        const right = new ContentAny(this.arr.slice(offset));\n        this.arr = this.arr.slice(0, offset);\n        return right;\n    }\n    /**\n   * @param {ContentAny} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        this.arr = this.arr.concat(right.arr);\n        return true;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */ integrate(transaction, item) {}\n    /**\n   * @param {Transaction} transaction\n   */ delete(transaction) {}\n    /**\n   * @param {StructStore} store\n   */ gc(store) {}\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        const len = this.arr.length;\n        encoder.writeLen(len - offset);\n        for(let i = offset; i < len; i++){\n            const c = this.arr[i];\n            encoder.writeAny(c);\n        }\n    }\n    /**\n   * @return {number}\n   */ getRef() {\n        return 8;\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentAny}\n */ const readContentAny = (decoder)=>{\n    const len = decoder.readLen();\n    const cs = [];\n    for(let i = 0; i < len; i++){\n        cs.push(decoder.readAny());\n    }\n    return new ContentAny(cs);\n};\n/**\n * @private\n */ class ContentString {\n    /**\n   * @param {string} str\n   */ constructor(str){\n        /**\n     * @type {string}\n     */ this.str = str;\n    }\n    /**\n   * @return {number}\n   */ getLength() {\n        return this.str.length;\n    }\n    /**\n   * @return {Array<any>}\n   */ getContent() {\n        return this.str.split(\"\");\n    }\n    /**\n   * @return {boolean}\n   */ isCountable() {\n        return true;\n    }\n    /**\n   * @return {ContentString}\n   */ copy() {\n        return new ContentString(this.str);\n    }\n    /**\n   * @param {number} offset\n   * @return {ContentString}\n   */ splice(offset) {\n        const right = new ContentString(this.str.slice(offset));\n        this.str = this.str.slice(0, offset);\n        // Prevent encoding invalid documents because of splitting of surrogate pairs: https://github.com/yjs/yjs/issues/248\n        const firstCharCode = this.str.charCodeAt(offset - 1);\n        if (firstCharCode >= 0xD800 && firstCharCode <= 0xDBFF) {\n            // Last character of the left split is the start of a surrogate utf16/ucs2 pair.\n            // We don't support splitting of surrogate pairs because this may lead to invalid documents.\n            // Replace the invalid character with a unicode replacement character (� / U+FFFD)\n            this.str = this.str.slice(0, offset - 1) + \"�\";\n            // replace right as well\n            right.str = \"�\" + right.str.slice(1);\n        }\n        return right;\n    }\n    /**\n   * @param {ContentString} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        this.str += right.str;\n        return true;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */ integrate(transaction, item) {}\n    /**\n   * @param {Transaction} transaction\n   */ delete(transaction) {}\n    /**\n   * @param {StructStore} store\n   */ gc(store) {}\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));\n    }\n    /**\n   * @return {number}\n   */ getRef() {\n        return 4;\n    }\n}\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentString}\n */ const readContentString = (decoder)=>new ContentString(decoder.readString());\n/**\n * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractType<any>>}\n * @private\n */ const typeRefs = [\n    readYArray,\n    readYMap,\n    readYText,\n    readYXmlElement,\n    readYXmlFragment,\n    readYXmlHook,\n    readYXmlText\n];\nconst YArrayRefID = 0;\nconst YMapRefID = 1;\nconst YTextRefID = 2;\nconst YXmlElementRefID = 3;\nconst YXmlFragmentRefID = 4;\nconst YXmlHookRefID = 5;\nconst YXmlTextRefID = 6;\n/**\n * @private\n */ class ContentType {\n    /**\n   * @param {AbstractType<any>} type\n   */ constructor(type){\n        /**\n     * @type {AbstractType<any>}\n     */ this.type = type;\n    }\n    /**\n   * @return {number}\n   */ getLength() {\n        return 1;\n    }\n    /**\n   * @return {Array<any>}\n   */ getContent() {\n        return [\n            this.type\n        ];\n    }\n    /**\n   * @return {boolean}\n   */ isCountable() {\n        return true;\n    }\n    /**\n   * @return {ContentType}\n   */ copy() {\n        return new ContentType(this.type._copy());\n    }\n    /**\n   * @param {number} offset\n   * @return {ContentType}\n   */ splice(offset) {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();\n    }\n    /**\n   * @param {ContentType} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        return false;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */ integrate(transaction, item) {\n        this.type._integrate(transaction.doc, item);\n    }\n    /**\n   * @param {Transaction} transaction\n   */ delete(transaction) {\n        let item = this.type._start;\n        while(item !== null){\n            if (!item.deleted) {\n                item.delete(transaction);\n            } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {\n                // This will be gc'd later and we want to merge it if possible\n                // We try to merge all deleted items after each transaction,\n                // but we have no knowledge about that this needs to be merged\n                // since it is not in transaction.ds. Hence we add it to transaction._mergeStructs\n                transaction._mergeStructs.push(item);\n            }\n            item = item.right;\n        }\n        this.type._map.forEach((item)=>{\n            if (!item.deleted) {\n                item.delete(transaction);\n            } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {\n                // same as above\n                transaction._mergeStructs.push(item);\n            }\n        });\n        transaction.changed.delete(this.type);\n    }\n    /**\n   * @param {StructStore} store\n   */ gc(store) {\n        let item = this.type._start;\n        while(item !== null){\n            item.gc(store, true);\n            item = item.right;\n        }\n        this.type._start = null;\n        this.type._map.forEach(/** @param {Item | null} item */ (item)=>{\n            while(item !== null){\n                item.gc(store, true);\n                item = item.left;\n            }\n        });\n        this.type._map = new Map();\n    }\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        this.type._write(encoder);\n    }\n    /**\n   * @return {number}\n   */ getRef() {\n        return 7;\n    }\n}\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentType}\n */ const readContentType = (decoder)=>new ContentType(typeRefs[decoder.readTypeRef()](decoder));\n/**\n * @todo This should return several items\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {{item:Item, diff:number}}\n */ const followRedone = (store, id)=>{\n    /**\n   * @type {ID|null}\n   */ let nextID = id;\n    let diff = 0;\n    let item;\n    do {\n        if (diff > 0) {\n            nextID = createID(nextID.client, nextID.clock + diff);\n        }\n        item = getItem(store, nextID);\n        diff = nextID.clock - item.id.clock;\n        nextID = item.redone;\n    }while (nextID !== null && item instanceof Item);\n    return {\n        item,\n        diff\n    };\n};\n/**\n * Make sure that neither item nor any of its parents is ever deleted.\n *\n * This property does not persist when storing it into a database or when\n * sending it to other peers\n *\n * @param {Item|null} item\n * @param {boolean} keep\n */ const keepItem = (item, keep)=>{\n    while(item !== null && item.keep !== keep){\n        item.keep = keep;\n        item = /** @type {AbstractType<any>} */ item.parent._item;\n    }\n};\n/**\n * Split leftItem into two items\n * @param {Transaction} transaction\n * @param {Item} leftItem\n * @param {number} diff\n * @return {Item}\n *\n * @function\n * @private\n */ const splitItem = (transaction, leftItem, diff)=>{\n    // create rightItem\n    const { client, clock } = leftItem.id;\n    const rightItem = new Item(createID(client, clock + diff), leftItem, createID(client, clock + diff - 1), leftItem.right, leftItem.rightOrigin, leftItem.parent, leftItem.parentSub, leftItem.content.splice(diff));\n    if (leftItem.deleted) {\n        rightItem.markDeleted();\n    }\n    if (leftItem.keep) {\n        rightItem.keep = true;\n    }\n    if (leftItem.redone !== null) {\n        rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);\n    }\n    // update left (do not set leftItem.rightOrigin as it will lead to problems when syncing)\n    leftItem.right = rightItem;\n    // update right\n    if (rightItem.right !== null) {\n        rightItem.right.left = rightItem;\n    }\n    // right is more specific.\n    transaction._mergeStructs.push(rightItem);\n    // update parent._map\n    if (rightItem.parentSub !== null && rightItem.right === null) {\n        /** @type {AbstractType<any>} */ rightItem.parent._map.set(rightItem.parentSub, rightItem);\n    }\n    leftItem.length = diff;\n    return rightItem;\n};\n/**\n * @param {Array<StackItem>} stack\n * @param {ID} id\n */ const isDeletedByUndoStack = (stack, id)=>lib0_array__WEBPACK_IMPORTED_MODULE_2__.some(stack, /** @param {StackItem} s */ (s)=>isDeleted(s.deletions, id));\n/**\n * Redoes the effect of this operation.\n *\n * @param {Transaction} transaction The Yjs instance.\n * @param {Item} item\n * @param {Set<Item>} redoitems\n * @param {DeleteSet} itemsToDelete\n * @param {boolean} ignoreRemoteMapChanges\n * @param {import('../utils/UndoManager.js').UndoManager} um\n *\n * @return {Item|null}\n *\n * @private\n */ const redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um)=>{\n    const doc = transaction.doc;\n    const store = doc.store;\n    const ownClientID = doc.clientID;\n    const redone = item.redone;\n    if (redone !== null) {\n        return getItemCleanStart(transaction, redone);\n    }\n    let parentItem = /** @type {AbstractType<any>} */ item.parent._item;\n    /**\n   * @type {Item|null}\n   */ let left = null;\n    /**\n   * @type {Item|null}\n   */ let right;\n    // make sure that parent is redone\n    if (parentItem !== null && parentItem.deleted === true) {\n        // try to undo parent if it will be undone anyway\n        if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {\n            return null;\n        }\n        while(parentItem.redone !== null){\n            parentItem = getItemCleanStart(transaction, parentItem.redone);\n        }\n    }\n    const parentType = parentItem === null ? /** @type {AbstractType<any>} */ item.parent : /** @type {ContentType} */ parentItem.content.type;\n    if (item.parentSub === null) {\n        // Is an array item. Insert at the old position\n        left = item.left;\n        right = item;\n        // find next cloned_redo items\n        while(left !== null){\n            /**\n       * @type {Item|null}\n       */ let leftTrace = left;\n            // trace redone until parent matches\n            while(leftTrace !== null && /** @type {AbstractType<any>} */ leftTrace.parent._item !== parentItem){\n                leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);\n            }\n            if (leftTrace !== null && /** @type {AbstractType<any>} */ leftTrace.parent._item === parentItem) {\n                left = leftTrace;\n                break;\n            }\n            left = left.left;\n        }\n        while(right !== null){\n            /**\n       * @type {Item|null}\n       */ let rightTrace = right;\n            // trace redone until parent matches\n            while(rightTrace !== null && /** @type {AbstractType<any>} */ rightTrace.parent._item !== parentItem){\n                rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);\n            }\n            if (rightTrace !== null && /** @type {AbstractType<any>} */ rightTrace.parent._item === parentItem) {\n                right = rightTrace;\n                break;\n            }\n            right = right.right;\n        }\n    } else {\n        right = null;\n        if (item.right && !ignoreRemoteMapChanges) {\n            left = item;\n            // Iterate right while right is in itemsToDelete\n            // If it is intended to delete right while item is redone, we can expect that item should replace right.\n            while(left !== null && left.right !== null && (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))){\n                left = left.right;\n                // follow redone\n                while(left.redone)left = getItemCleanStart(transaction, left.redone);\n            }\n            if (left && left.right !== null) {\n                // It is not possible to redo this item because it conflicts with a\n                // change from another client\n                return null;\n            }\n        } else {\n            left = parentType._map.get(item.parentSub) || null;\n        }\n    }\n    const nextClock = getState(store, ownClientID);\n    const nextId = createID(ownClientID, nextClock);\n    const redoneItem = new Item(nextId, left, left && left.lastId, right, right && right.id, parentType, item.parentSub, item.content.copy());\n    item.redone = nextId;\n    keepItem(redoneItem, true);\n    redoneItem.integrate(transaction, 0);\n    return redoneItem;\n};\n/**\n * Abstract class that represents any content.\n */ class Item extends AbstractStruct {\n    /**\n   * @param {ID} id\n   * @param {Item | null} left\n   * @param {ID | null} origin\n   * @param {Item | null} right\n   * @param {ID | null} rightOrigin\n   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.\n   * @param {string | null} parentSub\n   * @param {AbstractContent} content\n   */ constructor(id, left, origin, right, rightOrigin, parent, parentSub, content){\n        super(id, content.getLength());\n        /**\n     * The item that was originally to the left of this item.\n     * @type {ID | null}\n     */ this.origin = origin;\n        /**\n     * The item that is currently to the left of this item.\n     * @type {Item | null}\n     */ this.left = left;\n        /**\n     * The item that is currently to the right of this item.\n     * @type {Item | null}\n     */ this.right = right;\n        /**\n     * The item that was originally to the right of this item.\n     * @type {ID | null}\n     */ this.rightOrigin = rightOrigin;\n        /**\n     * @type {AbstractType<any>|ID|null}\n     */ this.parent = parent;\n        /**\n     * If the parent refers to this item with some kind of key (e.g. YMap, the\n     * key is specified here. The key is then used to refer to the list in which\n     * to insert this item. If `parentSub = null` type._start is the list in\n     * which to insert to. Otherwise it is `parent._map`.\n     * @type {String | null}\n     */ this.parentSub = parentSub;\n        /**\n     * If this type's effect is redone this type refers to the type that undid\n     * this operation.\n     * @type {ID | null}\n     */ this.redone = null;\n        /**\n     * @type {AbstractContent}\n     */ this.content = content;\n        /**\n     * bit1: keep\n     * bit2: countable\n     * bit3: deleted\n     * bit4: mark - mark node as fast-search-marker\n     * @type {number} byte\n     */ this.info = this.content.isCountable() ? lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT2 : 0;\n    }\n    /**\n   * This is used to mark the item as an indexed fast-search marker\n   *\n   * @type {boolean}\n   */ set marker(isMarked) {\n        if ((this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT4) > 0 !== isMarked) {\n            this.info ^= lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT4;\n        }\n    }\n    get marker() {\n        return (this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT4) > 0;\n    }\n    /**\n   * If true, do not garbage collect this Item.\n   */ get keep() {\n        return (this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT1) > 0;\n    }\n    set keep(doKeep) {\n        if (this.keep !== doKeep) {\n            this.info ^= lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT1;\n        }\n    }\n    get countable() {\n        return (this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT2) > 0;\n    }\n    /**\n   * Whether this item was deleted or not.\n   * @type {Boolean}\n   */ get deleted() {\n        return (this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT3) > 0;\n    }\n    set deleted(doDelete) {\n        if (this.deleted !== doDelete) {\n            this.info ^= lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT3;\n        }\n    }\n    markDeleted() {\n        this.info |= lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT3;\n    }\n    /**\n   * Return the creator clientID of the missing op or define missing items and return null.\n   *\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */ getMissing(transaction, store) {\n        if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {\n            return this.origin.client;\n        }\n        if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {\n            return this.rightOrigin.client;\n        }\n        if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {\n            return this.parent.client;\n        }\n        // We have all missing ids, now find the items\n        if (this.origin) {\n            this.left = getItemCleanEnd(transaction, store, this.origin);\n            this.origin = this.left.lastId;\n        }\n        if (this.rightOrigin) {\n            this.right = getItemCleanStart(transaction, this.rightOrigin);\n            this.rightOrigin = this.right.id;\n        }\n        if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {\n            this.parent = null;\n        } else if (!this.parent) {\n            // only set parent if this shouldn't be garbage collected\n            if (this.left && this.left.constructor === Item) {\n                this.parent = this.left.parent;\n                this.parentSub = this.left.parentSub;\n            } else if (this.right && this.right.constructor === Item) {\n                this.parent = this.right.parent;\n                this.parentSub = this.right.parentSub;\n            }\n        } else if (this.parent.constructor === ID) {\n            const parentItem = getItem(store, this.parent);\n            if (parentItem.constructor === GC) {\n                this.parent = null;\n            } else {\n                this.parent = /** @type {ContentType} */ parentItem.content.type;\n            }\n        }\n        return null;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */ integrate(transaction, offset) {\n        if (offset > 0) {\n            this.id.clock += offset;\n            this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));\n            this.origin = this.left.lastId;\n            this.content = this.content.splice(offset);\n            this.length -= offset;\n        }\n        if (this.parent) {\n            if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {\n                /**\n         * @type {Item|null}\n         */ let left = this.left;\n                /**\n         * @type {Item|null}\n         */ let o;\n                // set o to the first conflicting item\n                if (left !== null) {\n                    o = left.right;\n                } else if (this.parentSub !== null) {\n                    o = /** @type {AbstractType<any>} */ this.parent._map.get(this.parentSub) || null;\n                    while(o !== null && o.left !== null){\n                        o = o.left;\n                    }\n                } else {\n                    o = /** @type {AbstractType<any>} */ this.parent._start;\n                }\n                // TODO: use something like DeleteSet here (a tree implementation would be best)\n                // @todo use global set definitions\n                /**\n         * @type {Set<Item>}\n         */ const conflictingItems = new Set();\n                /**\n         * @type {Set<Item>}\n         */ const itemsBeforeOrigin = new Set();\n                // Let c in conflictingItems, b in itemsBeforeOrigin\n                // ***{origin}bbbb{this}{c,b}{c,b}{o}***\n                // Note that conflictingItems is a subset of itemsBeforeOrigin\n                while(o !== null && o !== this.right){\n                    itemsBeforeOrigin.add(o);\n                    conflictingItems.add(o);\n                    if (compareIDs(this.origin, o.origin)) {\n                        // case 1\n                        if (o.id.client < this.id.client) {\n                            left = o;\n                            conflictingItems.clear();\n                        } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {\n                            break;\n                        } // else, o might be integrated before an item that this conflicts with. If so, we will find it in the next iterations\n                    } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) {\n                        // case 2\n                        if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {\n                            left = o;\n                            conflictingItems.clear();\n                        }\n                    } else {\n                        break;\n                    }\n                    o = o.right;\n                }\n                this.left = left;\n            }\n            // reconnect left/right + update parent map/start if necessary\n            if (this.left !== null) {\n                const right = this.left.right;\n                this.right = right;\n                this.left.right = this;\n            } else {\n                let r;\n                if (this.parentSub !== null) {\n                    r = /** @type {AbstractType<any>} */ this.parent._map.get(this.parentSub) || null;\n                    while(r !== null && r.left !== null){\n                        r = r.left;\n                    }\n                } else {\n                    r = /** @type {AbstractType<any>} */ this.parent._start; /** @type {AbstractType<any>} */ \n                    this.parent._start = this;\n                }\n                this.right = r;\n            }\n            if (this.right !== null) {\n                this.right.left = this;\n            } else if (this.parentSub !== null) {\n                // set as current parent value if right === null and this is parentSub\n                /** @type {AbstractType<any>} */ this.parent._map.set(this.parentSub, this);\n                if (this.left !== null) {\n                    // this is the current attribute value of parent. delete right\n                    this.left.delete(transaction);\n                }\n            }\n            // adjust length of parent\n            if (this.parentSub === null && this.countable && !this.deleted) {\n                /** @type {AbstractType<any>} */ this.parent._length += this.length;\n            }\n            addStruct(transaction.doc.store, this);\n            this.content.integrate(transaction, this);\n            // add parent to transaction.changed\n            addChangedTypeToTransaction(transaction, /** @type {AbstractType<any>} */ this.parent, this.parentSub);\n            if (/** @type {AbstractType<any>} */ this.parent._item !== null && /** @type {AbstractType<any>} */ this.parent._item.deleted || this.parentSub !== null && this.right !== null) {\n                // delete if parent is deleted or if this is not the current attribute value of parent\n                this.delete(transaction);\n            }\n        } else {\n            // parent is not defined. Integrate GC struct instead\n            new GC(this.id, this.length).integrate(transaction, 0);\n        }\n    }\n    /**\n   * Returns the next non-deleted item\n   */ get next() {\n        let n = this.right;\n        while(n !== null && n.deleted){\n            n = n.right;\n        }\n        return n;\n    }\n    /**\n   * Returns the previous non-deleted item\n   */ get prev() {\n        let n = this.left;\n        while(n !== null && n.deleted){\n            n = n.left;\n        }\n        return n;\n    }\n    /**\n   * Computes the last content address of this Item.\n   */ get lastId() {\n        // allocating ids is pretty costly because of the amount of ids created, so we try to reuse whenever possible\n        return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);\n    }\n    /**\n   * Try to merge two items\n   *\n   * @param {Item} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {\n            const searchMarker = /** @type {AbstractType<any>} */ this.parent._searchMarker;\n            if (searchMarker) {\n                searchMarker.forEach((marker)=>{\n                    if (marker.p === right) {\n                        // right is going to be \"forgotten\" so we need to update the marker\n                        marker.p = this;\n                        // adjust marker index\n                        if (!this.deleted && this.countable) {\n                            marker.index -= this.length;\n                        }\n                    }\n                });\n            }\n            if (right.keep) {\n                this.keep = true;\n            }\n            this.right = right.right;\n            if (this.right !== null) {\n                this.right.left = this;\n            }\n            this.length += right.length;\n            return true;\n        }\n        return false;\n    }\n    /**\n   * Mark this Item as deleted.\n   *\n   * @param {Transaction} transaction\n   */ delete(transaction) {\n        if (!this.deleted) {\n            const parent = /** @type {AbstractType<any>} */ this.parent;\n            // adjust the length of parent\n            if (this.countable && this.parentSub === null) {\n                parent._length -= this.length;\n            }\n            this.markDeleted();\n            addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);\n            addChangedTypeToTransaction(transaction, parent, this.parentSub);\n            this.content.delete(transaction);\n        }\n    }\n    /**\n   * @param {StructStore} store\n   * @param {boolean} parentGCd\n   */ gc(store, parentGCd) {\n        if (!this.deleted) {\n            throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n        }\n        this.content.gc(store);\n        if (parentGCd) {\n            replaceStruct(store, this, new GC(this.id, this.length));\n        } else {\n            this.content = new ContentDeleted(this.length);\n        }\n    }\n    /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   */ write(encoder, offset) {\n        const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;\n        const rightOrigin = this.rightOrigin;\n        const parentSub = this.parentSub;\n        const info = this.content.getRef() & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BITS5 | (origin === null ? 0 : lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8) | // origin is defined\n        (rightOrigin === null ? 0 : lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7) | // right origin is defined\n        (parentSub === null ? 0 : lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6); // parentSub is non-null\n        encoder.writeInfo(info);\n        if (origin !== null) {\n            encoder.writeLeftID(origin);\n        }\n        if (rightOrigin !== null) {\n            encoder.writeRightID(rightOrigin);\n        }\n        if (origin === null && rightOrigin === null) {\n            const parent = /** @type {AbstractType<any>} */ this.parent;\n            if (parent._item !== undefined) {\n                const parentItem = parent._item;\n                if (parentItem === null) {\n                    // parent type on y._map\n                    // find the correct key\n                    const ykey = findRootTypeKey(parent);\n                    encoder.writeParentInfo(true); // write parentYKey\n                    encoder.writeString(ykey);\n                } else {\n                    encoder.writeParentInfo(false); // write parent id\n                    encoder.writeLeftID(parentItem.id);\n                }\n            } else if (parent.constructor === String) {\n                encoder.writeParentInfo(true); // write parentYKey\n                encoder.writeString(parent);\n            } else if (parent.constructor === ID) {\n                encoder.writeParentInfo(false); // write parent id\n                encoder.writeLeftID(parent);\n            } else {\n                lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n            }\n            if (parentSub !== null) {\n                encoder.writeString(parentSub);\n            }\n        }\n        this.content.write(encoder, offset);\n    }\n}\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @param {number} info\n */ const readItemContent = (decoder, info)=>contentRefs[info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BITS5](decoder);\n/**\n * A lookup map for reading Item content.\n *\n * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractContent>}\n */ const contentRefs = [\n    ()=>{\n        lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n    },\n    readContentDeleted,\n    readContentJSON,\n    readContentBinary,\n    readContentString,\n    readContentEmbed,\n    readContentFormat,\n    readContentType,\n    readContentAny,\n    readContentDoc,\n    ()=>{\n        lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n    } // 10 - Skip is not ItemContent\n];\nconst structSkipRefNumber = 10;\n/**\n * @private\n */ class Skip extends AbstractStruct {\n    get deleted() {\n        return true;\n    }\n    delete() {}\n    /**\n   * @param {Skip} right\n   * @return {boolean}\n   */ mergeWith(right) {\n        if (this.constructor !== right.constructor) {\n            return false;\n        }\n        this.length += right.length;\n        return true;\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */ integrate(transaction, offset) {\n        // skip structs cannot be integrated\n        lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n    }\n    /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */ write(encoder, offset) {\n        encoder.writeInfo(structSkipRefNumber);\n        // write as VarUint because Skips can't make use of predictable length-encoding\n        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, this.length - offset);\n    }\n    /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */ getMissing(transaction, store) {\n        return null;\n    }\n}\n/** eslint-env browser */ const glo = /** @type {any} */ typeof globalThis !== \"undefined\" ? globalThis :  false ? 0 : typeof global !== \"undefined\" ? global : {};\nconst importIdentifier = \"__ $YJS$ __\";\nif (glo[importIdentifier] === true) {\n    /**\n   * Dear reader of this message. Please take this seriously.\n   *\n   * If you see this message, make sure that you only import one version of Yjs. In many cases,\n   * your package manager installs two versions of Yjs that are used by different packages within your project.\n   * Another reason for this message is that some parts of your project use the commonjs version of Yjs\n   * and others use the EcmaScript version of Yjs.\n   *\n   * This often leads to issues that are hard to debug. We often need to perform constructor checks,\n   * e.g. `struct instanceof GC`. If you imported different versions of Yjs, it is impossible for us to\n   * do the constructor checks anymore - which might break the CRDT algorithm.\n   *\n   * https://github.com/yjs/yjs/issues/438\n   */ console.error(\"Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438\");\n}\nglo[importIdentifier] = true;\n //# sourceMappingURL=yjs.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveWpzL2Rpc3QveWpzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0M7QUFDWDtBQUNGO0FBQ0Y7QUFDVTtBQUNBO0FBQ0o7QUFDRTtBQUNGO0FBQ0Y7QUFDRTtBQUNIO0FBQ0s7QUFDUjtBQUNRO0FBQ047QUFDSTtBQUNJO0FBQ0o7QUFDRTtBQUV4Qzs7Ozs7OztDQU9DLEdBQ0QsTUFBTW9CLDBCQUEwQnBCLHlEQUFZQTtJQUMxQzs7O0dBR0MsR0FDRHFCLFlBQWFDLElBQUksRUFBRUMsU0FBUyxDQUFFO1FBQzVCLEtBQUs7UUFDTCxJQUFJLENBQUNDLEdBQUcsR0FBR0Y7UUFDWCxJQUFJLENBQUNDLFNBQVMsR0FBR0E7SUFDbkI7QUFDRjtBQUVBLE1BQU1FO0lBQ0o7OztHQUdDLEdBQ0RKLFlBQWFLLEtBQUssRUFBRUMsR0FBRyxDQUFFO1FBQ3ZCOztLQUVDLEdBQ0QsSUFBSSxDQUFDRCxLQUFLLEdBQUdBO1FBQ2I7O0tBRUMsR0FDRCxJQUFJLENBQUNDLEdBQUcsR0FBR0E7SUFDYjtBQUNGO0FBRUE7Ozs7OztDQU1DLEdBQ0QsTUFBTUM7SUFDSlAsYUFBZTtRQUNiOztLQUVDLEdBQ0QsSUFBSSxDQUFDUSxPQUFPLEdBQUcsSUFBSUM7SUFDckI7QUFDRjtBQUVBOzs7Ozs7OztDQVFDLEdBQ0QsTUFBTUMsd0JBQXdCLENBQUNDLGFBQWFDLElBQUl0QixJQUM5Q3NCLEdBQUdKLE9BQU8sQ0FBQ0ssT0FBTyxDQUFDLENBQUNDLFNBQVNDO1FBQzNCLE1BQU1DLFVBQVUsMkJBQTJCLEdBQUlMLFlBQVlSLEdBQUcsQ0FBQ2MsS0FBSyxDQUFDVCxPQUFPLENBQUNVLEdBQUcsQ0FBQ0g7UUFDakYsSUFBSUMsV0FBVyxN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QUFtQjtBQUV6QixJQUFJSixHQUFHLENBQUNJLGlCQUFpQixLQUFLLE1BQU07SUFDbEM7Ozs7Ozs7Ozs7Ozs7R0FhQyxHQUNEdmxCLFFBQVF2VyxLQUFLLENBQUM7QUFDaEI7QUFDQTA3QixHQUFHLENBQUNJLGlCQUFpQixHQUFHO0FBRWdzRCxDQUN4dEQsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3luY2RyYXctY2xpZW50Ly4vbm9kZV9tb2R1bGVzL3lqcy9kaXN0L3lqcy5tanM/ODg0NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlVjIgfSBmcm9tICdsaWIwL29ic2VydmFibGUnO1xuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnbGliMC9hcnJheSc7XG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCc7XG5pbXBvcnQgKiBhcyBtYXAgZnJvbSAnbGliMC9tYXAnO1xuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZyc7XG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICdsaWIwL2RlY29kaW5nJztcbmltcG9ydCAqIGFzIHJhbmRvbSBmcm9tICdsaWIwL3JhbmRvbSc7XG5pbXBvcnQgKiBhcyBwcm9taXNlIGZyb20gJ2xpYjAvcHJvbWlzZSc7XG5pbXBvcnQgKiBhcyBidWZmZXIgZnJvbSAnbGliMC9idWZmZXInO1xuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcic7XG5pbXBvcnQgKiBhcyBiaW5hcnkgZnJvbSAnbGliMC9iaW5hcnknO1xuaW1wb3J0ICogYXMgZiBmcm9tICdsaWIwL2Z1bmN0aW9uJztcbmltcG9ydCB7IGNhbGxBbGwgfSBmcm9tICdsaWIwL2Z1bmN0aW9uJztcbmltcG9ydCAqIGFzIHNldCBmcm9tICdsaWIwL3NldCc7XG5pbXBvcnQgKiBhcyBsb2dnaW5nIGZyb20gJ2xpYjAvbG9nZ2luZyc7XG5pbXBvcnQgKiBhcyB0aW1lIGZyb20gJ2xpYjAvdGltZSc7XG5pbXBvcnQgKiBhcyBzdHJpbmcgZnJvbSAnbGliMC9zdHJpbmcnO1xuaW1wb3J0ICogYXMgaXRlcmF0b3IgZnJvbSAnbGliMC9pdGVyYXRvcic7XG5pbXBvcnQgKiBhcyBvYmplY3QgZnJvbSAnbGliMC9vYmplY3QnO1xuaW1wb3J0ICogYXMgZW52IGZyb20gJ2xpYjAvZW52aXJvbm1lbnQnO1xuXG4vKipcbiAqIFRoaXMgaXMgYW4gYWJzdHJhY3QgaW50ZXJmYWNlIHRoYXQgYWxsIENvbm5lY3RvcnMgc2hvdWxkIGltcGxlbWVudCB0byBrZWVwIHRoZW0gaW50ZXJjaGFuZ2VhYmxlLlxuICpcbiAqIEBub3RlIFRoaXMgaW50ZXJmYWNlIGlzIGV4cGVyaW1lbnRhbCBhbmQgaXQgaXMgbm90IGFkdmlzZWQgdG8gYWN0dWFsbHkgaW5oZXJpdCB0aGlzIGNsYXNzLlxuICogICAgICAgSXQganVzdCBzZXJ2ZXMgYXMgdHlwaW5nIGluZm9ybWF0aW9uLlxuICpcbiAqIEBleHRlbmRzIHtPYnNlcnZhYmxlVjI8YW55Pn1cbiAqL1xuY2xhc3MgQWJzdHJhY3RDb25uZWN0b3IgZXh0ZW5kcyBPYnNlcnZhYmxlVjIge1xuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IHlkb2NcbiAgICogQHBhcmFtIHthbnl9IGF3YXJlbmVzc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHlkb2MsIGF3YXJlbmVzcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kb2MgPSB5ZG9jO1xuICAgIHRoaXMuYXdhcmVuZXNzID0gYXdhcmVuZXNzO1xuICB9XG59XG5cbmNsYXNzIERlbGV0ZUl0ZW0ge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChjbG9jaywgbGVuKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsb2NrID0gY2xvY2s7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IGxlbjtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5vIGxvbmdlciBtYWludGFpbiBhIERlbGV0ZVN0b3JlLiBEZWxldGVTZXQgaXMgYSB0ZW1wb3Jhcnkgb2JqZWN0IHRoYXQgaXMgY3JlYXRlZCB3aGVuIG5lZWRlZC5cbiAqIC0gV2hlbiBjcmVhdGVkIGluIGEgdHJhbnNhY3Rpb24sIGl0IG11c3Qgb25seSBiZSBhY2Nlc3NlZCBhZnRlciBzb3J0aW5nLCBhbmQgbWVyZ2luZ1xuICogICAtIFRoaXMgRGVsZXRlU2V0IGlzIHNlbmQgdG8gb3RoZXIgY2xpZW50c1xuICogLSBXZSBkbyBub3QgY3JlYXRlIGEgRGVsZXRlU2V0IHdoZW4gd2Ugc2VuZCBhIHN5bmMgbWVzc2FnZS4gVGhlIERlbGV0ZVNldCBtZXNzYWdlIGlzIGNyZWF0ZWQgZGlyZWN0bHkgZnJvbSBTdHJ1Y3RTdG9yZVxuICogLSBXZSByZWFkIGEgRGVsZXRlU2V0IGFzIHBhcnQgb2YgYSBzeW5jL3VwZGF0ZSBtZXNzYWdlLiBJbiB0aGlzIGNhc2UgdGhlIERlbGV0ZVNldCBpcyBhbHJlYWR5IHNvcnRlZCBhbmQgbWVyZ2VkLlxuICovXG5jbGFzcyBEZWxldGVTZXQge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsQXJyYXk8RGVsZXRlSXRlbT4+fVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50cyA9IG5ldyBNYXAoKTtcbiAgfVxufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgc3RydWN0cyB0aGF0IHRoZSBEZWxldGVTZXQgZ2Mncy5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEdDfEl0ZW0pOnZvaWR9IGZcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzID0gKHRyYW5zYWN0aW9uLCBkcywgZikgPT5cbiAgZHMuY2xpZW50cy5mb3JFYWNoKChkZWxldGVzLCBjbGllbnRpZCkgPT4ge1xuICAgIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEdDfEl0ZW0+fSAqLyAodHJhbnNhY3Rpb24uZG9jLnN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudGlkKSk7XG4gICAgaWYgKHN0cnVjdHMgIT0gbnVsbCkge1xuICAgICAgY29uc3QgbGFzdFN0cnVjdCA9IHN0cnVjdHNbc3RydWN0cy5sZW5ndGggLSAxXTtcbiAgICAgIGNvbnN0IGNsb2NrU3RhdGUgPSBsYXN0U3RydWN0LmlkLmNsb2NrICsgbGFzdFN0cnVjdC5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMCwgZGVsID0gZGVsZXRlc1tpXTsgaSA8IGRlbGV0ZXMubGVuZ3RoICYmIGRlbC5jbG9jayA8IGNsb2NrU3RhdGU7IGRlbCA9IGRlbGV0ZXNbKytpXSkge1xuICAgICAgICBpdGVyYXRlU3RydWN0cyh0cmFuc2FjdGlvbiwgc3RydWN0cywgZGVsLmNsb2NrLCBkZWwubGVuLCBmKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8RGVsZXRlSXRlbT59IGRpc1xuICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gKiBAcmV0dXJuIHtudW1iZXJ8bnVsbH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGZpbmRJbmRleERTID0gKGRpcywgY2xvY2spID0+IHtcbiAgbGV0IGxlZnQgPSAwO1xuICBsZXQgcmlnaHQgPSBkaXMubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICBjb25zdCBtaWRpbmRleCA9IG1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKTtcbiAgICBjb25zdCBtaWQgPSBkaXNbbWlkaW5kZXhdO1xuICAgIGNvbnN0IG1pZGNsb2NrID0gbWlkLmNsb2NrO1xuICAgIGlmIChtaWRjbG9jayA8PSBjbG9jaykge1xuICAgICAgaWYgKGNsb2NrIDwgbWlkY2xvY2sgKyBtaWQubGVuKSB7XG4gICAgICAgIHJldHVybiBtaWRpbmRleFxuICAgICAgfVxuICAgICAgbGVmdCA9IG1pZGluZGV4ICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmlnaHQgPSBtaWRpbmRleCAtIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICogQHBhcmFtIHtJRH0gaWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBpc0RlbGV0ZWQgPSAoZHMsIGlkKSA9PiB7XG4gIGNvbnN0IGRpcyA9IGRzLmNsaWVudHMuZ2V0KGlkLmNsaWVudCk7XG4gIHJldHVybiBkaXMgIT09IHVuZGVmaW5lZCAmJiBmaW5kSW5kZXhEUyhkaXMsIGlkLmNsb2NrKSAhPT0gbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHNvcnRBbmRNZXJnZURlbGV0ZVNldCA9IGRzID0+IHtcbiAgZHMuY2xpZW50cy5mb3JFYWNoKGRlbHMgPT4ge1xuICAgIGRlbHMuc29ydCgoYSwgYikgPT4gYS5jbG9jayAtIGIuY2xvY2spO1xuICAgIC8vIG1lcmdlIGl0ZW1zIHdpdGhvdXQgZmlsdGVyaW5nIG9yIHNwbGljaW5nIHRoZSBhcnJheVxuICAgIC8vIGkgaXMgdGhlIGN1cnJlbnQgcG9pbnRlclxuICAgIC8vIGogcmVmZXJzIHRvIHRoZSBjdXJyZW50IGluc2VydCBwb3NpdGlvbiBmb3IgdGhlIHBvaW50ZWQgaXRlbVxuICAgIC8vIHRyeSB0byBtZXJnZSBkZWxzW2ldIGludG8gZGVsc1tqLTFdIG9yIHNldCBkZWxzW2pdPWRlbHNbaV1cbiAgICBsZXQgaSwgajtcbiAgICBmb3IgKGkgPSAxLCBqID0gMTsgaSA8IGRlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxlZnQgPSBkZWxzW2ogLSAxXTtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gZGVsc1tpXTtcbiAgICAgIGlmIChsZWZ0LmNsb2NrICsgbGVmdC5sZW4gPj0gcmlnaHQuY2xvY2spIHtcbiAgICAgICAgbGVmdC5sZW4gPSBtYXRoLm1heChsZWZ0LmxlbiwgcmlnaHQuY2xvY2sgKyByaWdodC5sZW4gLSBsZWZ0LmNsb2NrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChqIDwgaSkge1xuICAgICAgICAgIGRlbHNbal0gPSByaWdodDtcbiAgICAgICAgfVxuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfVxuICAgIGRlbHMubGVuZ3RoID0gajtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8RGVsZXRlU2V0Pn0gZHNzXG4gKiBAcmV0dXJuIHtEZWxldGVTZXR9IEEgZnJlc2ggRGVsZXRlU2V0XG4gKi9cbmNvbnN0IG1lcmdlRGVsZXRlU2V0cyA9IGRzcyA9PiB7XG4gIGNvbnN0IG1lcmdlZCA9IG5ldyBEZWxldGVTZXQoKTtcbiAgZm9yIChsZXQgZHNzSSA9IDA7IGRzc0kgPCBkc3MubGVuZ3RoOyBkc3NJKyspIHtcbiAgICBkc3NbZHNzSV0uY2xpZW50cy5mb3JFYWNoKChkZWxzTGVmdCwgY2xpZW50KSA9PiB7XG4gICAgICBpZiAoIW1lcmdlZC5jbGllbnRzLmhhcyhjbGllbnQpKSB7XG4gICAgICAgIC8vIFdyaXRlIGFsbCBtaXNzaW5nIGtleXMgZnJvbSBjdXJyZW50IGRzIGFuZCBhbGwgZm9sbG93aW5nLlxuICAgICAgICAvLyBJZiBtZXJnZWQgYWxyZWFkeSBjb250YWlucyBgY2xpZW50YCBjdXJyZW50IGRzIGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8RGVsZXRlSXRlbT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBkZWxzID0gZGVsc0xlZnQuc2xpY2UoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGRzc0kgKyAxOyBpIDwgZHNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJyYXkuYXBwZW5kVG8oZGVscywgZHNzW2ldLmNsaWVudHMuZ2V0KGNsaWVudCkgfHwgW10pO1xuICAgICAgICB9XG4gICAgICAgIG1lcmdlZC5jbGllbnRzLnNldChjbGllbnQsIGRlbHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNvcnRBbmRNZXJnZURlbGV0ZVNldChtZXJnZWQpO1xuICByZXR1cm4gbWVyZ2VkXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFxuICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBhZGRUb0RlbGV0ZVNldCA9IChkcywgY2xpZW50LCBjbG9jaywgbGVuZ3RoKSA9PiB7XG4gIG1hcC5zZXRJZlVuZGVmaW5lZChkcy5jbGllbnRzLCBjbGllbnQsICgpID0+IC8qKiBAdHlwZSB7QXJyYXk8RGVsZXRlSXRlbT59ICovIChbXSkpLnB1c2gobmV3IERlbGV0ZUl0ZW0oY2xvY2ssIGxlbmd0aCkpO1xufTtcblxuY29uc3QgY3JlYXRlRGVsZXRlU2V0ID0gKCkgPT4gbmV3IERlbGV0ZVNldCgpO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHNzXG4gKiBAcmV0dXJuIHtEZWxldGVTZXR9IE1lcmdlZCBhbmQgc29ydGVkIERlbGV0ZVNldFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlRGVsZXRlU2V0RnJvbVN0cnVjdFN0b3JlID0gc3MgPT4ge1xuICBjb25zdCBkcyA9IGNyZWF0ZURlbGV0ZVNldCgpO1xuICBzcy5jbGllbnRzLmZvckVhY2goKHN0cnVjdHMsIGNsaWVudCkgPT4ge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxEZWxldGVJdGVtPn1cbiAgICAgKi9cbiAgICBjb25zdCBkc2l0ZW1zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJ1Y3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdHJ1Y3QgPSBzdHJ1Y3RzW2ldO1xuICAgICAgaWYgKHN0cnVjdC5kZWxldGVkKSB7XG4gICAgICAgIGNvbnN0IGNsb2NrID0gc3RydWN0LmlkLmNsb2NrO1xuICAgICAgICBsZXQgbGVuID0gc3RydWN0Lmxlbmd0aDtcbiAgICAgICAgaWYgKGkgKyAxIDwgc3RydWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKGxldCBuZXh0ID0gc3RydWN0c1tpICsgMV07IGkgKyAxIDwgc3RydWN0cy5sZW5ndGggJiYgbmV4dC5kZWxldGVkOyBuZXh0ID0gc3RydWN0c1srK2kgKyAxXSkge1xuICAgICAgICAgICAgbGVuICs9IG5leHQubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkc2l0ZW1zLnB1c2gobmV3IERlbGV0ZUl0ZW0oY2xvY2ssIGxlbikpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZHNpdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICBkcy5jbGllbnRzLnNldChjbGllbnQsIGRzaXRlbXMpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RTRW5jb2RlclYxIHwgRFNFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgd3JpdGVEZWxldGVTZXQgPSAoZW5jb2RlciwgZHMpID0+IHtcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGRzLmNsaWVudHMuc2l6ZSk7XG5cbiAgLy8gRW5zdXJlIHRoYXQgdGhlIGRlbGV0ZSBzZXQgaXMgd3JpdHRlbiBpbiBhIGRldGVybWluaXN0aWMgb3JkZXJcbiAgYXJyYXkuZnJvbShkcy5jbGllbnRzLmVudHJpZXMoKSlcbiAgICAuc29ydCgoYSwgYikgPT4gYlswXSAtIGFbMF0pXG4gICAgLmZvckVhY2goKFtjbGllbnQsIGRzaXRlbXNdKSA9PiB7XG4gICAgICBlbmNvZGVyLnJlc2V0RHNDdXJWYWwoKTtcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjbGllbnQpO1xuICAgICAgY29uc3QgbGVuID0gZHNpdGVtcy5sZW5ndGg7XG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgbGVuKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGRzaXRlbXNbaV07XG4gICAgICAgIGVuY29kZXIud3JpdGVEc0Nsb2NrKGl0ZW0uY2xvY2spO1xuICAgICAgICBlbmNvZGVyLndyaXRlRHNMZW4oaXRlbS5sZW4pO1xuICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RTRGVjb2RlclYxIHwgRFNEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0RlbGV0ZVNldH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWREZWxldGVTZXQgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgZHMgPSBuZXcgRGVsZXRlU2V0KCk7XG4gIGNvbnN0IG51bUNsaWVudHMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DbGllbnRzOyBpKyspIHtcbiAgICBkZWNvZGVyLnJlc2V0RHNDdXJWYWwoKTtcbiAgICBjb25zdCBjbGllbnQgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICBjb25zdCBudW1iZXJPZkRlbGV0ZXMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICBpZiAobnVtYmVyT2ZEZWxldGVzID4gMCkge1xuICAgICAgY29uc3QgZHNGaWVsZCA9IG1hcC5zZXRJZlVuZGVmaW5lZChkcy5jbGllbnRzLCBjbGllbnQsICgpID0+IC8qKiBAdHlwZSB7QXJyYXk8RGVsZXRlSXRlbT59ICovIChbXSkpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkRlbGV0ZXM7IGkrKykge1xuICAgICAgICBkc0ZpZWxkLnB1c2gobmV3IERlbGV0ZUl0ZW0oZGVjb2Rlci5yZWFkRHNDbG9jaygpLCBkZWNvZGVyLnJlYWREc0xlbigpKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkc1xufTtcblxuLyoqXG4gKiBAdG9kbyBZRGVjb2RlciBhbHNvIGNvbnRhaW5zIHJlZmVyZW5jZXMgdG8gU3RyaW5nIGFuZCBvdGhlciBEZWNvZGVycy4gV291bGQgbWFrZSBzZW5zZSB0byBleGNoYW5nZSBZRGVjb2Rlci50b1VpbnQ4QXJyYXkgZm9yIFlEZWNvZGVyLkRzVG9VaW50OEFycmF5KCkuLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtEU0RlY29kZXJWMSB8IERTRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl8bnVsbH0gUmV0dXJucyBhIHYyIHVwZGF0ZSBjb250YWluaW5nIGFsbCBkZWxldGVzIHRoYXQgY291bGRuJ3QgYmUgYXBwbGllZCB5ZXQ7IG9yIG51bGwgaWYgYWxsIGRlbGV0ZXMgd2VyZSBhcHBsaWVkIHN1Y2Nlc3NmdWxseS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRBbmRBcHBseURlbGV0ZVNldCA9IChkZWNvZGVyLCB0cmFuc2FjdGlvbiwgc3RvcmUpID0+IHtcbiAgY29uc3QgdW5hcHBsaWVkRFMgPSBuZXcgRGVsZXRlU2V0KCk7XG4gIGNvbnN0IG51bUNsaWVudHMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DbGllbnRzOyBpKyspIHtcbiAgICBkZWNvZGVyLnJlc2V0RHNDdXJWYWwoKTtcbiAgICBjb25zdCBjbGllbnQgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICBjb25zdCBudW1iZXJPZkRlbGV0ZXMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICBjb25zdCBzdHJ1Y3RzID0gc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSB8fCBbXTtcbiAgICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKHN0b3JlLCBjbGllbnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZEZWxldGVzOyBpKyspIHtcbiAgICAgIGNvbnN0IGNsb2NrID0gZGVjb2Rlci5yZWFkRHNDbG9jaygpO1xuICAgICAgY29uc3QgY2xvY2tFbmQgPSBjbG9jayArIGRlY29kZXIucmVhZERzTGVuKCk7XG4gICAgICBpZiAoY2xvY2sgPCBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUgPCBjbG9ja0VuZCkge1xuICAgICAgICAgIGFkZFRvRGVsZXRlU2V0KHVuYXBwbGllZERTLCBjbGllbnQsIHN0YXRlLCBjbG9ja0VuZCAtIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jayk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBjYW4gaWdub3JlIHRoZSBjYXNlIG9mIEdDIGFuZCBEZWxldGUgc3RydWN0cywgYmVjYXVzZSB3ZSBhcmUgZ29pbmcgdG8gc2tpcCB0aGVtXG4gICAgICAgICAqIEB0eXBlIHtJdGVtfVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBsZXQgc3RydWN0ID0gc3RydWN0c1tpbmRleF07XG4gICAgICAgIC8vIHNwbGl0IHRoZSBmaXJzdCBpdGVtIGlmIG5lY2Vzc2FyeVxuICAgICAgICBpZiAoIXN0cnVjdC5kZWxldGVkICYmIHN0cnVjdC5pZC5jbG9jayA8IGNsb2NrKSB7XG4gICAgICAgICAgc3RydWN0cy5zcGxpY2UoaW5kZXggKyAxLCAwLCBzcGxpdEl0ZW0odHJhbnNhY3Rpb24sIHN0cnVjdCwgY2xvY2sgLSBzdHJ1Y3QuaWQuY2xvY2spKTtcbiAgICAgICAgICBpbmRleCsrOyAvLyBpbmNyZWFzZSB3ZSBub3cgd2FudCB0byB1c2UgdGhlIG5leHQgc3RydWN0XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgc3RydWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgc3RydWN0ID0gc3RydWN0c1tpbmRleCsrXTtcbiAgICAgICAgICBpZiAoc3RydWN0LmlkLmNsb2NrIDwgY2xvY2tFbmQpIHtcbiAgICAgICAgICAgIGlmICghc3RydWN0LmRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGNsb2NrRW5kIDwgc3RydWN0LmlkLmNsb2NrICsgc3RydWN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHN0cnVjdHMuc3BsaWNlKGluZGV4LCAwLCBzcGxpdEl0ZW0odHJhbnNhY3Rpb24sIHN0cnVjdCwgY2xvY2tFbmQgLSBzdHJ1Y3QuaWQuY2xvY2spKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdHJ1Y3QuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZFRvRGVsZXRlU2V0KHVuYXBwbGllZERTLCBjbGllbnQsIGNsb2NrLCBjbG9ja0VuZCAtIGNsb2NrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHVuYXBwbGllZERTLmNsaWVudHMuc2l6ZSA+IDApIHtcbiAgICBjb25zdCBkcyA9IG5ldyBVcGRhdGVFbmNvZGVyVjIoKTtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZHMucmVzdEVuY29kZXIsIDApOyAvLyBlbmNvZGUgMCBzdHJ1Y3RzXG4gICAgd3JpdGVEZWxldGVTZXQoZHMsIHVuYXBwbGllZERTKTtcbiAgICByZXR1cm4gZHMudG9VaW50OEFycmF5KClcbiAgfVxuICByZXR1cm4gbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHMxXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHMyXG4gKi9cbmNvbnN0IGVxdWFsRGVsZXRlU2V0cyA9IChkczEsIGRzMikgPT4ge1xuICBpZiAoZHMxLmNsaWVudHMuc2l6ZSAhPT0gZHMyLmNsaWVudHMuc2l6ZSkgcmV0dXJuIGZhbHNlXG4gIGZvciAoY29uc3QgW2NsaWVudCwgZGVsZXRlSXRlbXMxXSBvZiBkczEuY2xpZW50cy5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCBkZWxldGVJdGVtczIgPSAvKiogQHR5cGUge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWxzLmpzJykuRGVsZXRlSXRlbT59ICovIChkczIuY2xpZW50cy5nZXQoY2xpZW50KSk7XG4gICAgaWYgKGRlbGV0ZUl0ZW1zMiA9PT0gdW5kZWZpbmVkIHx8IGRlbGV0ZUl0ZW1zMS5sZW5ndGggIT09IGRlbGV0ZUl0ZW1zMi5sZW5ndGgpIHJldHVybiBmYWxzZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsZXRlSXRlbXMxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkaTEgPSBkZWxldGVJdGVtczFbaV07XG4gICAgICBjb25zdCBkaTIgPSBkZWxldGVJdGVtczJbaV07XG4gICAgICBpZiAoZGkxLmNsb2NrICE9PSBkaTIuY2xvY2sgfHwgZGkxLmxlbiAhPT0gZGkyLmxlbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5cbi8qKlxuICogQG1vZHVsZSBZXG4gKi9cblxuXG5jb25zdCBnZW5lcmF0ZU5ld0NsaWVudElkID0gcmFuZG9tLnVpbnQzMjtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEb2NPcHRzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtEb2NPcHRzLmdjPXRydWVdIERpc2FibGUgZ2FyYmFnZSBjb2xsZWN0aW9uIChkZWZhdWx0OiBnYz10cnVlKVxuICogQHByb3BlcnR5IHtmdW5jdGlvbihJdGVtKTpib29sZWFufSBbRG9jT3B0cy5nY0ZpbHRlcl0gV2lsbCBiZSBjYWxsZWQgYmVmb3JlIGFuIEl0ZW0gaXMgZ2FyYmFnZSBjb2xsZWN0ZWQuIFJldHVybiBmYWxzZSB0byBrZWVwIHRoZSBJdGVtLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtEb2NPcHRzLmd1aWRdIERlZmluZSBhIGdsb2JhbGx5IHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGRvY3VtZW50XG4gKiBAcHJvcGVydHkge3N0cmluZyB8IG51bGx9IFtEb2NPcHRzLmNvbGxlY3Rpb25pZF0gQXNzb2NpYXRlIHRoaXMgZG9jdW1lbnQgd2l0aCBhIGNvbGxlY3Rpb24uIFRoaXMgb25seSBwbGF5cyBhIHJvbGUgaWYgeW91ciBwcm92aWRlciBoYXMgYSBjb25jZXB0IG9mIGNvbGxlY3Rpb24uXG4gKiBAcHJvcGVydHkge2FueX0gW0RvY09wdHMubWV0YV0gQW55IGtpbmQgb2YgbWV0YSBpbmZvcm1hdGlvbiB5b3Ugd2FudCB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIGRvY3VtZW50LiBJZiB0aGlzIGlzIGEgc3ViZG9jdW1lbnQsIHJlbW90ZSBwZWVycyB3aWxsIHN0b3JlIHRoZSBtZXRhIGluZm9ybWF0aW9uIGFzIHdlbGwuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtEb2NPcHRzLmF1dG9Mb2FkXSBJZiBhIHN1YmRvY3VtZW50LCBhdXRvbWF0aWNhbGx5IGxvYWQgZG9jdW1lbnQuIElmIHRoaXMgaXMgYSBzdWJkb2N1bWVudCwgcmVtb3RlIHBlZXJzIHdpbGwgbG9hZCB0aGUgZG9jdW1lbnQgYXMgd2VsbCBhdXRvbWF0aWNhbGx5LlxuICogQHByb3BlcnR5IHtib29sZWFufSBbRG9jT3B0cy5zaG91bGRMb2FkXSBXaGV0aGVyIHRoZSBkb2N1bWVudCBzaG91bGQgYmUgc3luY2VkIGJ5IHRoZSBwcm92aWRlciBub3cuIFRoaXMgaXMgdG9nZ2xlZCB0byB0cnVlIHdoZW4geW91IGNhbGwgeWRvYy5sb2FkKClcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERvY0V2ZW50c1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihEb2MpOnZvaWR9IERvY0V2ZW50cy5kZXN0cm95XG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKERvYyk6dm9pZH0gRG9jRXZlbnRzLmxvYWRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oYm9vbGVhbiwgRG9jKTp2b2lkfSBEb2NFdmVudHMuc3luY1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihVaW50OEFycmF5LCBhbnksIERvYywgVHJhbnNhY3Rpb24pOnZvaWR9IERvY0V2ZW50cy51cGRhdGVcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oVWludDhBcnJheSwgYW55LCBEb2MsIFRyYW5zYWN0aW9uKTp2b2lkfSBEb2NFdmVudHMudXBkYXRlVjJcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oRG9jKTp2b2lkfSBEb2NFdmVudHMuYmVmb3JlQWxsVHJhbnNhY3Rpb25zXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKFRyYW5zYWN0aW9uLCBEb2MpOnZvaWR9IERvY0V2ZW50cy5iZWZvcmVUcmFuc2FjdGlvblxuICogQHByb3BlcnR5IHtmdW5jdGlvbihUcmFuc2FjdGlvbiwgRG9jKTp2b2lkfSBEb2NFdmVudHMuYmVmb3JlT2JzZXJ2ZXJDYWxsc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihUcmFuc2FjdGlvbiwgRG9jKTp2b2lkfSBEb2NFdmVudHMuYWZ0ZXJUcmFuc2FjdGlvblxuICogQHByb3BlcnR5IHtmdW5jdGlvbihUcmFuc2FjdGlvbiwgRG9jKTp2b2lkfSBEb2NFdmVudHMuYWZ0ZXJUcmFuc2FjdGlvbkNsZWFudXBcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oRG9jLCBBcnJheTxUcmFuc2FjdGlvbj4pOnZvaWR9IERvY0V2ZW50cy5hZnRlckFsbFRyYW5zYWN0aW9uc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbih7IGxvYWRlZDogU2V0PERvYz4sIGFkZGVkOiBTZXQ8RG9jPiwgcmVtb3ZlZDogU2V0PERvYz4gfSwgRG9jLCBUcmFuc2FjdGlvbik6dm9pZH0gRG9jRXZlbnRzLnN1YmRvY3NcbiAqL1xuXG4vKipcbiAqIEEgWWpzIGluc3RhbmNlIGhhbmRsZXMgdGhlIHN0YXRlIG9mIHNoYXJlZCBkYXRhLlxuICogQGV4dGVuZHMgT2JzZXJ2YWJsZVYyPERvY0V2ZW50cz5cbiAqL1xuY2xhc3MgRG9jIGV4dGVuZHMgT2JzZXJ2YWJsZVYyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jT3B0c30gb3B0cyBjb25maWd1cmF0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeyBndWlkID0gcmFuZG9tLnV1aWR2NCgpLCBjb2xsZWN0aW9uaWQgPSBudWxsLCBnYyA9IHRydWUsIGdjRmlsdGVyID0gKCkgPT4gdHJ1ZSwgbWV0YSA9IG51bGwsIGF1dG9Mb2FkID0gZmFsc2UsIHNob3VsZExvYWQgPSB0cnVlIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5nYyA9IGdjO1xuICAgIHRoaXMuZ2NGaWx0ZXIgPSBnY0ZpbHRlcjtcbiAgICB0aGlzLmNsaWVudElEID0gZ2VuZXJhdGVOZXdDbGllbnRJZCgpO1xuICAgIHRoaXMuZ3VpZCA9IGd1aWQ7XG4gICAgdGhpcy5jb2xsZWN0aW9uaWQgPSBjb2xsZWN0aW9uaWQ7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsIEFic3RyYWN0VHlwZTxZRXZlbnQ8YW55Pj4+fVxuICAgICAqL1xuICAgIHRoaXMuc2hhcmUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5zdG9yZSA9IG5ldyBTdHJ1Y3RTdG9yZSgpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtUcmFuc2FjdGlvbiB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fdHJhbnNhY3Rpb24gPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxUcmFuc2FjdGlvbj59XG4gICAgICovXG4gICAgdGhpcy5fdHJhbnNhY3Rpb25DbGVhbnVwcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtTZXQ8RG9jPn1cbiAgICAgKi9cbiAgICB0aGlzLnN1YmRvY3MgPSBuZXcgU2V0KCk7XG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBkb2N1bWVudCBpcyBhIHN1YmRvY3VtZW50IC0gYSBkb2N1bWVudCBpbnRlZ3JhdGVkIGludG8gYW5vdGhlciBkb2N1bWVudCAtIHRoZW4gX2l0ZW0gaXMgZGVmaW5lZC5cbiAgICAgKiBAdHlwZSB7SXRlbT99XG4gICAgICovXG4gICAgdGhpcy5faXRlbSA9IG51bGw7XG4gICAgdGhpcy5zaG91bGRMb2FkID0gc2hvdWxkTG9hZDtcbiAgICB0aGlzLmF1dG9Mb2FkID0gYXV0b0xvYWQ7XG4gICAgdGhpcy5tZXRhID0gbWV0YTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHNldCB0byB0cnVlIHdoZW4gdGhlIHBlcnNpc3RlbmNlIHByb3ZpZGVyIGxvYWRlZCB0aGUgZG9jdW1lbnQgZnJvbSB0aGUgZGF0YWJhc2Ugb3Igd2hlbiB0aGUgYHN5bmNgIGV2ZW50IGZpcmVzLlxuICAgICAqIE5vdGUgdGhhdCBub3QgYWxsIHByb3ZpZGVycyBpbXBsZW1lbnQgdGhpcyBmZWF0dXJlLiBQcm92aWRlciBhdXRob3JzIGFyZSBlbmNvdXJhZ2VkIHRvIGZpcmUgdGhlIGBsb2FkYCBldmVudCB3aGVuIHRoZSBkb2MgY29udGVudCBpcyBsb2FkZWQgZnJvbSB0aGUgZGF0YWJhc2UuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzTG9hZGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBzZXQgdG8gdHJ1ZSB3aGVuIHRoZSBjb25uZWN0aW9uIHByb3ZpZGVyIGhhcyBzdWNjZXNzZnVsbHkgc3luY2VkIHdpdGggYSBiYWNrZW5kLlxuICAgICAqIE5vdGUgdGhhdCB3aGVuIHVzaW5nIHBlZXItdG8tcGVlciBwcm92aWRlcnMgdGhpcyBldmVudCBtYXkgbm90IHByb3ZpZGUgdmVyeSB1c2VmdWwuXG4gICAgICogQWxzbyBub3RlIHRoYXQgbm90IGFsbCBwcm92aWRlcnMgaW1wbGVtZW50IHRoaXMgZmVhdHVyZS4gUHJvdmlkZXIgYXV0aG9ycyBhcmUgZW5jb3VyYWdlZCB0byBmaXJlXG4gICAgICogdGhlIGBzeW5jYCBldmVudCB3aGVuIHRoZSBkb2MgaGFzIGJlZW4gc3luY2VkICh3aXRoIGB0cnVlYCBhcyBhIHBhcmFtZXRlcikgb3IgaWYgY29ubmVjdGlvbiBpc1xuICAgICAqIGxvc3QgKHdpdGggZmFsc2UgYXMgYSBwYXJhbWV0ZXIpLlxuICAgICAqL1xuICAgIHRoaXMuaXNTeW5jZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzRGVzdHJveWVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogUHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgdGhlIGRvY3VtZW50IGhhcyBiZWVuIGxvYWRlZCBmcm9tIGEgcGVyc2lzdGVuY2UgcHJvdmlkZXIuXG4gICAgICovXG4gICAgdGhpcy53aGVuTG9hZGVkID0gcHJvbWlzZS5jcmVhdGUocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLm9uKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IHByb3ZpZGVTeW5jZWRQcm9taXNlID0gKCkgPT4gcHJvbWlzZS5jcmVhdGUocmVzb2x2ZSA9PiB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTeW5jZWRcbiAgICAgICAqL1xuICAgICAgY29uc3QgZXZlbnRIYW5kbGVyID0gKGlzU3luY2VkKSA9PiB7XG4gICAgICAgIGlmIChpc1N5bmNlZCA9PT0gdW5kZWZpbmVkIHx8IGlzU3luY2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5vZmYoJ3N5bmMnLCBldmVudEhhbmRsZXIpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMub24oJ3N5bmMnLCBldmVudEhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHRoaXMub24oJ3N5bmMnLCBpc1N5bmNlZCA9PiB7XG4gICAgICBpZiAoaXNTeW5jZWQgPT09IGZhbHNlICYmIHRoaXMuaXNTeW5jZWQpIHtcbiAgICAgICAgdGhpcy53aGVuU3luY2VkID0gcHJvdmlkZVN5bmNlZFByb21pc2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNTeW5jZWQgPSBpc1N5bmNlZCA9PT0gdW5kZWZpbmVkIHx8IGlzU3luY2VkID09PSB0cnVlO1xuICAgICAgaWYgKHRoaXMuaXNTeW5jZWQgJiYgIXRoaXMuaXNMb2FkZWQpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdsb2FkJywgW3RoaXNdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSB0aGUgZG9jdW1lbnQgaGFzIGJlZW4gc3luY2VkIHdpdGggYSBiYWNrZW5kLlxuICAgICAqIFRoaXMgcHJvbWlzZSBpcyByZWNyZWF0ZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBsb3N0LlxuICAgICAqIE5vdGUgdGhlIGRvY3VtZW50YXRpb24gYWJvdXQgdGhlIGBpc1N5bmNlZGAgcHJvcGVydHkuXG4gICAgICovXG4gICAgdGhpcy53aGVuU3luY2VkID0gcHJvdmlkZVN5bmNlZFByb21pc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RpZnkgdGhlIHBhcmVudCBkb2N1bWVudCB0aGF0IHlvdSByZXF1ZXN0IHRvIGxvYWQgZGF0YSBpbnRvIHRoaXMgc3ViZG9jdW1lbnQgKGlmIGl0IGlzIGEgc3ViZG9jdW1lbnQpLlxuICAgKlxuICAgKiBgbG9hZCgpYCBtaWdodCBiZSB1c2VkIGluIHRoZSBmdXR1cmUgdG8gcmVxdWVzdCBhbnkgcHJvdmlkZXIgdG8gbG9hZCB0aGUgbW9zdCBjdXJyZW50IGRhdGEuXG4gICAqXG4gICAqIEl0IGlzIHNhZmUgdG8gY2FsbCBgbG9hZCgpYCBtdWx0aXBsZSB0aW1lcy5cbiAgICovXG4gIGxvYWQgKCkge1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtO1xuICAgIGlmIChpdGVtICE9PSBudWxsICYmICF0aGlzLnNob3VsZExvYWQpIHtcbiAgICAgIHRyYW5zYWN0KC8qKiBAdHlwZSB7YW55fSAqLyAoaXRlbS5wYXJlbnQpLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzTG9hZGVkLmFkZCh0aGlzKTtcbiAgICAgIH0sIG51bGwsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLnNob3VsZExvYWQgPSB0cnVlO1xuICB9XG5cbiAgZ2V0U3ViZG9jcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ViZG9jc1xuICB9XG5cbiAgZ2V0U3ViZG9jR3VpZHMgKCkge1xuICAgIHJldHVybiBuZXcgU2V0KGFycmF5LmZyb20odGhpcy5zdWJkb2NzKS5tYXAoZG9jID0+IGRvYy5ndWlkKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRoYXQgaGFwcGVuIGluc2lkZSBvZiBhIHRyYW5zYWN0aW9uIGFyZSBidW5kbGVkLiBUaGlzIG1lYW5zIHRoYXRcbiAgICogdGhlIG9ic2VydmVyIGZpcmVzIF9hZnRlcl8gdGhlIHRyYW5zYWN0aW9uIGlzIGZpbmlzaGVkIGFuZCB0aGF0IGFsbCBjaGFuZ2VzXG4gICAqIHRoYXQgaGFwcGVuZWQgaW5zaWRlIG9mIHRoZSB0cmFuc2FjdGlvbiBhcmUgc2VudCBhcyBvbmUgbWVzc2FnZSB0byB0aGVcbiAgICogb3RoZXIgcGVlcnMuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVHJhbnNhY3Rpb24pOlR9IGYgVGhlIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGV4ZWN1dGVkIGFzIGEgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHthbnl9IFtvcmlnaW5dIE9yaWdpbiBvZiB3aG8gc3RhcnRlZCB0aGUgdHJhbnNhY3Rpb24uIFdpbGwgYmUgc3RvcmVkIG9uIHRyYW5zYWN0aW9uLm9yaWdpblxuICAgKiBAcmV0dXJuIFRcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdHJhbnNhY3QgKGYsIG9yaWdpbiA9IG51bGwpIHtcbiAgICByZXR1cm4gdHJhbnNhY3QodGhpcywgZiwgb3JpZ2luKVxuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSBhIHNoYXJlZCBkYXRhIHR5cGUuXG4gICAqXG4gICAqIE11bHRpcGxlIGNhbGxzIG9mIGB5ZG9jLmdldChuYW1lLCBUeXBlQ29uc3RydWN0b3IpYCB5aWVsZCB0aGUgc2FtZSByZXN1bHRcbiAgICogYW5kIGRvIG5vdCBvdmVyd3JpdGUgZWFjaCBvdGhlci4gSS5lLlxuICAgKiBgeWRvYy5nZXQobmFtZSwgWS5BcnJheSkgPT09IHlkb2MuZ2V0KG5hbWUsIFkuQXJyYXkpYFxuICAgKlxuICAgKiBBZnRlciB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIHRoZSB0eXBlIGlzIGFsc28gYXZhaWxhYmxlIG9uIGB5ZG9jLnNoYXJlLmdldChuYW1lKWAuXG4gICAqXG4gICAqICpCZXN0IFByYWN0aWNlczoqXG4gICAqIERlZmluZSBhbGwgdHlwZXMgcmlnaHQgYWZ0ZXIgdGhlIFkuRG9jIGluc3RhbmNlIGlzIGNyZWF0ZWQgYW5kIHN0b3JlIHRoZW0gaW4gYSBzZXBhcmF0ZSBvYmplY3QuXG4gICAqIEFsc28gdXNlIHRoZSB0eXBlZCBtZXRob2RzIGBnZXRUZXh0KG5hbWUpYCwgYGdldEFycmF5KG5hbWUpYCwgLi5cbiAgICpcbiAgICogQHRlbXBsYXRlIHt0eXBlb2YgQWJzdHJhY3RUeXBlPGFueT59IFR5cGVcbiAgICogQGV4YW1wbGVcbiAgICogICBjb25zdCB5ZG9jID0gbmV3IFkuRG9jKC4uKVxuICAgKiAgIGNvbnN0IGFwcFN0YXRlID0ge1xuICAgKiAgICAgZG9jdW1lbnQ6IHlkb2MuZ2V0VGV4dCgnZG9jdW1lbnQnKVxuICAgKiAgICAgY29tbWVudHM6IHlkb2MuZ2V0QXJyYXkoJ2NvbW1lbnRzJylcbiAgICogICB9XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7VHlwZX0gVHlwZUNvbnN0cnVjdG9yIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgdHlwZSBkZWZpbml0aW9uLiBFLmcuIFkuVGV4dCwgWS5BcnJheSwgWS5NYXAsIC4uLlxuICAgKiBAcmV0dXJuIHtJbnN0YW5jZVR5cGU8VHlwZT59IFRoZSBjcmVhdGVkIHR5cGUuIENvbnN0cnVjdGVkIHdpdGggVHlwZUNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldCAobmFtZSwgVHlwZUNvbnN0cnVjdG9yID0gLyoqIEB0eXBlIHthbnl9ICovIChBYnN0cmFjdFR5cGUpKSB7XG4gICAgY29uc3QgdHlwZSA9IG1hcC5zZXRJZlVuZGVmaW5lZCh0aGlzLnNoYXJlLCBuYW1lLCAoKSA9PiB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCB0ID0gbmV3IFR5cGVDb25zdHJ1Y3RvcigpO1xuICAgICAgdC5faW50ZWdyYXRlKHRoaXMsIG51bGwpO1xuICAgICAgcmV0dXJuIHRcbiAgICB9KTtcbiAgICBjb25zdCBDb25zdHIgPSB0eXBlLmNvbnN0cnVjdG9yO1xuICAgIGlmIChUeXBlQ29uc3RydWN0b3IgIT09IEFic3RyYWN0VHlwZSAmJiBDb25zdHIgIT09IFR5cGVDb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKENvbnN0ciA9PT0gQWJzdHJhY3RUeXBlKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgdCA9IG5ldyBUeXBlQ29uc3RydWN0b3IoKTtcbiAgICAgICAgdC5fbWFwID0gdHlwZS5fbWFwO1xuICAgICAgICB0eXBlLl9tYXAuZm9yRWFjaCgvKiogQHBhcmFtIHtJdGVtP30gbiAqLyBuID0+IHtcbiAgICAgICAgICBmb3IgKDsgbiAhPT0gbnVsbDsgbiA9IG4ubGVmdCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgbi5wYXJlbnQgPSB0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHQuX3N0YXJ0ID0gdHlwZS5fc3RhcnQ7XG4gICAgICAgIGZvciAobGV0IG4gPSB0Ll9zdGFydDsgbiAhPT0gbnVsbDsgbiA9IG4ucmlnaHQpIHtcbiAgICAgICAgICBuLnBhcmVudCA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgdC5fbGVuZ3RoID0gdHlwZS5fbGVuZ3RoO1xuICAgICAgICB0aGlzLnNoYXJlLnNldChuYW1lLCB0KTtcbiAgICAgICAgdC5faW50ZWdyYXRlKHRoaXMsIG51bGwpO1xuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtJbnN0YW5jZVR5cGU8VHlwZT59ICovICh0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUeXBlIHdpdGggdGhlIG5hbWUgJHtuYW1lfSBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgd2l0aCBhIGRpZmZlcmVudCBjb25zdHJ1Y3RvcmApXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUge0luc3RhbmNlVHlwZTxUeXBlPn0gKi8gKHR5cGUpXG4gIH1cblxuICAvKipcbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXVxuICAgKiBAcmV0dXJuIHtZQXJyYXk8VD59XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEFycmF5IChuYW1lID0gJycpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtZQXJyYXk8VD59ICovICh0aGlzLmdldChuYW1lLCBZQXJyYXkpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV1cbiAgICogQHJldHVybiB7WVRleHR9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldFRleHQgKG5hbWUgPSAnJykge1xuICAgIHJldHVybiB0aGlzLmdldChuYW1lLCBZVGV4dClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGVtcGxhdGUgVFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gICAqIEByZXR1cm4ge1lNYXA8VD59XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldE1hcCAobmFtZSA9ICcnKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7WU1hcDxUPn0gKi8gKHRoaXMuZ2V0KG5hbWUsIFlNYXApKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV1cbiAgICogQHJldHVybiB7WVhtbEVsZW1lbnR9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldFhtbEVsZW1lbnQgKG5hbWUgPSAnJykge1xuICAgIHJldHVybiAvKiogQHR5cGUge1lYbWxFbGVtZW50PHtba2V5OnN0cmluZ106c3RyaW5nfT59ICovICh0aGlzLmdldChuYW1lLCBZWG1sRWxlbWVudCkpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXVxuICAgKiBAcmV0dXJuIHtZWG1sRnJhZ21lbnR9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldFhtbEZyYWdtZW50IChuYW1lID0gJycpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQobmFtZSwgWVhtbEZyYWdtZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBlbnRpcmUgZG9jdW1lbnQgaW50byBhIGpzIG9iamVjdCwgcmVjdXJzaXZlbHkgdHJhdmVyc2luZyBlYWNoIHlqcyB0eXBlXG4gICAqIERvZXNuJ3QgbG9nIHR5cGVzIHRoYXQgaGF2ZSBub3QgYmVlbiBkZWZpbmVkICh1c2luZyB5ZG9jLmdldFR5cGUoLi4pKS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZCBhbmQgcmF0aGVyIGNhbGwgdG9KU09OIGRpcmVjdGx5IG9uIHRoZSBzaGFyZWQgdHlwZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsIGFueT59XG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBhbnk+fVxuICAgICAqL1xuICAgIGNvbnN0IGRvYyA9IHt9O1xuXG4gICAgdGhpcy5zaGFyZS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBkb2Nba2V5XSA9IHZhbHVlLnRvSlNPTigpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGRvY1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgYGRlc3Ryb3lgIGV2ZW50IGFuZCB1bnJlZ2lzdGVyIGFsbCBldmVudCBoYW5kbGVycy5cbiAgICovXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIGFycmF5LmZyb20odGhpcy5zdWJkb2NzKS5mb3JFYWNoKHN1YmRvYyA9PiBzdWJkb2MuZGVzdHJveSgpKTtcbiAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbTtcbiAgICBpZiAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5faXRlbSA9IG51bGw7XG4gICAgICBjb25zdCBjb250ZW50ID0gLyoqIEB0eXBlIHtDb250ZW50RG9jfSAqLyAoaXRlbS5jb250ZW50KTtcbiAgICAgIGNvbnRlbnQuZG9jID0gbmV3IERvYyh7IGd1aWQ6IHRoaXMuZ3VpZCwgLi4uY29udGVudC5vcHRzLCBzaG91bGRMb2FkOiBmYWxzZSB9KTtcbiAgICAgIGNvbnRlbnQuZG9jLl9pdGVtID0gaXRlbTtcbiAgICAgIHRyYW5zYWN0KC8qKiBAdHlwZSB7YW55fSAqLyAoaXRlbSkucGFyZW50LmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBkb2MgPSBjb250ZW50LmRvYztcbiAgICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzQWRkZWQuYWRkKGRvYyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc1JlbW92ZWQuYWRkKHRoaXMpO1xuICAgICAgfSwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3llZCcsIFt0cnVlXSk7IC8vIERFUFJFQ0FURUQhXG4gICAgdGhpcy5lbWl0KCdkZXN0cm95JywgW3RoaXNdKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbn1cblxuY2xhc3MgRFNEZWNvZGVyVjEge1xuICAvKipcbiAgICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZGVjb2Rlcikge1xuICAgIHRoaXMucmVzdERlY29kZXIgPSBkZWNvZGVyO1xuICB9XG5cbiAgcmVzZXREc0N1clZhbCAoKSB7XG4gICAgLy8gbm9wXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZERzQ2xvY2sgKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHJlYWREc0xlbiAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpXG4gIH1cbn1cblxuY2xhc3MgVXBkYXRlRGVjb2RlclYxIGV4dGVuZHMgRFNEZWNvZGVyVjEge1xuICAvKipcbiAgICogQHJldHVybiB7SUR9XG4gICAqL1xuICByZWFkTGVmdElEICgpIHtcbiAgICByZXR1cm4gY3JlYXRlSUQoZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlciksIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0lEfVxuICAgKi9cbiAgcmVhZFJpZ2h0SUQgKCkge1xuICAgIHJldHVybiBjcmVhdGVJRChkZWNvZGluZy5yZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKSwgZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcikpXG4gIH1cblxuICAvKipcbiAgICogUmVhZCB0aGUgbmV4dCBjbGllbnQgaWQuXG4gICAqIFVzZSB0aGlzIGluIGZhdm9yIG9mIHJlYWRJRCB3aGVuZXZlciBwb3NzaWJsZSB0byByZWR1Y2UgdGhlIG51bWJlciBvZiBvYmplY3RzIGNyZWF0ZWQuXG4gICAqL1xuICByZWFkQ2xpZW50ICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgcmVhZEluZm8gKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkVWludDgodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICByZWFkU3RyaW5nICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclN0cmluZyh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGlzS2V5XG4gICAqL1xuICByZWFkUGFyZW50SW5mbyAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpID09PSAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHJlYWRUeXBlUmVmICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBsZW4gb2YgYSBzdHJ1Y3QgLSB3ZWxsIHN1aXRlZCBmb3IgT3B0IFJMRSBlbmNvZGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgcmVhZExlbiAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgcmVhZEFueSAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRBbnkodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICAgKi9cbiAgcmVhZEJ1ZiAoKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5jb3B5VWludDhBcnJheShkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheSh0aGlzLnJlc3REZWNvZGVyKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMZWdhY3kgaW1wbGVtZW50YXRpb24gdXNlcyBKU09OIHBhcnNlLiBXZSB1c2UgYW55LWRlY29kaW5nIGluIHYyLlxuICAgKlxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICByZWFkSlNPTiAoKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RpbmcucmVhZFZhclN0cmluZyh0aGlzLnJlc3REZWNvZGVyKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICByZWFkS2V5ICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclN0cmluZyh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG59XG5cbmNsYXNzIERTRGVjb2RlclYyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRlY29kZXIpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZHNDdXJyVmFsID0gMDtcbiAgICB0aGlzLnJlc3REZWNvZGVyID0gZGVjb2RlcjtcbiAgfVxuXG4gIHJlc2V0RHNDdXJWYWwgKCkge1xuICAgIHRoaXMuZHNDdXJyVmFsID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICByZWFkRHNDbG9jayAoKSB7XG4gICAgdGhpcy5kc0N1cnJWYWwgKz0gZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2Rlcik7XG4gICAgcmV0dXJuIHRoaXMuZHNDdXJyVmFsXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZERzTGVuICgpIHtcbiAgICBjb25zdCBkaWZmID0gZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcikgKyAxO1xuICAgIHRoaXMuZHNDdXJyVmFsICs9IGRpZmY7XG4gICAgcmV0dXJuIGRpZmZcbiAgfVxufVxuXG5jbGFzcyBVcGRhdGVEZWNvZGVyVjIgZXh0ZW5kcyBEU0RlY29kZXJWMiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWNvZGVyKSB7XG4gICAgc3VwZXIoZGVjb2Rlcik7XG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBjYWNoZWQga2V5cy4gSWYgdGhlIGtleXNbaWRdIGRvZXMgbm90IGV4aXN0LCB3ZSByZWFkIGEgbmV3IGtleVxuICAgICAqIGZyb20gc3RyaW5nRW5jb2RlciBhbmQgcHVzaCBpdCB0byBrZXlzLlxuICAgICAqXG4gICAgICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5rZXlzID0gW107XG4gICAgZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlcik7IC8vIHJlYWQgZmVhdHVyZSBmbGFnIC0gY3VycmVudGx5IHVudXNlZFxuICAgIHRoaXMua2V5Q2xvY2tEZWNvZGVyID0gbmV3IGRlY29kaW5nLkludERpZmZPcHRSbGVEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKTtcbiAgICB0aGlzLmNsaWVudERlY29kZXIgPSBuZXcgZGVjb2RpbmcuVWludE9wdFJsZURlY29kZXIoZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpO1xuICAgIHRoaXMubGVmdENsb2NrRGVjb2RlciA9IG5ldyBkZWNvZGluZy5JbnREaWZmT3B0UmxlRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG4gICAgdGhpcy5yaWdodENsb2NrRGVjb2RlciA9IG5ldyBkZWNvZGluZy5JbnREaWZmT3B0UmxlRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG4gICAgdGhpcy5pbmZvRGVjb2RlciA9IG5ldyBkZWNvZGluZy5SbGVEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpLCBkZWNvZGluZy5yZWFkVWludDgpO1xuICAgIHRoaXMuc3RyaW5nRGVjb2RlciA9IG5ldyBkZWNvZGluZy5TdHJpbmdEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKTtcbiAgICB0aGlzLnBhcmVudEluZm9EZWNvZGVyID0gbmV3IGRlY29kaW5nLlJsZURlY29kZXIoZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlciksIGRlY29kaW5nLnJlYWRVaW50OCk7XG4gICAgdGhpcy50eXBlUmVmRGVjb2RlciA9IG5ldyBkZWNvZGluZy5VaW50T3B0UmxlRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG4gICAgdGhpcy5sZW5EZWNvZGVyID0gbmV3IGRlY29kaW5nLlVpbnRPcHRSbGVEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJRH1cbiAgICovXG4gIHJlYWRMZWZ0SUQgKCkge1xuICAgIHJldHVybiBuZXcgSUQodGhpcy5jbGllbnREZWNvZGVyLnJlYWQoKSwgdGhpcy5sZWZ0Q2xvY2tEZWNvZGVyLnJlYWQoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJRH1cbiAgICovXG4gIHJlYWRSaWdodElEICgpIHtcbiAgICByZXR1cm4gbmV3IElEKHRoaXMuY2xpZW50RGVjb2Rlci5yZWFkKCksIHRoaXMucmlnaHRDbG9ja0RlY29kZXIucmVhZCgpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgdGhlIG5leHQgY2xpZW50IGlkLlxuICAgKiBVc2UgdGhpcyBpbiBmYXZvciBvZiByZWFkSUQgd2hlbmV2ZXIgcG9zc2libGUgdG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyBjcmVhdGVkLlxuICAgKi9cbiAgcmVhZENsaWVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50RGVjb2Rlci5yZWFkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgcmVhZEluZm8gKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuaW5mb0RlY29kZXIucmVhZCgpKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHJlYWRTdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZ0RlY29kZXIucmVhZCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHJlYWRQYXJlbnRJbmZvICgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnRJbmZvRGVjb2Rlci5yZWFkKCkgPT09IDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHJlYWRUeXBlUmVmICgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlUmVmRGVjb2Rlci5yZWFkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBsZW4gb2YgYSBzdHJ1Y3QgLSB3ZWxsIHN1aXRlZCBmb3IgT3B0IFJMRSBlbmNvZGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICByZWFkTGVuICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5EZWNvZGVyLnJlYWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIHJlYWRBbnkgKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkQW55KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7VWludDhBcnJheX1cbiAgICovXG4gIHJlYWRCdWYgKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheSh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgbWFpbmx5IGhlcmUgZm9yIGxlZ2FjeSBwdXJwb3Nlcy5cbiAgICpcbiAgICogSW5pdGlhbCB3ZSBpbmNvZGVkIG9iamVjdHMgdXNpbmcgSlNPTi4gTm93IHdlIHVzZSB0aGUgbXVjaCBmYXN0ZXIgbGliMC9hbnktZW5jb2Rlci4gVGhpcyBtZXRob2QgbWFpbmx5IGV4aXN0cyBmb3IgbGVnYWN5IHB1cnBvc2VzIGZvciB0aGUgdjEgZW5jb2Rlci5cbiAgICpcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgcmVhZEpTT04gKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkQW55KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgcmVhZEtleSAoKSB7XG4gICAgY29uc3Qga2V5Q2xvY2sgPSB0aGlzLmtleUNsb2NrRGVjb2Rlci5yZWFkKCk7XG4gICAgaWYgKGtleUNsb2NrIDwgdGhpcy5rZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMua2V5c1trZXlDbG9ja11cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy5zdHJpbmdEZWNvZGVyLnJlYWQoKTtcbiAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgICByZXR1cm4ga2V5XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIERTRW5jb2RlclYxIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMucmVzdEVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKCk7XG4gIH1cblxuICB0b1VpbnQ4QXJyYXkgKCkge1xuICAgIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkodGhpcy5yZXN0RW5jb2RlcilcbiAgfVxuXG4gIHJlc2V0RHNDdXJWYWwgKCkge1xuICAgIC8vIG5vcFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICAgKi9cbiAgd3JpdGVEc0Nsb2NrIChjbG9jaykge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBjbG9jayk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgd3JpdGVEc0xlbiAobGVuKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGxlbik7XG4gIH1cbn1cblxuY2xhc3MgVXBkYXRlRW5jb2RlclYxIGV4dGVuZHMgRFNFbmNvZGVyVjEge1xuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICovXG4gIHdyaXRlTGVmdElEIChpZCkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBpZC5jbGllbnQpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBpZC5jbG9jayk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICovXG4gIHdyaXRlUmlnaHRJRCAoaWQpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgaWQuY2xpZW50KTtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgaWQuY2xvY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB3cml0ZUNsaWVudCBhbmQgd3JpdGVDbG9jayBpbnN0ZWFkIG9mIHdyaXRlSUQgaWYgcG9zc2libGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRcbiAgICovXG4gIHdyaXRlQ2xpZW50IChjbGllbnQpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgY2xpZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICB3cml0ZUluZm8gKGluZm8pIHtcbiAgICBlbmNvZGluZy53cml0ZVVpbnQ4KHRoaXMucmVzdEVuY29kZXIsIGluZm8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAqL1xuICB3cml0ZVN0cmluZyAocykge1xuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKHRoaXMucmVzdEVuY29kZXIsIHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNZS2V5XG4gICAqL1xuICB3cml0ZVBhcmVudEluZm8gKGlzWUtleSkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBpc1lLZXkgPyAxIDogMCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgd3JpdGVUeXBlUmVmIChpbmZvKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGluZm8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGxlbiBvZiBhIHN0cnVjdCAtIHdlbGwgc3VpdGVkIGZvciBPcHQgUkxFIGVuY29kZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIHdyaXRlTGVuIChsZW4pIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgbGVuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gYW55XG4gICAqL1xuICB3cml0ZUFueSAoYW55KSB7XG4gICAgZW5jb2Rpbmcud3JpdGVBbnkodGhpcy5yZXN0RW5jb2RlciwgYW55KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICAgKi9cbiAgd3JpdGVCdWYgKGJ1Zikge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheSh0aGlzLnJlc3RFbmNvZGVyLCBidWYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBlbWJlZFxuICAgKi9cbiAgd3JpdGVKU09OIChlbWJlZCkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKHRoaXMucmVzdEVuY29kZXIsIEpTT04uc3RyaW5naWZ5KGVtYmVkKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKi9cbiAgd3JpdGVLZXkgKGtleSkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKHRoaXMucmVzdEVuY29kZXIsIGtleSk7XG4gIH1cbn1cblxuY2xhc3MgRFNFbmNvZGVyVjIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5yZXN0RW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKTsgLy8gZW5jb2RlcyBhbGwgdGhlIHJlc3QgLyBub24tb3B0aW1pemVkXG4gICAgdGhpcy5kc0N1cnJWYWwgPSAwO1xuICB9XG5cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICByZXR1cm4gZW5jb2RpbmcudG9VaW50OEFycmF5KHRoaXMucmVzdEVuY29kZXIpXG4gIH1cblxuICByZXNldERzQ3VyVmFsICgpIHtcbiAgICB0aGlzLmRzQ3VyclZhbCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gICAqL1xuICB3cml0ZURzQ2xvY2sgKGNsb2NrKSB7XG4gICAgY29uc3QgZGlmZiA9IGNsb2NrIC0gdGhpcy5kc0N1cnJWYWw7XG4gICAgdGhpcy5kc0N1cnJWYWwgPSBjbG9jaztcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgZGlmZik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgd3JpdGVEc0xlbiAobGVuKSB7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgZXJyb3IudW5leHBlY3RlZENhc2UoKTtcbiAgICB9XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGxlbiAtIDEpO1xuICAgIHRoaXMuZHNDdXJyVmFsICs9IGxlbjtcbiAgfVxufVxuXG5jbGFzcyBVcGRhdGVFbmNvZGVyVjIgZXh0ZW5kcyBEU0VuY29kZXJWMiB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5rZXlNYXAgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogUmVmZXJzIHRvIHRoZSBuZXh0IHVuaXF1ZSBrZXktaWRlbnRpZmllciB0byBtZSB1c2VkLlxuICAgICAqIFNlZSB3cml0ZUtleSBtZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMua2V5Q2xvY2sgPSAwO1xuICAgIHRoaXMua2V5Q2xvY2tFbmNvZGVyID0gbmV3IGVuY29kaW5nLkludERpZmZPcHRSbGVFbmNvZGVyKCk7XG4gICAgdGhpcy5jbGllbnRFbmNvZGVyID0gbmV3IGVuY29kaW5nLlVpbnRPcHRSbGVFbmNvZGVyKCk7XG4gICAgdGhpcy5sZWZ0Q2xvY2tFbmNvZGVyID0gbmV3IGVuY29kaW5nLkludERpZmZPcHRSbGVFbmNvZGVyKCk7XG4gICAgdGhpcy5yaWdodENsb2NrRW5jb2RlciA9IG5ldyBlbmNvZGluZy5JbnREaWZmT3B0UmxlRW5jb2RlcigpO1xuICAgIHRoaXMuaW5mb0VuY29kZXIgPSBuZXcgZW5jb2RpbmcuUmxlRW5jb2RlcihlbmNvZGluZy53cml0ZVVpbnQ4KTtcbiAgICB0aGlzLnN0cmluZ0VuY29kZXIgPSBuZXcgZW5jb2RpbmcuU3RyaW5nRW5jb2RlcigpO1xuICAgIHRoaXMucGFyZW50SW5mb0VuY29kZXIgPSBuZXcgZW5jb2RpbmcuUmxlRW5jb2RlcihlbmNvZGluZy53cml0ZVVpbnQ4KTtcbiAgICB0aGlzLnR5cGVSZWZFbmNvZGVyID0gbmV3IGVuY29kaW5nLlVpbnRPcHRSbGVFbmNvZGVyKCk7XG4gICAgdGhpcy5sZW5FbmNvZGVyID0gbmV3IGVuY29kaW5nLlVpbnRPcHRSbGVFbmNvZGVyKCk7XG4gIH1cblxuICB0b1VpbnQ4QXJyYXkgKCkge1xuICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKCk7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIDApOyAvLyB0aGlzIGlzIGEgZmVhdHVyZSBmbGFnIHRoYXQgd2UgbWlnaHQgdXNlIGluIHRoZSBmdXR1cmVcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5rZXlDbG9ja0VuY29kZXIudG9VaW50OEFycmF5KCkpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLmNsaWVudEVuY29kZXIudG9VaW50OEFycmF5KCkpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLmxlZnRDbG9ja0VuY29kZXIudG9VaW50OEFycmF5KCkpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLnJpZ2h0Q2xvY2tFbmNvZGVyLnRvVWludDhBcnJheSgpKTtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgZW5jb2RpbmcudG9VaW50OEFycmF5KHRoaXMuaW5mb0VuY29kZXIpKTtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5zdHJpbmdFbmNvZGVyLnRvVWludDhBcnJheSgpKTtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgZW5jb2RpbmcudG9VaW50OEFycmF5KHRoaXMucGFyZW50SW5mb0VuY29kZXIpKTtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy50eXBlUmVmRW5jb2Rlci50b1VpbnQ4QXJyYXkoKSk7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRoaXMubGVuRW5jb2Rlci50b1VpbnQ4QXJyYXkoKSk7XG4gICAgLy8gQG5vdGUgVGhlIHJlc3QgZW5jb2RlciBpcyBhcHBlbmRlZCEgKG5vdGUgdGhlIG1pc3NpbmcgdmFyKVxuICAgIGVuY29kaW5nLndyaXRlVWludDhBcnJheShlbmNvZGVyLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkodGhpcy5yZXN0RW5jb2RlcikpO1xuICAgIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKi9cbiAgd3JpdGVMZWZ0SUQgKGlkKSB7XG4gICAgdGhpcy5jbGllbnRFbmNvZGVyLndyaXRlKGlkLmNsaWVudCk7XG4gICAgdGhpcy5sZWZ0Q2xvY2tFbmNvZGVyLndyaXRlKGlkLmNsb2NrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKi9cbiAgd3JpdGVSaWdodElEIChpZCkge1xuICAgIHRoaXMuY2xpZW50RW5jb2Rlci53cml0ZShpZC5jbGllbnQpO1xuICAgIHRoaXMucmlnaHRDbG9ja0VuY29kZXIud3JpdGUoaWQuY2xvY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRcbiAgICovXG4gIHdyaXRlQ2xpZW50IChjbGllbnQpIHtcbiAgICB0aGlzLmNsaWVudEVuY29kZXIud3JpdGUoY2xpZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICB3cml0ZUluZm8gKGluZm8pIHtcbiAgICB0aGlzLmluZm9FbmNvZGVyLndyaXRlKGluZm8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAqL1xuICB3cml0ZVN0cmluZyAocykge1xuICAgIHRoaXMuc3RyaW5nRW5jb2Rlci53cml0ZShzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzWUtleVxuICAgKi9cbiAgd3JpdGVQYXJlbnRJbmZvIChpc1lLZXkpIHtcbiAgICB0aGlzLnBhcmVudEluZm9FbmNvZGVyLndyaXRlKGlzWUtleSA/IDEgOiAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICB3cml0ZVR5cGVSZWYgKGluZm8pIHtcbiAgICB0aGlzLnR5cGVSZWZFbmNvZGVyLndyaXRlKGluZm8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGxlbiBvZiBhIHN0cnVjdCAtIHdlbGwgc3VpdGVkIGZvciBPcHQgUkxFIGVuY29kZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIHdyaXRlTGVuIChsZW4pIHtcbiAgICB0aGlzLmxlbkVuY29kZXIud3JpdGUobGVuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gYW55XG4gICAqL1xuICB3cml0ZUFueSAoYW55KSB7XG4gICAgZW5jb2Rpbmcud3JpdGVBbnkodGhpcy5yZXN0RW5jb2RlciwgYW55KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICAgKi9cbiAgd3JpdGVCdWYgKGJ1Zikge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheSh0aGlzLnJlc3RFbmNvZGVyLCBidWYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgbWFpbmx5IGhlcmUgZm9yIGxlZ2FjeSBwdXJwb3Nlcy5cbiAgICpcbiAgICogSW5pdGlhbCB3ZSBpbmNvZGVkIG9iamVjdHMgdXNpbmcgSlNPTi4gTm93IHdlIHVzZSB0aGUgbXVjaCBmYXN0ZXIgbGliMC9hbnktZW5jb2Rlci4gVGhpcyBtZXRob2QgbWFpbmx5IGV4aXN0cyBmb3IgbGVnYWN5IHB1cnBvc2VzIGZvciB0aGUgdjEgZW5jb2Rlci5cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IGVtYmVkXG4gICAqL1xuICB3cml0ZUpTT04gKGVtYmVkKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVBbnkodGhpcy5yZXN0RW5jb2RlciwgZW1iZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3BlcnR5IGtleXMgYXJlIG9mdGVuIHJldXNlZC4gRm9yIGV4YW1wbGUsIGluIHktcHJvc2VtaXJyb3IgdGhlIGtleSBgYm9sZGAgbWlnaHRcbiAgICogb2NjdXIgdmVyeSBvZnRlbi4gRm9yIGEgM2QgYXBwbGljYXRpb24sIHRoZSBrZXkgYHBvc2l0aW9uYCBtaWdodCBvY2N1ciB2ZXJ5IG9mdGVuLlxuICAgKlxuICAgKiBXZSBjYWNoZSB0aGVzZSBrZXlzIGluIGEgTWFwIGFuZCByZWZlciB0byB0aGVtIHZpYSBhIHVuaXF1ZSBudW1iZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICovXG4gIHdyaXRlS2V5IChrZXkpIHtcbiAgICBjb25zdCBjbG9jayA9IHRoaXMua2V5TWFwLmdldChrZXkpO1xuICAgIGlmIChjbG9jayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvKipcbiAgICAgICAqIEB0b2RvIHVuY29tbWVudCB0byBpbnRyb2R1Y2UgdGhpcyBmZWF0dXJlIGZpbmFsbHlcbiAgICAgICAqXG4gICAgICAgKiBCYWNrZ3JvdW5kLiBUaGUgQ29udGVudEZvcm1hdCBvYmplY3Qgd2FzIGFsd2F5cyBlbmNvZGVkIHVzaW5nIHdyaXRlS2V5LCBidXQgdGhlIGRlY29kZXIgdXNlZCB0byB1c2UgcmVhZFN0cmluZy5cbiAgICAgICAqIEZ1cnRoZXJtb3JlLCBJIGZvcmdvdCB0byBzZXQgdGhlIGtleWNsb2NrLiBTbyBldmVyeXRoaW5nIHdhcyB3b3JraW5nIGZpbmUuXG4gICAgICAgKlxuICAgICAgICogSG93ZXZlciwgdGhpcyBmZWF0dXJlIGhlcmUgaXMgYmFzaWNhbGx5IHVzZWxlc3MgYXMgaXQgaXMgbm90IGJlaW5nIHVzZWQgKGl0IGFjdHVhbGx5IG9ubHkgY29uc3VtZXMgZXh0cmEgbWVtb3J5KS5cbiAgICAgICAqXG4gICAgICAgKiBJIGRvbid0IGtub3cgeWV0IGhvdyB0byByZWludHJvZHVjZSB0aGlzIGZlYXR1cmUuLlxuICAgICAgICpcbiAgICAgICAqIE9sZGVyIGNsaWVudHMgd29uJ3QgYmUgYWJsZSB0byByZWFkIHVwZGF0ZXMgd2hlbiB3ZSByZWludHJvZHVjZSB0aGlzIGZlYXR1cmUuIFNvIHRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIGRvbmUgdXNpbmcgYSBmbGFnLlxuICAgICAgICpcbiAgICAgICAqL1xuICAgICAgLy8gdGhpcy5rZXlNYXAuc2V0KGtleSwgdGhpcy5rZXlDbG9jaylcbiAgICAgIHRoaXMua2V5Q2xvY2tFbmNvZGVyLndyaXRlKHRoaXMua2V5Q2xvY2srKyk7XG4gICAgICB0aGlzLnN0cmluZ0VuY29kZXIud3JpdGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5rZXlDbG9ja0VuY29kZXIud3JpdGUoY2xvY2spO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBtb2R1bGUgZW5jb2RpbmdcbiAqL1xuLypcbiAqIFdlIHVzZSB0aGUgZmlyc3QgZml2ZSBiaXRzIGluIHRoZSBpbmZvIGZsYWcgZm9yIGRldGVybWluaW5nIHRoZSB0eXBlIG9mIHRoZSBzdHJ1Y3QuXG4gKlxuICogMDogR0NcbiAqIDE6IEl0ZW0gd2l0aCBEZWxldGVkIGNvbnRlbnRcbiAqIDI6IEl0ZW0gd2l0aCBKU09OIGNvbnRlbnRcbiAqIDM6IEl0ZW0gd2l0aCBCaW5hcnkgY29udGVudFxuICogNDogSXRlbSB3aXRoIFN0cmluZyBjb250ZW50XG4gKiA1OiBJdGVtIHdpdGggRW1iZWQgY29udGVudCAoZm9yIHJpY2h0ZXh0IGNvbnRlbnQpXG4gKiA2OiBJdGVtIHdpdGggRm9ybWF0IGNvbnRlbnQgKGEgZm9ybWF0dGluZyBtYXJrZXIgZm9yIHJpY2h0ZXh0IGNvbnRlbnQpXG4gKiA3OiBJdGVtIHdpdGggVHlwZVxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICogQHBhcmFtIHtBcnJheTxHQ3xJdGVtPn0gc3RydWN0cyBBbGwgc3RydWN0cyBieSBgY2xpZW50YFxuICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFxuICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrIHdyaXRlIHN0cnVjdHMgc3RhcnRpbmcgd2l0aCBgSUQoY2xpZW50LGNsb2NrKWBcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgd3JpdGVTdHJ1Y3RzID0gKGVuY29kZXIsIHN0cnVjdHMsIGNsaWVudCwgY2xvY2spID0+IHtcbiAgLy8gd3JpdGUgZmlyc3QgaWRcbiAgY2xvY2sgPSBtYXRoLm1heChjbG9jaywgc3RydWN0c1swXS5pZC5jbG9jayk7IC8vIG1ha2Ugc3VyZSB0aGUgZmlyc3QgaWQgZXhpc3RzXG4gIGNvbnN0IHN0YXJ0TmV3U3RydWN0cyA9IGZpbmRJbmRleFNTKHN0cnVjdHMsIGNsb2NrKTtcbiAgLy8gd3JpdGUgIyBlbmNvZGVkIHN0cnVjdHNcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIHN0cnVjdHMubGVuZ3RoIC0gc3RhcnROZXdTdHJ1Y3RzKTtcbiAgZW5jb2Rlci53cml0ZUNsaWVudChjbGllbnQpO1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY2xvY2spO1xuICBjb25zdCBmaXJzdFN0cnVjdCA9IHN0cnVjdHNbc3RhcnROZXdTdHJ1Y3RzXTtcbiAgLy8gd3JpdGUgZmlyc3Qgc3RydWN0IHdpdGggYW4gb2Zmc2V0XG4gIGZpcnN0U3RydWN0LndyaXRlKGVuY29kZXIsIGNsb2NrIC0gZmlyc3RTdHJ1Y3QuaWQuY2xvY2spO1xuICBmb3IgKGxldCBpID0gc3RhcnROZXdTdHJ1Y3RzICsgMTsgaSA8IHN0cnVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICBzdHJ1Y3RzW2ldLndyaXRlKGVuY29kZXIsIDApO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtNYXA8bnVtYmVyLG51bWJlcj59IF9zbVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgd3JpdGVDbGllbnRzU3RydWN0cyA9IChlbmNvZGVyLCBzdG9yZSwgX3NtKSA9PiB7XG4gIC8vIHdlIGZpbHRlciBhbGwgdmFsaWQgX3NtIGVudHJpZXMgaW50byBzbVxuICBjb25zdCBzbSA9IG5ldyBNYXAoKTtcbiAgX3NtLmZvckVhY2goKGNsb2NrLCBjbGllbnQpID0+IHtcbiAgICAvLyBvbmx5IHdyaXRlIGlmIG5ldyBzdHJ1Y3RzIGFyZSBhdmFpbGFibGVcbiAgICBpZiAoZ2V0U3RhdGUoc3RvcmUsIGNsaWVudCkgPiBjbG9jaykge1xuICAgICAgc20uc2V0KGNsaWVudCwgY2xvY2spO1xuICAgIH1cbiAgfSk7XG4gIGdldFN0YXRlVmVjdG9yKHN0b3JlKS5mb3JFYWNoKChfY2xvY2ssIGNsaWVudCkgPT4ge1xuICAgIGlmICghX3NtLmhhcyhjbGllbnQpKSB7XG4gICAgICBzbS5zZXQoY2xpZW50LCAwKTtcbiAgICB9XG4gIH0pO1xuICAvLyB3cml0ZSAjIHN0YXRlcyB0aGF0IHdlcmUgdXBkYXRlZFxuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2Rlciwgc20uc2l6ZSk7XG4gIC8vIFdyaXRlIGl0ZW1zIHdpdGggaGlnaGVyIGNsaWVudCBpZHMgZmlyc3RcbiAgLy8gVGhpcyBoZWF2aWx5IGltcHJvdmVzIHRoZSBjb25mbGljdCBhbGdvcml0aG0uXG4gIGFycmF5LmZyb20oc20uZW50cmllcygpKS5zb3J0KChhLCBiKSA9PiBiWzBdIC0gYVswXSkuZm9yRWFjaCgoW2NsaWVudCwgY2xvY2tdKSA9PiB7XG4gICAgd3JpdGVTdHJ1Y3RzKGVuY29kZXIsIC8qKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59ICovIChzdG9yZS5jbGllbnRzLmdldChjbGllbnQpKSwgY2xpZW50LCBjbG9jayk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlciBUaGUgZGVjb2RlciBvYmplY3QgdG8gcmVhZCBkYXRhIGZyb20uXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcmV0dXJuIHtNYXA8bnVtYmVyLCB7IGk6IG51bWJlciwgcmVmczogQXJyYXk8SXRlbSB8IEdDPiB9Pn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRDbGllbnRzU3RydWN0UmVmcyA9IChkZWNvZGVyLCBkb2MpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtNYXA8bnVtYmVyLCB7IGk6IG51bWJlciwgcmVmczogQXJyYXk8SXRlbSB8IEdDPiB9Pn1cbiAgICovXG4gIGNvbnN0IGNsaWVudFJlZnMgPSBtYXAuY3JlYXRlKCk7XG4gIGNvbnN0IG51bU9mU3RhdGVVcGRhdGVzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtT2ZTdGF0ZVVwZGF0ZXM7IGkrKykge1xuICAgIGNvbnN0IG51bWJlck9mU3RydWN0cyA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn1cbiAgICAgKi9cbiAgICBjb25zdCByZWZzID0gbmV3IEFycmF5KG51bWJlck9mU3RydWN0cyk7XG4gICAgY29uc3QgY2xpZW50ID0gZGVjb2Rlci5yZWFkQ2xpZW50KCk7XG4gICAgbGV0IGNsb2NrID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgLy8gY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGNsaWVudFJlZnMuc2V0KGNsaWVudCwgeyBpOiAwLCByZWZzIH0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZTdHJ1Y3RzOyBpKyspIHtcbiAgICAgIGNvbnN0IGluZm8gPSBkZWNvZGVyLnJlYWRJbmZvKCk7XG4gICAgICBzd2l0Y2ggKGJpbmFyeS5CSVRTNSAmIGluZm8pIHtcbiAgICAgICAgY2FzZSAwOiB7IC8vIEdDXG4gICAgICAgICAgY29uc3QgbGVuID0gZGVjb2Rlci5yZWFkTGVuKCk7XG4gICAgICAgICAgcmVmc1tpXSA9IG5ldyBHQyhjcmVhdGVJRChjbGllbnQsIGNsb2NrKSwgbGVuKTtcbiAgICAgICAgICBjbG9jayArPSBsZW47XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDEwOiB7IC8vIFNraXAgU3RydWN0IChub3RoaW5nIHRvIGFwcGx5KVxuICAgICAgICAgIC8vIEB0b2RvIHdlIGNvdWxkIHJlZHVjZSB0aGUgYW1vdW50IG9mIGNoZWNrcyBieSBhZGRpbmcgU2tpcCBzdHJ1Y3QgdG8gY2xpZW50UmVmcyBzbyB3ZSBrbm93IHRoYXQgc29tZXRoaW5nIGlzIG1pc3NpbmcuXG4gICAgICAgICAgY29uc3QgbGVuID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgICAgICAgcmVmc1tpXSA9IG5ldyBTa2lwKGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLCBsZW4pO1xuICAgICAgICAgIGNsb2NrICs9IGxlbjtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHsgLy8gSXRlbSB3aXRoIGNvbnRlbnRcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBUaGUgb3B0aW1pemVkIGltcGxlbWVudGF0aW9uIGRvZXNuJ3QgdXNlIGFueSB2YXJpYWJsZXMgYmVjYXVzZSBpbmxpbmluZyB2YXJpYWJsZXMgaXMgZmFzdGVyLlxuICAgICAgICAgICAqIEJlbG93IGEgbm9uLW9wdGltaXplZCB2ZXJzaW9uIGlzIHNob3duIHRoYXQgaW1wbGVtZW50cyB0aGUgYmFzaWMgYWxnb3JpdGhtIHdpdGhcbiAgICAgICAgICAgKiBhIGZldyBjb21tZW50c1xuICAgICAgICAgICAqL1xuICAgICAgICAgIGNvbnN0IGNhbnRDb3B5UGFyZW50SW5mbyA9IChpbmZvICYgKGJpbmFyeS5CSVQ3IHwgYmluYXJ5LkJJVDgpKSA9PT0gMDtcbiAgICAgICAgICAvLyBJZiBwYXJlbnQgPSBudWxsIGFuZCBuZWl0aGVyIGxlZnQgbm9yIHJpZ2h0IGFyZSBkZWZpbmVkLCB0aGVuIHdlIGtub3cgdGhhdCBgcGFyZW50YCBpcyBjaGlsZCBvZiBgeWBcbiAgICAgICAgICAvLyBhbmQgd2UgcmVhZCB0aGUgbmV4dCBzdHJpbmcgYXMgcGFyZW50WUtleS5cbiAgICAgICAgICAvLyBJdCBpbmRpY2F0ZXMgaG93IHdlIHN0b3JlL3JldHJpZXZlIHBhcmVudCBmcm9tIGB5LnNoYXJlYFxuICAgICAgICAgIC8vIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBuZXcgSXRlbShcbiAgICAgICAgICAgIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLFxuICAgICAgICAgICAgbnVsbCwgLy8gbGVmdFxuICAgICAgICAgICAgKGluZm8gJiBiaW5hcnkuQklUOCkgPT09IGJpbmFyeS5CSVQ4ID8gZGVjb2Rlci5yZWFkTGVmdElEKCkgOiBudWxsLCAvLyBvcmlnaW5cbiAgICAgICAgICAgIG51bGwsIC8vIHJpZ2h0XG4gICAgICAgICAgICAoaW5mbyAmIGJpbmFyeS5CSVQ3KSA9PT0gYmluYXJ5LkJJVDcgPyBkZWNvZGVyLnJlYWRSaWdodElEKCkgOiBudWxsLCAvLyByaWdodCBvcmlnaW5cbiAgICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyA/IChkZWNvZGVyLnJlYWRQYXJlbnRJbmZvKCkgPyBkb2MuZ2V0KGRlY29kZXIucmVhZFN0cmluZygpKSA6IGRlY29kZXIucmVhZExlZnRJRCgpKSA6IG51bGwsIC8vIHBhcmVudFxuICAgICAgICAgICAgY2FudENvcHlQYXJlbnRJbmZvICYmIChpbmZvICYgYmluYXJ5LkJJVDYpID09PSBiaW5hcnkuQklUNiA/IGRlY29kZXIucmVhZFN0cmluZygpIDogbnVsbCwgLy8gcGFyZW50U3ViXG4gICAgICAgICAgICByZWFkSXRlbUNvbnRlbnQoZGVjb2RlciwgaW5mbykgLy8gaXRlbSBjb250ZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgICAvKiBBIG5vbi1vcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gb2YgdGhlIGFib3ZlIGFsZ29yaXRobTpcblxuICAgICAgICAgIC8vIFRoZSBpdGVtIHRoYXQgd2FzIG9yaWdpbmFsbHkgdG8gdGhlIGxlZnQgb2YgdGhpcyBpdGVtLlxuICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IChpbmZvICYgYmluYXJ5LkJJVDgpID09PSBiaW5hcnkuQklUOCA/IGRlY29kZXIucmVhZExlZnRJRCgpIDogbnVsbFxuICAgICAgICAgIC8vIFRoZSBpdGVtIHRoYXQgd2FzIG9yaWdpbmFsbHkgdG8gdGhlIHJpZ2h0IG9mIHRoaXMgaXRlbS5cbiAgICAgICAgICBjb25zdCByaWdodE9yaWdpbiA9IChpbmZvICYgYmluYXJ5LkJJVDcpID09PSBiaW5hcnkuQklUNyA/IGRlY29kZXIucmVhZFJpZ2h0SUQoKSA6IG51bGxcbiAgICAgICAgICBjb25zdCBjYW50Q29weVBhcmVudEluZm8gPSAoaW5mbyAmIChiaW5hcnkuQklUNyB8IGJpbmFyeS5CSVQ4KSkgPT09IDBcbiAgICAgICAgICBjb25zdCBoYXNQYXJlbnRZS2V5ID0gY2FudENvcHlQYXJlbnRJbmZvID8gZGVjb2Rlci5yZWFkUGFyZW50SW5mbygpIDogZmFsc2VcbiAgICAgICAgICAvLyBJZiBwYXJlbnQgPSBudWxsIGFuZCBuZWl0aGVyIGxlZnQgbm9yIHJpZ2h0IGFyZSBkZWZpbmVkLCB0aGVuIHdlIGtub3cgdGhhdCBgcGFyZW50YCBpcyBjaGlsZCBvZiBgeWBcbiAgICAgICAgICAvLyBhbmQgd2UgcmVhZCB0aGUgbmV4dCBzdHJpbmcgYXMgcGFyZW50WUtleS5cbiAgICAgICAgICAvLyBJdCBpbmRpY2F0ZXMgaG93IHdlIHN0b3JlL3JldHJpZXZlIHBhcmVudCBmcm9tIGB5LnNoYXJlYFxuICAgICAgICAgIC8vIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgICAgICBjb25zdCBwYXJlbnRZS2V5ID0gY2FudENvcHlQYXJlbnRJbmZvICYmIGhhc1BhcmVudFlLZXkgPyBkZWNvZGVyLnJlYWRTdHJpbmcoKSA6IG51bGxcblxuICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IG5ldyBJdGVtKFxuICAgICAgICAgICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayksXG4gICAgICAgICAgICBudWxsLCAvLyBsZWZ0XG4gICAgICAgICAgICBvcmlnaW4sIC8vIG9yaWdpblxuICAgICAgICAgICAgbnVsbCwgLy8gcmlnaHRcbiAgICAgICAgICAgIHJpZ2h0T3JpZ2luLCAvLyByaWdodCBvcmlnaW5cbiAgICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyAmJiAhaGFzUGFyZW50WUtleSA/IGRlY29kZXIucmVhZExlZnRJRCgpIDogKHBhcmVudFlLZXkgIT09IG51bGwgPyBkb2MuZ2V0KHBhcmVudFlLZXkpIDogbnVsbCksIC8vIHBhcmVudFxuICAgICAgICAgICAgY2FudENvcHlQYXJlbnRJbmZvICYmIChpbmZvICYgYmluYXJ5LkJJVDYpID09PSBiaW5hcnkuQklUNiA/IGRlY29kZXIucmVhZFN0cmluZygpIDogbnVsbCwgLy8gcGFyZW50U3ViXG4gICAgICAgICAgICByZWFkSXRlbUNvbnRlbnQoZGVjb2RlciwgaW5mbykgLy8gaXRlbSBjb250ZW50XG4gICAgICAgICAgKVxuICAgICAgICAgICovXG4gICAgICAgICAgcmVmc1tpXSA9IHN0cnVjdDtcbiAgICAgICAgICBjbG9jayArPSBzdHJ1Y3QubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKCd0aW1lIHRvIHJlYWQ6ICcsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpIC8vIEB0b2RvIHJlbW92ZVxuICB9XG4gIHJldHVybiBjbGllbnRSZWZzXG59O1xuXG4vKipcbiAqIFJlc3VtZSBjb21wdXRpbmcgc3RydWN0cyBnZW5lcmF0ZWQgYnkgc3RydWN0IHJlYWRlcnMuXG4gKlxuICogV2hpbGUgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGRvLCB3ZSBpbnRlZ3JhdGUgc3RydWN0cyBpbiB0aGlzIG9yZGVyXG4gKiAxLiB0b3AgZWxlbWVudCBvbiBzdGFjaywgaWYgc3RhY2sgaXMgbm90IGVtcHR5XG4gKiAyLiBuZXh0IGVsZW1lbnQgZnJvbSBjdXJyZW50IHN0cnVjdCByZWFkZXIgKGlmIGVtcHR5LCB1c2UgbmV4dCBzdHJ1Y3QgcmVhZGVyKVxuICpcbiAqIElmIHN0cnVjdCBjYXVzYWxseSBkZXBlbmRzIG9uIGFub3RoZXIgc3RydWN0IChyZWYubWlzc2luZyksIHdlIHB1dCBuZXh0IHJlYWRlciBvZlxuICogYHJlZi5pZC5jbGllbnRgIG9uIHRvcCBvZiBzdGFjay5cbiAqXG4gKiBBdCBzb21lIHBvaW50IHdlIGZpbmQgYSBzdHJ1Y3QgdGhhdCBoYXMgbm8gY2F1c2FsIGRlcGVuZGVuY2llcyxcbiAqIHRoZW4gd2Ugc3RhcnQgZW1wdHlpbmcgdGhlIHN0YWNrLlxuICpcbiAqIEl0IGlzIG5vdCBwb3NzaWJsZSB0byBoYXZlIGNpcmNsZXM6IGkuZS4gc3RydWN0MSAoZnJvbSBjbGllbnQxKSBkZXBlbmRzIG9uIHN0cnVjdDIgKGZyb20gY2xpZW50MilcbiAqIGRlcGVuZHMgb24gc3RydWN0MyAoZnJvbSBjbGllbnQxKS4gVGhlcmVmb3JlIHRoZSBtYXggc3RhY2sgc2l6ZSBpcyBlcXVhbCB0byBgc3RydWN0UmVhZGVycy5sZW5ndGhgLlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGltcGxlbWVudGVkIGluIGEgd2F5IHNvIHRoYXQgd2UgY2FuIHJlc3VtZSBjb21wdXRhdGlvbiBpZiB0aGlzIHVwZGF0ZVxuICogY2F1c2FsbHkgZGVwZW5kcyBvbiBhbm90aGVyIHVwZGF0ZS5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7TWFwPG51bWJlciwgeyBpOiBudW1iZXIsIHJlZnM6IChHQyB8IEl0ZW0pW10gfT59IGNsaWVudHNTdHJ1Y3RSZWZzXG4gKiBAcmV0dXJuIHsgbnVsbCB8IHsgdXBkYXRlOiBVaW50OEFycmF5LCBtaXNzaW5nOiBNYXA8bnVtYmVyLG51bWJlcj4gfSB9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBpbnRlZ3JhdGVTdHJ1Y3RzID0gKHRyYW5zYWN0aW9uLCBzdG9yZSwgY2xpZW50c1N0cnVjdFJlZnMpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxJdGVtIHwgR0M+fVxuICAgKi9cbiAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgLy8gc29ydCB0aGVtIHNvIHRoYXQgd2UgdGFrZSB0aGUgaGlnaGVyIGlkIGZpcnN0LCBpbiBjYXNlIG9mIGNvbmZsaWN0cyB0aGUgbG93ZXIgaWQgd2lsbCBwcm9iYWJseSBub3QgY29uZmxpY3Qgd2l0aCB0aGUgaWQgZnJvbSB0aGUgaGlnaGVyIHVzZXIuXG4gIGxldCBjbGllbnRzU3RydWN0UmVmc0lkcyA9IGFycmF5LmZyb20oY2xpZW50c1N0cnVjdFJlZnMua2V5cygpKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIGlmIChjbGllbnRzU3RydWN0UmVmc0lkcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGNvbnN0IGdldE5leHRTdHJ1Y3RUYXJnZXQgPSAoKSA9PiB7XG4gICAgaWYgKGNsaWVudHNTdHJ1Y3RSZWZzSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgbGV0IG5leHRTdHJ1Y3RzVGFyZ2V0ID0gLyoqIEB0eXBlIHt7aTpudW1iZXIscmVmczpBcnJheTxHQ3xJdGVtPn19ICovIChjbGllbnRzU3RydWN0UmVmcy5nZXQoY2xpZW50c1N0cnVjdFJlZnNJZHNbY2xpZW50c1N0cnVjdFJlZnNJZHMubGVuZ3RoIC0gMV0pKTtcbiAgICB3aGlsZSAobmV4dFN0cnVjdHNUYXJnZXQucmVmcy5sZW5ndGggPT09IG5leHRTdHJ1Y3RzVGFyZ2V0LmkpIHtcbiAgICAgIGNsaWVudHNTdHJ1Y3RSZWZzSWRzLnBvcCgpO1xuICAgICAgaWYgKGNsaWVudHNTdHJ1Y3RSZWZzSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbmV4dFN0cnVjdHNUYXJnZXQgPSAvKiogQHR5cGUge3tpOm51bWJlcixyZWZzOkFycmF5PEdDfEl0ZW0+fX0gKi8gKGNsaWVudHNTdHJ1Y3RSZWZzLmdldChjbGllbnRzU3RydWN0UmVmc0lkc1tjbGllbnRzU3RydWN0UmVmc0lkcy5sZW5ndGggLSAxXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5leHRTdHJ1Y3RzVGFyZ2V0XG4gIH07XG4gIGxldCBjdXJTdHJ1Y3RzVGFyZ2V0ID0gZ2V0TmV4dFN0cnVjdFRhcmdldCgpO1xuICBpZiAoY3VyU3RydWN0c1RhcmdldCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cnVjdFN0b3JlfVxuICAgKi9cbiAgY29uc3QgcmVzdFN0cnVjdHMgPSBuZXcgU3RydWN0U3RvcmUoKTtcbiAgY29uc3QgbWlzc2luZ1NWID0gbmV3IE1hcCgpO1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAgICovXG4gIGNvbnN0IHVwZGF0ZU1pc3NpbmdTdiA9IChjbGllbnQsIGNsb2NrKSA9PiB7XG4gICAgY29uc3QgbWNsb2NrID0gbWlzc2luZ1NWLmdldChjbGllbnQpO1xuICAgIGlmIChtY2xvY2sgPT0gbnVsbCB8fCBtY2xvY2sgPiBjbG9jaykge1xuICAgICAgbWlzc2luZ1NWLnNldChjbGllbnQsIGNsb2NrKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAdHlwZSB7R0N8SXRlbX1cbiAgICovXG4gIGxldCBzdGFja0hlYWQgPSAvKiogQHR5cGUge2FueX0gKi8gKGN1clN0cnVjdHNUYXJnZXQpLnJlZnNbLyoqIEB0eXBlIHthbnl9ICovIChjdXJTdHJ1Y3RzVGFyZ2V0KS5pKytdO1xuICAvLyBjYWNoaW5nIHRoZSBzdGF0ZSBiZWNhdXNlIGl0IGlzIHVzZWQgdmVyeSBvZnRlblxuICBjb25zdCBzdGF0ZSA9IG5ldyBNYXAoKTtcblxuICBjb25zdCBhZGRTdGFja1RvUmVzdFNTID0gKCkgPT4ge1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBzdGFjaykge1xuICAgICAgY29uc3QgY2xpZW50ID0gaXRlbS5pZC5jbGllbnQ7XG4gICAgICBjb25zdCBpbmFwcGxpY2FibGVJdGVtcyA9IGNsaWVudHNTdHJ1Y3RSZWZzLmdldChjbGllbnQpO1xuICAgICAgaWYgKGluYXBwbGljYWJsZUl0ZW1zKSB7XG4gICAgICAgIC8vIGRlY3JlbWVudCBiZWNhdXNlIHdlIHdlcmVuJ3QgYWJsZSB0byBhcHBseSBwcmV2aW91cyBvcGVyYXRpb25cbiAgICAgICAgaW5hcHBsaWNhYmxlSXRlbXMuaS0tO1xuICAgICAgICByZXN0U3RydWN0cy5jbGllbnRzLnNldChjbGllbnQsIGluYXBwbGljYWJsZUl0ZW1zLnJlZnMuc2xpY2UoaW5hcHBsaWNhYmxlSXRlbXMuaSkpO1xuICAgICAgICBjbGllbnRzU3RydWN0UmVmcy5kZWxldGUoY2xpZW50KTtcbiAgICAgICAgaW5hcHBsaWNhYmxlSXRlbXMuaSA9IDA7XG4gICAgICAgIGluYXBwbGljYWJsZUl0ZW1zLnJlZnMgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGl0ZW0gd2FzIHRoZSBsYXN0IGl0ZW0gb24gY2xpZW50c1N0cnVjdFJlZnMgYW5kIHRoZSBmaWVsZCB3YXMgYWxyZWFkeSBjbGVhcmVkLiBBZGQgaXRlbSB0byByZXN0U3RydWN0cyBhbmQgY29udGludWVcbiAgICAgICAgcmVzdFN0cnVjdHMuY2xpZW50cy5zZXQoY2xpZW50LCBbaXRlbV0pO1xuICAgICAgfVxuICAgICAgLy8gcmVtb3ZlIGNsaWVudCBmcm9tIGNsaWVudHNTdHJ1Y3RSZWZzSWRzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSBhcHBseWluZyB0aGUgc2FtZSB1cGRhdGUgYWdhaW5cbiAgICAgIGNsaWVudHNTdHJ1Y3RSZWZzSWRzID0gY2xpZW50c1N0cnVjdFJlZnNJZHMuZmlsdGVyKGMgPT4gYyAhPT0gY2xpZW50KTtcbiAgICB9XG4gICAgc3RhY2subGVuZ3RoID0gMDtcbiAgfTtcblxuICAvLyBpdGVyYXRlIG92ZXIgYWxsIHN0cnVjdCByZWFkZXJzIHVudGlsIHdlIGFyZSBkb25lXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKHN0YWNrSGVhZC5jb25zdHJ1Y3RvciAhPT0gU2tpcCkge1xuICAgICAgY29uc3QgbG9jYWxDbG9jayA9IG1hcC5zZXRJZlVuZGVmaW5lZChzdGF0ZSwgc3RhY2tIZWFkLmlkLmNsaWVudCwgKCkgPT4gZ2V0U3RhdGUoc3RvcmUsIHN0YWNrSGVhZC5pZC5jbGllbnQpKTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGxvY2FsQ2xvY2sgLSBzdGFja0hlYWQuaWQuY2xvY2s7XG4gICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAvLyB1cGRhdGUgZnJvbSB0aGUgc2FtZSBjbGllbnQgaXMgbWlzc2luZ1xuICAgICAgICBzdGFjay5wdXNoKHN0YWNrSGVhZCk7XG4gICAgICAgIHVwZGF0ZU1pc3NpbmdTdihzdGFja0hlYWQuaWQuY2xpZW50LCBzdGFja0hlYWQuaWQuY2xvY2sgLSAxKTtcbiAgICAgICAgLy8gaGlkIGEgZGVhZCB3YWxsLCBhZGQgYWxsIGl0ZW1zIGZyb20gc3RhY2sgdG8gcmVzdFNTXG4gICAgICAgIGFkZFN0YWNrVG9SZXN0U1MoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSBzdGFja0hlYWQuZ2V0TWlzc2luZyh0cmFuc2FjdGlvbiwgc3RvcmUpO1xuICAgICAgICBpZiAobWlzc2luZyAhPT0gbnVsbCkge1xuICAgICAgICAgIHN0YWNrLnB1c2goc3RhY2tIZWFkKTtcbiAgICAgICAgICAvLyBnZXQgdGhlIHN0cnVjdCByZWFkZXIgdGhhdCBoYXMgdGhlIG1pc3Npbmcgc3RydWN0XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQHR5cGUge3sgcmVmczogQXJyYXk8R0N8SXRlbT4sIGk6IG51bWJlciB9fVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGNvbnN0IHN0cnVjdFJlZnMgPSBjbGllbnRzU3RydWN0UmVmcy5nZXQoLyoqIEB0eXBlIHtudW1iZXJ9ICovIChtaXNzaW5nKSkgfHwgeyByZWZzOiBbXSwgaTogMCB9O1xuICAgICAgICAgIGlmIChzdHJ1Y3RSZWZzLnJlZnMubGVuZ3RoID09PSBzdHJ1Y3RSZWZzLmkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgdXBkYXRlIG1lc3NhZ2UgY2F1c2FsbHkgZGVwZW5kcyBvbiBhbm90aGVyIHVwZGF0ZSBtZXNzYWdlIHRoYXQgZG9lc24ndCBleGlzdCB5ZXRcbiAgICAgICAgICAgIHVwZGF0ZU1pc3NpbmdTdigvKiogQHR5cGUge251bWJlcn0gKi8gKG1pc3NpbmcpLCBnZXRTdGF0ZShzdG9yZSwgbWlzc2luZykpO1xuICAgICAgICAgICAgYWRkU3RhY2tUb1Jlc3RTUygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFja0hlYWQgPSBzdHJ1Y3RSZWZzLnJlZnNbc3RydWN0UmVmcy5pKytdO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ID09PSAwIHx8IG9mZnNldCA8IHN0YWNrSGVhZC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBhbGwgZmluZSwgYXBwbHkgdGhlIHN0YWNraGVhZFxuICAgICAgICAgIHN0YWNrSGVhZC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIG9mZnNldCk7XG4gICAgICAgICAgc3RhdGUuc2V0KHN0YWNrSGVhZC5pZC5jbGllbnQsIHN0YWNrSGVhZC5pZC5jbG9jayArIHN0YWNrSGVhZC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGl0ZXJhdGUgdG8gbmV4dCBzdGFja0hlYWRcbiAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgc3RhY2tIZWFkID0gLyoqIEB0eXBlIHtHQ3xJdGVtfSAqLyAoc3RhY2sucG9wKCkpO1xuICAgIH0gZWxzZSBpZiAoY3VyU3RydWN0c1RhcmdldCAhPT0gbnVsbCAmJiBjdXJTdHJ1Y3RzVGFyZ2V0LmkgPCBjdXJTdHJ1Y3RzVGFyZ2V0LnJlZnMubGVuZ3RoKSB7XG4gICAgICBzdGFja0hlYWQgPSAvKiogQHR5cGUge0dDfEl0ZW19ICovIChjdXJTdHJ1Y3RzVGFyZ2V0LnJlZnNbY3VyU3RydWN0c1RhcmdldC5pKytdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VyU3RydWN0c1RhcmdldCA9IGdldE5leHRTdHJ1Y3RUYXJnZXQoKTtcbiAgICAgIGlmIChjdXJTdHJ1Y3RzVGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgIC8vIHdlIGFyZSBkb25lIVxuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhY2tIZWFkID0gLyoqIEB0eXBlIHtHQ3xJdGVtfSAqLyAoY3VyU3RydWN0c1RhcmdldC5yZWZzW2N1clN0cnVjdHNUYXJnZXQuaSsrXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyZXN0U3RydWN0cy5jbGllbnRzLnNpemUgPiAwKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBVcGRhdGVFbmNvZGVyVjIoKTtcbiAgICB3cml0ZUNsaWVudHNTdHJ1Y3RzKGVuY29kZXIsIHJlc3RTdHJ1Y3RzLCBuZXcgTWFwKCkpO1xuICAgIC8vIHdyaXRlIGVtcHR5IGRlbGV0ZXNldFxuICAgIC8vIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIG5ldyBEZWxldGVTZXQoKSlcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgMCk7IC8vID0+IG5vIG5lZWQgZm9yIGFuIGV4dHJhIGZ1bmN0aW9uIGNhbGwsIGp1c3Qgd3JpdGUgMCBkZWxldGVzXG4gICAgcmV0dXJuIHsgbWlzc2luZzogbWlzc2luZ1NWLCB1cGRhdGU6IGVuY29kZXIudG9VaW50OEFycmF5KCkgfVxuICB9XG4gIHJldHVybiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgd3JpdGVTdHJ1Y3RzRnJvbVRyYW5zYWN0aW9uID0gKGVuY29kZXIsIHRyYW5zYWN0aW9uKSA9PiB3cml0ZUNsaWVudHNTdHJ1Y3RzKGVuY29kZXIsIHRyYW5zYWN0aW9uLmRvYy5zdG9yZSwgdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUpO1xuXG4vKipcbiAqIFJlYWQgYW5kIGFwcGx5IGEgZG9jdW1lbnQgdXBkYXRlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaGFzIHRoZSBzYW1lIGVmZmVjdCBhcyBgYXBwbHlVcGRhdGVgIGJ1dCBhY2NlcHRzIGEgZGVjb2Rlci5cbiAqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAqIEBwYXJhbSB7RG9jfSB5ZG9jXG4gKiBAcGFyYW0ge2FueX0gW3RyYW5zYWN0aW9uT3JpZ2luXSBUaGlzIHdpbGwgYmUgc3RvcmVkIG9uIGB0cmFuc2FjdGlvbi5vcmlnaW5gIGFuZCBgLm9uKCd1cGRhdGUnLCAodXBkYXRlLCBvcmlnaW4pKWBcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBbc3RydWN0RGVjb2Rlcl1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFVwZGF0ZVYyID0gKGRlY29kZXIsIHlkb2MsIHRyYW5zYWN0aW9uT3JpZ2luLCBzdHJ1Y3REZWNvZGVyID0gbmV3IFVwZGF0ZURlY29kZXJWMihkZWNvZGVyKSkgPT5cbiAgdHJhbnNhY3QoeWRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgIC8vIGZvcmNlIHRoYXQgdHJhbnNhY3Rpb24ubG9jYWwgaXMgc2V0IHRvIG5vbi1sb2NhbFxuICAgIHRyYW5zYWN0aW9uLmxvY2FsID0gZmFsc2U7XG4gICAgbGV0IHJldHJ5ID0gZmFsc2U7XG4gICAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICAgIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlO1xuICAgIC8vIGxldCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgY29uc3Qgc3MgPSByZWFkQ2xpZW50c1N0cnVjdFJlZnMoc3RydWN0RGVjb2RlciwgZG9jKTtcbiAgICAvLyBjb25zb2xlLmxvZygndGltZSB0byByZWFkIHN0cnVjdHM6ICcsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpIC8vIEB0b2RvIHJlbW92ZVxuICAgIC8vIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAvLyBjb25zb2xlLmxvZygndGltZSB0byBtZXJnZTogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gICAgLy8gc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGNvbnN0IHJlc3RTdHJ1Y3RzID0gaW50ZWdyYXRlU3RydWN0cyh0cmFuc2FjdGlvbiwgc3RvcmUsIHNzKTtcbiAgICBjb25zdCBwZW5kaW5nID0gc3RvcmUucGVuZGluZ1N0cnVjdHM7XG4gICAgaWYgKHBlbmRpbmcpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHdlIGNhbiBhcHBseSBzb21ldGhpbmdcbiAgICAgIGZvciAoY29uc3QgW2NsaWVudCwgY2xvY2tdIG9mIHBlbmRpbmcubWlzc2luZykge1xuICAgICAgICBpZiAoY2xvY2sgPCBnZXRTdGF0ZShzdG9yZSwgY2xpZW50KSkge1xuICAgICAgICAgIHJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzdFN0cnVjdHMpIHtcbiAgICAgICAgLy8gbWVyZ2UgcmVzdFN0cnVjdHMgaW50byBzdG9yZS5wZW5kaW5nXG4gICAgICAgIGZvciAoY29uc3QgW2NsaWVudCwgY2xvY2tdIG9mIHJlc3RTdHJ1Y3RzLm1pc3NpbmcpIHtcbiAgICAgICAgICBjb25zdCBtY2xvY2sgPSBwZW5kaW5nLm1pc3NpbmcuZ2V0KGNsaWVudCk7XG4gICAgICAgICAgaWYgKG1jbG9jayA9PSBudWxsIHx8IG1jbG9jayA+IGNsb2NrKSB7XG4gICAgICAgICAgICBwZW5kaW5nLm1pc3Npbmcuc2V0KGNsaWVudCwgY2xvY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwZW5kaW5nLnVwZGF0ZSA9IG1lcmdlVXBkYXRlc1YyKFtwZW5kaW5nLnVwZGF0ZSwgcmVzdFN0cnVjdHMudXBkYXRlXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3JlLnBlbmRpbmdTdHJ1Y3RzID0gcmVzdFN0cnVjdHM7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKCd0aW1lIHRvIGludGVncmF0ZTogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gICAgLy8gc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGNvbnN0IGRzUmVzdCA9IHJlYWRBbmRBcHBseURlbGV0ZVNldChzdHJ1Y3REZWNvZGVyLCB0cmFuc2FjdGlvbiwgc3RvcmUpO1xuICAgIGlmIChzdG9yZS5wZW5kaW5nRHMpIHtcbiAgICAgIC8vIEB0b2RvIHdlIGNvdWxkIG1ha2UgYSBsb3dlci1ib3VuZCBzdGF0ZS12ZWN0b3IgY2hlY2sgYXMgd2UgZG8gYWJvdmVcbiAgICAgIGNvbnN0IHBlbmRpbmdEU1VwZGF0ZSA9IG5ldyBVcGRhdGVEZWNvZGVyVjIoZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihzdG9yZS5wZW5kaW5nRHMpKTtcbiAgICAgIGRlY29kaW5nLnJlYWRWYXJVaW50KHBlbmRpbmdEU1VwZGF0ZS5yZXN0RGVjb2Rlcik7IC8vIHJlYWQgMCBzdHJ1Y3RzLCBiZWNhdXNlIHdlIG9ubHkgZW5jb2RlIGRlbGV0ZXMgaW4gcGVuZGluZ2RzdXBkYXRlXG4gICAgICBjb25zdCBkc1Jlc3QyID0gcmVhZEFuZEFwcGx5RGVsZXRlU2V0KHBlbmRpbmdEU1VwZGF0ZSwgdHJhbnNhY3Rpb24sIHN0b3JlKTtcbiAgICAgIGlmIChkc1Jlc3QgJiYgZHNSZXN0Mikge1xuICAgICAgICAvLyBjYXNlIDE6IGRzMSAhPSBudWxsICYmIGRzMiAhPSBudWxsXG4gICAgICAgIHN0b3JlLnBlbmRpbmdEcyA9IG1lcmdlVXBkYXRlc1YyKFtkc1Jlc3QsIGRzUmVzdDJdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNhc2UgMjogZHMxICE9IG51bGxcbiAgICAgICAgLy8gY2FzZSAzOiBkczIgIT0gbnVsbFxuICAgICAgICAvLyBjYXNlIDQ6IGRzMSA9PSBudWxsICYmIGRzMiA9PSBudWxsXG4gICAgICAgIHN0b3JlLnBlbmRpbmdEcyA9IGRzUmVzdCB8fCBkc1Jlc3QyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFaXRoZXIgZHNSZXN0ID09IG51bGwgJiYgcGVuZGluZ0RzID09IG51bGwgT1IgZHNSZXN0ICE9IG51bGxcbiAgICAgIHN0b3JlLnBlbmRpbmdEcyA9IGRzUmVzdDtcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coJ3RpbWUgdG8gY2xlYW51cDogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gICAgLy8gc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuXG4gICAgLy8gY29uc29sZS5sb2coJ3RpbWUgdG8gcmVzdW1lIGRlbGV0ZSByZWFkZXJzOiAnLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KSAvLyBAdG9kbyByZW1vdmVcbiAgICAvLyBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgaWYgKHJldHJ5KSB7XG4gICAgICBjb25zdCB1cGRhdGUgPSAvKiogQHR5cGUge3t1cGRhdGU6IFVpbnQ4QXJyYXl9fSAqLyAoc3RvcmUucGVuZGluZ1N0cnVjdHMpLnVwZGF0ZTtcbiAgICAgIHN0b3JlLnBlbmRpbmdTdHJ1Y3RzID0gbnVsbDtcbiAgICAgIGFwcGx5VXBkYXRlVjIodHJhbnNhY3Rpb24uZG9jLCB1cGRhdGUpO1xuICAgIH1cbiAgfSwgdHJhbnNhY3Rpb25PcmlnaW4sIGZhbHNlKTtcblxuLyoqXG4gKiBSZWFkIGFuZCBhcHBseSBhIGRvY3VtZW50IHVwZGF0ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgYGFwcGx5VXBkYXRlYCBidXQgYWNjZXB0cyBhIGRlY29kZXIuXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge0RvY30geWRvY1xuICogQHBhcmFtIHthbnl9IFt0cmFuc2FjdGlvbk9yaWdpbl0gVGhpcyB3aWxsIGJlIHN0b3JlZCBvbiBgdHJhbnNhY3Rpb24ub3JpZ2luYCBhbmQgYC5vbigndXBkYXRlJywgKHVwZGF0ZSwgb3JpZ2luKSlgXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRVcGRhdGUgPSAoZGVjb2RlciwgeWRvYywgdHJhbnNhY3Rpb25PcmlnaW4pID0+IHJlYWRVcGRhdGVWMihkZWNvZGVyLCB5ZG9jLCB0cmFuc2FjdGlvbk9yaWdpbiwgbmV3IFVwZGF0ZURlY29kZXJWMShkZWNvZGVyKSk7XG5cbi8qKlxuICogQXBwbHkgYSBkb2N1bWVudCB1cGRhdGUgY3JlYXRlZCBieSwgZm9yIGV4YW1wbGUsIGB5Lm9uKCd1cGRhdGUnLCB1cGRhdGUgPT4gLi4pYCBvciBgdXBkYXRlID0gZW5jb2RlU3RhdGVBc1VwZGF0ZSgpYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgYHJlYWRVcGRhdGVgIGJ1dCBhY2NlcHRzIGFuIFVpbnQ4QXJyYXkgaW5zdGVhZCBvZiBhIERlY29kZXIuXG4gKlxuICogQHBhcmFtIHtEb2N9IHlkb2NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge2FueX0gW3RyYW5zYWN0aW9uT3JpZ2luXSBUaGlzIHdpbGwgYmUgc3RvcmVkIG9uIGB0cmFuc2FjdGlvbi5vcmlnaW5gIGFuZCBgLm9uKCd1cGRhdGUnLCAodXBkYXRlLCBvcmlnaW4pKWBcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjJ9IFtZRGVjb2Rlcl1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgYXBwbHlVcGRhdGVWMiA9ICh5ZG9jLCB1cGRhdGUsIHRyYW5zYWN0aW9uT3JpZ2luLCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMikgPT4ge1xuICBjb25zdCBkZWNvZGVyID0gZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpO1xuICByZWFkVXBkYXRlVjIoZGVjb2RlciwgeWRvYywgdHJhbnNhY3Rpb25PcmlnaW4sIG5ldyBZRGVjb2RlcihkZWNvZGVyKSk7XG59O1xuXG4vKipcbiAqIEFwcGx5IGEgZG9jdW1lbnQgdXBkYXRlIGNyZWF0ZWQgYnksIGZvciBleGFtcGxlLCBgeS5vbigndXBkYXRlJywgdXBkYXRlID0+IC4uKWAgb3IgYHVwZGF0ZSA9IGVuY29kZVN0YXRlQXNVcGRhdGUoKWAuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIGByZWFkVXBkYXRlYCBidXQgYWNjZXB0cyBhbiBVaW50OEFycmF5IGluc3RlYWQgb2YgYSBEZWNvZGVyLlxuICpcbiAqIEBwYXJhbSB7RG9jfSB5ZG9jXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHthbnl9IFt0cmFuc2FjdGlvbk9yaWdpbl0gVGhpcyB3aWxsIGJlIHN0b3JlZCBvbiBgdHJhbnNhY3Rpb24ub3JpZ2luYCBhbmQgYC5vbigndXBkYXRlJywgKHVwZGF0ZSwgb3JpZ2luKSlgXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGFwcGx5VXBkYXRlID0gKHlkb2MsIHVwZGF0ZSwgdHJhbnNhY3Rpb25PcmlnaW4pID0+IGFwcGx5VXBkYXRlVjIoeWRvYywgdXBkYXRlLCB0cmFuc2FjdGlvbk9yaWdpbiwgVXBkYXRlRGVjb2RlclYxKTtcblxuLyoqXG4gKiBXcml0ZSBhbGwgdGhlIGRvY3VtZW50IGFzIGEgc2luZ2xlIHVwZGF0ZSBtZXNzYWdlLiBJZiB5b3Ugc3BlY2lmeSB0aGUgc3RhdGUgb2YgdGhlIHJlbW90ZSBjbGllbnQgKGB0YXJnZXRTdGF0ZVZlY3RvcmApIGl0IHdpbGxcbiAqIG9ubHkgd3JpdGUgdGhlIG9wZXJhdGlvbnMgdGhhdCBhcmUgbWlzc2luZy5cbiAqXG4gKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICogQHBhcmFtIHtEb2N9IGRvY1xuICogQHBhcmFtIHtNYXA8bnVtYmVyLG51bWJlcj59IFt0YXJnZXRTdGF0ZVZlY3Rvcl0gVGhlIHN0YXRlIG9mIHRoZSB0YXJnZXQgdGhhdCByZWNlaXZlcyB0aGUgdXBkYXRlLiBMZWF2ZSBlbXB0eSB0byB3cml0ZSBhbGwga25vd24gc3RydWN0c1xuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB3cml0ZVN0YXRlQXNVcGRhdGUgPSAoZW5jb2RlciwgZG9jLCB0YXJnZXRTdGF0ZVZlY3RvciA9IG5ldyBNYXAoKSkgPT4ge1xuICB3cml0ZUNsaWVudHNTdHJ1Y3RzKGVuY29kZXIsIGRvYy5zdG9yZSwgdGFyZ2V0U3RhdGVWZWN0b3IpO1xuICB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCBjcmVhdGVEZWxldGVTZXRGcm9tU3RydWN0U3RvcmUoZG9jLnN0b3JlKSk7XG59O1xuXG4vKipcbiAqIFdyaXRlIGFsbCB0aGUgZG9jdW1lbnQgYXMgYSBzaW5nbGUgdXBkYXRlIG1lc3NhZ2UgdGhhdCBjYW4gYmUgYXBwbGllZCBvbiB0aGUgcmVtb3RlIGRvY3VtZW50LiBJZiB5b3Ugc3BlY2lmeSB0aGUgc3RhdGUgb2YgdGhlIHJlbW90ZSBjbGllbnQgKGB0YXJnZXRTdGF0ZWApIGl0IHdpbGxcbiAqIG9ubHkgd3JpdGUgdGhlIG9wZXJhdGlvbnMgdGhhdCBhcmUgbWlzc2luZy5cbiAqXG4gKiBVc2UgYHdyaXRlU3RhdGVBc1VwZGF0ZWAgaW5zdGVhZCBpZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBsaWIwL2VuY29kaW5nLmpzI0VuY29kZXJcbiAqXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IFtlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3JdIFRoZSBzdGF0ZSBvZiB0aGUgdGFyZ2V0IHRoYXQgcmVjZWl2ZXMgdGhlIHVwZGF0ZS4gTGVhdmUgZW1wdHkgdG8gd3JpdGUgYWxsIGtub3duIHN0cnVjdHNcbiAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBbZW5jb2Rlcl1cbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGVuY29kZVN0YXRlQXNVcGRhdGVWMiA9IChkb2MsIGVuY29kZWRUYXJnZXRTdGF0ZVZlY3RvciA9IG5ldyBVaW50OEFycmF5KFswXSksIGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYyKCkpID0+IHtcbiAgY29uc3QgdGFyZ2V0U3RhdGVWZWN0b3IgPSBkZWNvZGVTdGF0ZVZlY3RvcihlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3IpO1xuICB3cml0ZVN0YXRlQXNVcGRhdGUoZW5jb2RlciwgZG9jLCB0YXJnZXRTdGF0ZVZlY3Rvcik7XG4gIGNvbnN0IHVwZGF0ZXMgPSBbZW5jb2Rlci50b1VpbnQ4QXJyYXkoKV07XG4gIC8vIGFsc28gYWRkIHRoZSBwZW5kaW5nIHVwZGF0ZXMgKGlmIHRoZXJlIGFyZSBhbnkpXG4gIGlmIChkb2Muc3RvcmUucGVuZGluZ0RzKSB7XG4gICAgdXBkYXRlcy5wdXNoKGRvYy5zdG9yZS5wZW5kaW5nRHMpO1xuICB9XG4gIGlmIChkb2Muc3RvcmUucGVuZGluZ1N0cnVjdHMpIHtcbiAgICB1cGRhdGVzLnB1c2goZGlmZlVwZGF0ZVYyKGRvYy5zdG9yZS5wZW5kaW5nU3RydWN0cy51cGRhdGUsIGVuY29kZWRUYXJnZXRTdGF0ZVZlY3RvcikpO1xuICB9XG4gIGlmICh1cGRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoZW5jb2Rlci5jb25zdHJ1Y3RvciA9PT0gVXBkYXRlRW5jb2RlclYxKSB7XG4gICAgICByZXR1cm4gbWVyZ2VVcGRhdGVzKHVwZGF0ZXMubWFwKCh1cGRhdGUsIGkpID0+IGkgPT09IDAgPyB1cGRhdGUgOiBjb252ZXJ0VXBkYXRlRm9ybWF0VjJUb1YxKHVwZGF0ZSkpKVxuICAgIH0gZWxzZSBpZiAoZW5jb2Rlci5jb25zdHJ1Y3RvciA9PT0gVXBkYXRlRW5jb2RlclYyKSB7XG4gICAgICByZXR1cm4gbWVyZ2VVcGRhdGVzVjIodXBkYXRlcylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZXNbMF1cbn07XG5cbi8qKlxuICogV3JpdGUgYWxsIHRoZSBkb2N1bWVudCBhcyBhIHNpbmdsZSB1cGRhdGUgbWVzc2FnZSB0aGF0IGNhbiBiZSBhcHBsaWVkIG9uIHRoZSByZW1vdGUgZG9jdW1lbnQuIElmIHlvdSBzcGVjaWZ5IHRoZSBzdGF0ZSBvZiB0aGUgcmVtb3RlIGNsaWVudCAoYHRhcmdldFN0YXRlYCkgaXQgd2lsbFxuICogb25seSB3cml0ZSB0aGUgb3BlcmF0aW9ucyB0aGF0IGFyZSBtaXNzaW5nLlxuICpcbiAqIFVzZSBgd3JpdGVTdGF0ZUFzVXBkYXRlYCBpbnN0ZWFkIGlmIHlvdSBhcmUgd29ya2luZyB3aXRoIGxpYjAvZW5jb2RpbmcuanMjRW5jb2RlclxuICpcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gW2VuY29kZWRUYXJnZXRTdGF0ZVZlY3Rvcl0gVGhlIHN0YXRlIG9mIHRoZSB0YXJnZXQgdGhhdCByZWNlaXZlcyB0aGUgdXBkYXRlLiBMZWF2ZSBlbXB0eSB0byB3cml0ZSBhbGwga25vd24gc3RydWN0c1xuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZW5jb2RlU3RhdGVBc1VwZGF0ZSA9IChkb2MsIGVuY29kZWRUYXJnZXRTdGF0ZVZlY3RvcikgPT4gZW5jb2RlU3RhdGVBc1VwZGF0ZVYyKGRvYywgZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yLCBuZXcgVXBkYXRlRW5jb2RlclYxKCkpO1xuXG4vKipcbiAqIFJlYWQgc3RhdGUgdmVjdG9yIGZyb20gRGVjb2RlciBhbmQgcmV0dXJuIGFzIE1hcFxuICpcbiAqIEBwYXJhbSB7RFNEZWNvZGVyVjEgfCBEU0RlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7TWFwPG51bWJlcixudW1iZXI+fSBNYXBzIGBjbGllbnRgIHRvIHRoZSBudW1iZXIgbmV4dCBleHBlY3RlZCBgY2xvY2tgIGZyb20gdGhhdCBjbGllbnQuXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRTdGF0ZVZlY3RvciA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBzcyA9IG5ldyBNYXAoKTtcbiAgY29uc3Qgc3NMZW5ndGggPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzc0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50ID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgY29uc3QgY2xvY2sgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICBzcy5zZXQoY2xpZW50LCBjbG9jayk7XG4gIH1cbiAgcmV0dXJuIHNzXG59O1xuXG4vKipcbiAqIFJlYWQgZGVjb2RlZFN0YXRlIGFuZCByZXR1cm4gU3RhdGUgYXMgTWFwLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGVjb2RlZFN0YXRlXG4gKiBAcmV0dXJuIHtNYXA8bnVtYmVyLG51bWJlcj59IE1hcHMgYGNsaWVudGAgdG8gdGhlIG51bWJlciBuZXh0IGV4cGVjdGVkIGBjbG9ja2AgZnJvbSB0aGF0IGNsaWVudC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuLy8gZXhwb3J0IGNvbnN0IGRlY29kZVN0YXRlVmVjdG9yVjIgPSBkZWNvZGVkU3RhdGUgPT4gcmVhZFN0YXRlVmVjdG9yKG5ldyBEU0RlY29kZXJWMihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGRlY29kZWRTdGF0ZSkpKVxuXG4vKipcbiAqIFJlYWQgZGVjb2RlZFN0YXRlIGFuZCByZXR1cm4gU3RhdGUgYXMgTWFwLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGVjb2RlZFN0YXRlXG4gKiBAcmV0dXJuIHtNYXA8bnVtYmVyLG51bWJlcj59IE1hcHMgYGNsaWVudGAgdG8gdGhlIG51bWJlciBuZXh0IGV4cGVjdGVkIGBjbG9ja2AgZnJvbSB0aGF0IGNsaWVudC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZGVjb2RlU3RhdGVWZWN0b3IgPSBkZWNvZGVkU3RhdGUgPT4gcmVhZFN0YXRlVmVjdG9yKG5ldyBEU0RlY29kZXJWMShkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGRlY29kZWRTdGF0ZSkpKTtcblxuLyoqXG4gKiBAcGFyYW0ge0RTRW5jb2RlclYxIHwgRFNFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7TWFwPG51bWJlcixudW1iZXI+fSBzdlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlU3RhdGVWZWN0b3IgPSAoZW5jb2Rlciwgc3YpID0+IHtcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIHN2LnNpemUpO1xuICBhcnJheS5mcm9tKHN2LmVudHJpZXMoKSkuc29ydCgoYSwgYikgPT4gYlswXSAtIGFbMF0pLmZvckVhY2goKFtjbGllbnQsIGNsb2NrXSkgPT4ge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjbGllbnQpOyAvLyBAdG9kbyB1c2UgYSBzcGVjaWFsIGNsaWVudCBkZWNvZGVyIHRoYXQgaXMgYmFzZWQgb24gbWFwcGluZ1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjbG9jayk7XG4gIH0pO1xuICByZXR1cm4gZW5jb2RlclxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RTRW5jb2RlclYxIHwgRFNFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgd3JpdGVEb2N1bWVudFN0YXRlVmVjdG9yID0gKGVuY29kZXIsIGRvYykgPT4gd3JpdGVTdGF0ZVZlY3RvcihlbmNvZGVyLCBnZXRTdGF0ZVZlY3Rvcihkb2Muc3RvcmUpKTtcblxuLyoqXG4gKiBFbmNvZGUgU3RhdGUgYXMgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0ge0RvY3xNYXA8bnVtYmVyLG51bWJlcj59IGRvY1xuICogQHBhcmFtIHtEU0VuY29kZXJWMSB8IERTRW5jb2RlclYyfSBbZW5jb2Rlcl1cbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGVuY29kZVN0YXRlVmVjdG9yVjIgPSAoZG9jLCBlbmNvZGVyID0gbmV3IERTRW5jb2RlclYyKCkpID0+IHtcbiAgaWYgKGRvYyBpbnN0YW5jZW9mIE1hcCkge1xuICAgIHdyaXRlU3RhdGVWZWN0b3IoZW5jb2RlciwgZG9jKTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZURvY3VtZW50U3RhdGVWZWN0b3IoZW5jb2RlciwgZG9jKTtcbiAgfVxuICByZXR1cm4gZW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxufTtcblxuLyoqXG4gKiBFbmNvZGUgU3RhdGUgYXMgVWludDhBcnJheS5cbiAqXG4gKiBAcGFyYW0ge0RvY3xNYXA8bnVtYmVyLG51bWJlcj59IGRvY1xuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZW5jb2RlU3RhdGVWZWN0b3IgPSBkb2MgPT4gZW5jb2RlU3RhdGVWZWN0b3JWMihkb2MsIG5ldyBEU0VuY29kZXJWMSgpKTtcblxuLyoqXG4gKiBHZW5lcmFsIGV2ZW50IGhhbmRsZXIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHRlbXBsYXRlIEFSRzAsIEFSRzFcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBFdmVudEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKEFSRzAsIEFSRzEpOnZvaWQ+fVxuICAgICAqL1xuICAgIHRoaXMubCA9IFtdO1xuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIEFSRzAsQVJHMVxuICogQHJldHVybnMge0V2ZW50SGFuZGxlcjxBUkcwLEFSRzE+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlRXZlbnRIYW5kbGVyID0gKCkgPT4gbmV3IEV2ZW50SGFuZGxlcigpO1xuXG4vKipcbiAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBpcyBjYWxsZWQgd2hlblxuICoge0BsaW5rIEV2ZW50SGFuZGxlciNjYWxsRXZlbnRMaXN0ZW5lcnN9IGlzIGNhbGxlZC5cbiAqXG4gKiBAdGVtcGxhdGUgQVJHMCxBUkcxXG4gKiBAcGFyYW0ge0V2ZW50SGFuZGxlcjxBUkcwLEFSRzE+fSBldmVudEhhbmRsZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oQVJHMCxBUkcxKTp2b2lkfSBmIFRoZSBldmVudCBoYW5kbGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgYWRkRXZlbnRIYW5kbGVyTGlzdGVuZXIgPSAoZXZlbnRIYW5kbGVyLCBmKSA9PlxuICBldmVudEhhbmRsZXIubC5wdXNoKGYpO1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHRlbXBsYXRlIEFSRzAsQVJHMVxuICogQHBhcmFtIHtFdmVudEhhbmRsZXI8QVJHMCxBUkcxPn0gZXZlbnRIYW5kbGVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEFSRzAsQVJHMSk6dm9pZH0gZiBUaGUgZXZlbnQgaGFuZGxlciB0aGF0IHdhcyBhZGRlZCB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgIHtAbGluayBFdmVudEhhbmRsZXIjYWRkRXZlbnRMaXN0ZW5lcn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlbW92ZUV2ZW50SGFuZGxlckxpc3RlbmVyID0gKGV2ZW50SGFuZGxlciwgZikgPT4ge1xuICBjb25zdCBsID0gZXZlbnRIYW5kbGVyLmw7XG4gIGNvbnN0IGxlbiA9IGwubGVuZ3RoO1xuICBldmVudEhhbmRsZXIubCA9IGwuZmlsdGVyKGcgPT4gZiAhPT0gZyk7XG4gIGlmIChsZW4gPT09IGV2ZW50SGFuZGxlci5sLmxlbmd0aCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1t5anNdIFRyaWVkIHRvIHJlbW92ZSBldmVudCBoYW5kbGVyIHRoYXQgZG9lc25cXCd0IGV4aXN0LicpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGwgYWxsIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQgdmlhXG4gKiB7QGxpbmsgRXZlbnRIYW5kbGVyI2FkZEV2ZW50TGlzdGVuZXJ9LlxuICpcbiAqIEB0ZW1wbGF0ZSBBUkcwLEFSRzFcbiAqIEBwYXJhbSB7RXZlbnRIYW5kbGVyPEFSRzAsQVJHMT59IGV2ZW50SGFuZGxlclxuICogQHBhcmFtIHtBUkcwfSBhcmcwXG4gKiBAcGFyYW0ge0FSRzF9IGFyZzFcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNhbGxFdmVudEhhbmRsZXJMaXN0ZW5lcnMgPSAoZXZlbnRIYW5kbGVyLCBhcmcwLCBhcmcxKSA9PlxuICBmLmNhbGxBbGwoZXZlbnRIYW5kbGVyLmwsIFthcmcwLCBhcmcxXSk7XG5cbmNsYXNzIElEIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnQgY2xpZW50IGlkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbG9jayB1bmlxdWUgcGVyIGNsaWVudCBpZCwgY29udGludW91cyBudW1iZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChjbGllbnQsIGNsb2NrKSB7XG4gICAgLyoqXG4gICAgICogQ2xpZW50IGlkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAvKipcbiAgICAgKiB1bmlxdWUgcGVyIGNsaWVudCBpZCwgY29udGludW91cyBudW1iZXJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuY2xvY2sgPSBjbG9jaztcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SUQgfCBudWxsfSBhXG4gKiBAcGFyYW0ge0lEIHwgbnVsbH0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY29tcGFyZUlEcyA9IChhLCBiKSA9PiBhID09PSBiIHx8IChhICE9PSBudWxsICYmIGIgIT09IG51bGwgJiYgYS5jbGllbnQgPT09IGIuY2xpZW50ICYmIGEuY2xvY2sgPT09IGIuY2xvY2spO1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlSUQgPSAoY2xpZW50LCBjbG9jaykgPT4gbmV3IElEKGNsaWVudCwgY2xvY2spO1xuXG4vKipcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtJRH0gaWRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlSUQgPSAoZW5jb2RlciwgaWQpID0+IHtcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGlkLmNsaWVudCk7XG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBpZC5jbG9jayk7XG59O1xuXG4vKipcbiAqIFJlYWQgSUQuXG4gKiAqIElmIGZpcnN0IHZhclVpbnQgcmVhZCBpcyAweEZGRkZGRiBhIFJvb3RJRCBpcyByZXR1cm5lZC5cbiAqICogT3RoZXJ3aXNlIGFuIElEIGlzIHJldHVybmVkXG4gKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtJRH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRJRCA9IGRlY29kZXIgPT5cbiAgY3JlYXRlSUQoZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlciksIGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpKTtcblxuLyoqXG4gKiBUaGUgdG9wIHR5cGVzIGFyZSBtYXBwZWQgZnJvbSB5LnNoYXJlLmdldChrZXluYW1lKSA9PiB0eXBlLlxuICogYHR5cGVgIGRvZXMgbm90IHN0b3JlIGFueSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYGtleW5hbWVgLlxuICogVGhpcyBmdW5jdGlvbiBmaW5kcyB0aGUgY29ycmVjdCBga2V5bmFtZWAgZm9yIGB0eXBlYCBhbmQgdGhyb3dzIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmaW5kUm9vdFR5cGVLZXkgPSB0eXBlID0+IHtcbiAgLy8gQHRzLWlnbm9yZSBfeSBtdXN0IGJlIGRlZmluZWQsIG90aGVyd2lzZSB1bmV4cGVjdGVkIGNhc2VcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdHlwZS5kb2Muc2hhcmUuZW50cmllcygpKSB7XG4gICAgaWYgKHZhbHVlID09PSB0eXBlKSB7XG4gICAgICByZXR1cm4ga2V5XG4gICAgfVxuICB9XG4gIHRocm93IGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYHBhcmVudGAgaXMgYSBwYXJlbnQgb2YgYGNoaWxkYC5cbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7SXRlbXxudWxsfSBjaGlsZFxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciBgcGFyZW50YCBpcyBhIHBhcmVudCBvZiBgY2hpbGRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgaXNQYXJlbnRPZiA9IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIGlmIChjaGlsZC5wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgY2hpbGQgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoY2hpbGQucGFyZW50KS5faXRlbTtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8qKlxuICogQ29udmVuaWVudCBoZWxwZXIgdG8gbG9nIHR5cGUgaW5mb3JtYXRpb24uXG4gKlxuICogRG8gbm90IHVzZSBpbiBwcm9kdWN0aXZlIHN5c3RlbXMgYXMgdGhlIG91dHB1dCBjYW4gYmUgaW1tZW5zZSFcbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKi9cbmNvbnN0IGxvZ1R5cGUgPSB0eXBlID0+IHtcbiAgY29uc3QgcmVzID0gW107XG4gIGxldCBuID0gdHlwZS5fc3RhcnQ7XG4gIHdoaWxlIChuKSB7XG4gICAgcmVzLnB1c2gobik7XG4gICAgbiA9IG4ucmlnaHQ7XG4gIH1cbiAgY29uc29sZS5sb2coJ0NoaWxkcmVuOiAnLCByZXMpO1xuICBjb25zb2xlLmxvZygnQ2hpbGRyZW4gY29udGVudDogJywgcmVzLmZpbHRlcihtID0+ICFtLmRlbGV0ZWQpLm1hcChtID0+IG0uY29udGVudCkpO1xufTtcblxuY2xhc3MgUGVybWFuZW50VXNlckRhdGEge1xuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IGRvY1xuICAgKiBAcGFyYW0ge1lNYXA8YW55Pn0gW3N0b3JlVHlwZV1cbiAgICovXG4gIGNvbnN0cnVjdG9yIChkb2MsIHN0b3JlVHlwZSA9IGRvYy5nZXRNYXAoJ3VzZXJzJykpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZyxEZWxldGVTZXQ+fVxuICAgICAqL1xuICAgIGNvbnN0IGRzcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnl1c2VycyA9IHN0b3JlVHlwZTtcbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAvKipcbiAgICAgKiBNYXBzIGZyb20gY2xpZW50aWQgdG8gdXNlckRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlcixzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmRzcyA9IGRzcztcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1lNYXA8YW55Pn0gdXNlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyRGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBjb25zdCBpbml0VXNlciA9ICh1c2VyLCB1c2VyRGVzY3JpcHRpb24pID0+IHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge1lBcnJheTxVaW50OEFycmF5Pn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgZHMgPSB1c2VyLmdldCgnZHMnKTtcbiAgICAgIGNvbnN0IGlkcyA9IHVzZXIuZ2V0KCdpZHMnKTtcbiAgICAgIGNvbnN0IGFkZENsaWVudElkID0gLyoqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRpZCAqLyBjbGllbnRpZCA9PiB0aGlzLmNsaWVudHMuc2V0KGNsaWVudGlkLCB1c2VyRGVzY3JpcHRpb24pO1xuICAgICAgZHMub2JzZXJ2ZSgvKiogQHBhcmFtIHtZQXJyYXlFdmVudDxhbnk+fSBldmVudCAqLyBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LmNoYW5nZXMuYWRkZWQuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICBpdGVtLmNvbnRlbnQuZ2V0Q29udGVudCgpLmZvckVhY2goZW5jb2RlZERzID0+IHtcbiAgICAgICAgICAgIGlmIChlbmNvZGVkRHMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgIHRoaXMuZHNzLnNldCh1c2VyRGVzY3JpcHRpb24sIG1lcmdlRGVsZXRlU2V0cyhbdGhpcy5kc3MuZ2V0KHVzZXJEZXNjcmlwdGlvbikgfHwgY3JlYXRlRGVsZXRlU2V0KCksIHJlYWREZWxldGVTZXQobmV3IERTRGVjb2RlclYxKGRlY29kaW5nLmNyZWF0ZURlY29kZXIoZW5jb2RlZERzKSkpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kc3Muc2V0KHVzZXJEZXNjcmlwdGlvbiwgbWVyZ2VEZWxldGVTZXRzKGRzLm1hcChlbmNvZGVkRHMgPT4gcmVhZERlbGV0ZVNldChuZXcgRFNEZWNvZGVyVjEoZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihlbmNvZGVkRHMpKSkpKSk7XG4gICAgICBpZHMub2JzZXJ2ZSgvKiogQHBhcmFtIHtZQXJyYXlFdmVudDxhbnk+fSBldmVudCAqLyBldmVudCA9PlxuICAgICAgICBldmVudC5jaGFuZ2VzLmFkZGVkLmZvckVhY2goaXRlbSA9PiBpdGVtLmNvbnRlbnQuZ2V0Q29udGVudCgpLmZvckVhY2goYWRkQ2xpZW50SWQpKVxuICAgICAgKTtcbiAgICAgIGlkcy5mb3JFYWNoKGFkZENsaWVudElkKTtcbiAgICB9O1xuICAgIC8vIG9ic2VydmUgdXNlcnNcbiAgICBzdG9yZVR5cGUub2JzZXJ2ZShldmVudCA9PiB7XG4gICAgICBldmVudC5rZXlzQ2hhbmdlZC5mb3JFYWNoKHVzZXJEZXNjcmlwdGlvbiA9PlxuICAgICAgICBpbml0VXNlcihzdG9yZVR5cGUuZ2V0KHVzZXJEZXNjcmlwdGlvbiksIHVzZXJEZXNjcmlwdGlvbilcbiAgICAgICk7XG4gICAgfSk7XG4gICAgLy8gYWRkIGluaXRpYWwgZGF0YVxuICAgIHN0b3JlVHlwZS5mb3JFYWNoKGluaXRVc2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30gZG9jXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlckRlc2NyaXB0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25mXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVHJhbnNhY3Rpb24sIERlbGV0ZVNldCk6Ym9vbGVhbn0gW2NvbmYuZmlsdGVyXVxuICAgKi9cbiAgc2V0VXNlck1hcHBpbmcgKGRvYywgY2xpZW50aWQsIHVzZXJEZXNjcmlwdGlvbiwgeyBmaWx0ZXIgPSAoKSA9PiB0cnVlIH0gPSB7fSkge1xuICAgIGNvbnN0IHVzZXJzID0gdGhpcy55dXNlcnM7XG4gICAgbGV0IHVzZXIgPSB1c2Vycy5nZXQodXNlckRlc2NyaXB0aW9uKTtcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHVzZXIgPSBuZXcgWU1hcCgpO1xuICAgICAgdXNlci5zZXQoJ2lkcycsIG5ldyBZQXJyYXkoKSk7XG4gICAgICB1c2VyLnNldCgnZHMnLCBuZXcgWUFycmF5KCkpO1xuICAgICAgdXNlcnMuc2V0KHVzZXJEZXNjcmlwdGlvbiwgdXNlcik7XG4gICAgfVxuICAgIHVzZXIuZ2V0KCdpZHMnKS5wdXNoKFtjbGllbnRpZF0pO1xuICAgIHVzZXJzLm9ic2VydmUoX2V2ZW50ID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCB1c2VyT3ZlcndyaXRlID0gdXNlcnMuZ2V0KHVzZXJEZXNjcmlwdGlvbik7XG4gICAgICAgIGlmICh1c2VyT3ZlcndyaXRlICE9PSB1c2VyKSB7XG4gICAgICAgICAgLy8gdXNlciB3YXMgb3ZlcndyaXR0ZW4sIHBvcnQgYWxsIGRhdGEgb3ZlciB0byB0aGUgbmV4dCB1c2VyIG9iamVjdFxuICAgICAgICAgIC8vIEB0b2RvIEV4cGVyaW1lbnQgd2l0aCBZLlNldHMgaGVyZVxuICAgICAgICAgIHVzZXIgPSB1c2VyT3ZlcndyaXRlO1xuICAgICAgICAgIC8vIEB0b2RvIGl0ZXJhdGUgb3ZlciBvbGQgdHlwZVxuICAgICAgICAgIHRoaXMuY2xpZW50cy5mb3JFYWNoKChfdXNlckRlc2NyaXB0aW9uLCBjbGllbnRpZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHVzZXJEZXNjcmlwdGlvbiA9PT0gX3VzZXJEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICB1c2VyLmdldCgnaWRzJykucHVzaChbY2xpZW50aWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IERTRW5jb2RlclYxKCk7XG4gICAgICAgICAgY29uc3QgZHMgPSB0aGlzLmRzcy5nZXQodXNlckRlc2NyaXB0aW9uKTtcbiAgICAgICAgICBpZiAoZHMpIHtcbiAgICAgICAgICAgIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIGRzKTtcbiAgICAgICAgICAgIHVzZXIuZ2V0KCdkcycpLnB1c2goW2VuY29kZXIudG9VaW50OEFycmF5KCldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH0pO1xuICAgIGRvYy5vbignYWZ0ZXJUcmFuc2FjdGlvbicsIC8qKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbiAqLyB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgeWRzID0gdXNlci5nZXQoJ2RzJyk7XG4gICAgICAgIGNvbnN0IGRzID0gdHJhbnNhY3Rpb24uZGVsZXRlU2V0O1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24ubG9jYWwgJiYgZHMuY2xpZW50cy5zaXplID4gMCAmJiBmaWx0ZXIodHJhbnNhY3Rpb24sIGRzKSkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgRFNFbmNvZGVyVjEoKTtcbiAgICAgICAgICB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCBkcyk7XG4gICAgICAgICAgeWRzLnB1c2goW2VuY29kZXIudG9VaW50OEFycmF5KCldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudGlkXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIGdldFVzZXJCeUNsaWVudElkIChjbGllbnRpZCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudHMuZ2V0KGNsaWVudGlkKSB8fCBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICogQHJldHVybiB7c3RyaW5nIHwgbnVsbH1cbiAgICovXG4gIGdldFVzZXJCeURlbGV0ZWRJZCAoaWQpIHtcbiAgICBmb3IgKGNvbnN0IFt1c2VyRGVzY3JpcHRpb24sIGRzXSBvZiB0aGlzLmRzcy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChpc0RlbGV0ZWQoZHMsIGlkKSkge1xuICAgICAgICByZXR1cm4gdXNlckRlc2NyaXB0aW9uXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuLyoqXG4gKiBBIHJlbGF0aXZlIHBvc2l0aW9uIGlzIGJhc2VkIG9uIHRoZSBZanMgbW9kZWwgYW5kIGlzIG5vdCBhZmZlY3RlZCBieSBkb2N1bWVudCBjaGFuZ2VzLlxuICogRS5nLiBJZiB5b3UgcGxhY2UgYSByZWxhdGl2ZSBwb3NpdGlvbiBiZWZvcmUgYSBjZXJ0YWluIGNoYXJhY3RlciwgaXQgd2lsbCBhbHdheXMgcG9pbnQgdG8gdGhpcyBjaGFyYWN0ZXIuXG4gKiBJZiB5b3UgcGxhY2UgYSByZWxhdGl2ZSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIGEgdHlwZSwgaXQgd2lsbCBhbHdheXMgcG9pbnQgdG8gdGhlIGVuZCBvZiB0aGUgdHlwZS5cbiAqXG4gKiBBIG51bWVyaWMgcG9zaXRpb24gaXMgb2Z0ZW4gdW5zdWl0ZWQgZm9yIHVzZXIgc2VsZWN0aW9ucywgYmVjYXVzZSBpdCBkb2VzIG5vdCBjaGFuZ2Ugd2hlbiBjb250ZW50IGlzIGluc2VydGVkXG4gKiBiZWZvcmUgb3IgYWZ0ZXIuXG4gKlxuICogYGBgSW5zZXJ0KDAsICd4JykoJ2F8YmMnKSA9ICd4YXxiYydgYGAgV2hlcmUgfCBpcyB0aGUgcmVsYXRpdmUgcG9zaXRpb24uXG4gKlxuICogT25lIG9mIHRoZSBwcm9wZXJ0aWVzIG11c3QgYmUgZGVmaW5lZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAvLyBDdXJyZW50IGN1cnNvciBwb3NpdGlvbiBpcyBhdCBwb3NpdGlvbiAxMFxuICogICBjb25zdCByZWxhdGl2ZVBvc2l0aW9uID0gY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21JbmRleCh5VGV4dCwgMTApXG4gKiAgIC8vIG1vZGlmeSB5VGV4dFxuICogICB5VGV4dC5pbnNlcnQoMCwgJ2FiYycpXG4gKiAgIHlUZXh0LmRlbGV0ZSgzLCAxMClcbiAqICAgLy8gQ29tcHV0ZSB0aGUgY3Vyc29yIHBvc2l0aW9uXG4gKiAgIGNvbnN0IGFic29sdXRlUG9zaXRpb24gPSBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24oeSwgcmVsYXRpdmVQb3NpdGlvbilcbiAqICAgYWJzb2x1dGVQb3NpdGlvbi50eXBlID09PSB5VGV4dCAvLyA9PiB0cnVlXG4gKiAgIGNvbnNvbGUubG9nKCdjdXJzb3IgbG9jYXRpb24gaXMgJyArIGFic29sdXRlUG9zaXRpb24uaW5kZXgpIC8vID0+IGN1cnNvciBsb2NhdGlvbiBpcyAzXG4gKlxuICovXG5jbGFzcyBSZWxhdGl2ZVBvc2l0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR8bnVsbH0gdHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSB0bmFtZVxuICAgKiBAcGFyYW0ge0lEfG51bGx9IGl0ZW1cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFzc29jXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodHlwZSwgdG5hbWUsIGl0ZW0sIGFzc29jID0gMCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJRHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMudG5hbWUgPSB0bmFtZTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SUQgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMuaXRlbSA9IGl0ZW07XG4gICAgLyoqXG4gICAgICogQSByZWxhdGl2ZSBwb3NpdGlvbiBpcyBhc3NvY2lhdGVkIHRvIGEgc3BlY2lmaWMgY2hhcmFjdGVyLiBCeSBkZWZhdWx0XG4gICAgICogYXNzb2MgPj0gMCwgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGlzIGFzc29jaWF0ZWQgdG8gdGhlIGNoYXJhY3RlclxuICAgICAqIGFmdGVyIHRoZSBtZWFudCBwb3NpdGlvbi5cbiAgICAgKiBJLmUuIHBvc2l0aW9uIDEgaW4gJ2FiJyBpcyBhc3NvY2lhdGVkIHRvIGNoYXJhY3RlciAnYicuXG4gICAgICpcbiAgICAgKiBJZiBhc3NvYyA8IDAsIHRoZW4gdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGlzIGFzc29jaWF0ZWQgdG8gdGhlIGNoYXJhY3RlclxuICAgICAqIGJlZm9yZSB0aGUgbWVhbnQgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuYXNzb2MgPSBhc3NvYztcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVsYXRpdmVQb3NpdGlvbn0gcnBvc1xuICogQHJldHVybiB7YW55fVxuICovXG5jb25zdCByZWxhdGl2ZVBvc2l0aW9uVG9KU09OID0gcnBvcyA9PiB7XG4gIGNvbnN0IGpzb24gPSB7fTtcbiAgaWYgKHJwb3MudHlwZSkge1xuICAgIGpzb24udHlwZSA9IHJwb3MudHlwZTtcbiAgfVxuICBpZiAocnBvcy50bmFtZSkge1xuICAgIGpzb24udG5hbWUgPSBycG9zLnRuYW1lO1xuICB9XG4gIGlmIChycG9zLml0ZW0pIHtcbiAgICBqc29uLml0ZW0gPSBycG9zLml0ZW07XG4gIH1cbiAgaWYgKHJwb3MuYXNzb2MgIT0gbnVsbCkge1xuICAgIGpzb24uYXNzb2MgPSBycG9zLmFzc29jO1xuICB9XG4gIHJldHVybiBqc29uXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBqc29uXG4gKiBAcmV0dXJuIHtSZWxhdGl2ZVBvc2l0aW9ufVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04gPSBqc29uID0+IG5ldyBSZWxhdGl2ZVBvc2l0aW9uKGpzb24udHlwZSA9PSBudWxsID8gbnVsbCA6IGNyZWF0ZUlEKGpzb24udHlwZS5jbGllbnQsIGpzb24udHlwZS5jbG9jayksIGpzb24udG5hbWUgPz8gbnVsbCwganNvbi5pdGVtID09IG51bGwgPyBudWxsIDogY3JlYXRlSUQoanNvbi5pdGVtLmNsaWVudCwganNvbi5pdGVtLmNsb2NrKSwganNvbi5hc3NvYyA9PSBudWxsID8gMCA6IGpzb24uYXNzb2MpO1xuXG5jbGFzcyBBYnNvbHV0ZVBvc2l0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYXNzb2NdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodHlwZSwgaW5kZXgsIGFzc29jID0gMCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuYXNzb2MgPSBhc3NvYztcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFthc3NvY11cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlQWJzb2x1dGVQb3NpdGlvbiA9ICh0eXBlLCBpbmRleCwgYXNzb2MgPSAwKSA9PiBuZXcgQWJzb2x1dGVQb3NpdGlvbih0eXBlLCBpbmRleCwgYXNzb2MpO1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7SUR8bnVsbH0gaXRlbVxuICogQHBhcmFtIHtudW1iZXJ9IFthc3NvY11cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlUmVsYXRpdmVQb3NpdGlvbiA9ICh0eXBlLCBpdGVtLCBhc3NvYykgPT4ge1xuICBsZXQgdHlwZWlkID0gbnVsbDtcbiAgbGV0IHRuYW1lID0gbnVsbDtcbiAgaWYgKHR5cGUuX2l0ZW0gPT09IG51bGwpIHtcbiAgICB0bmFtZSA9IGZpbmRSb290VHlwZUtleSh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICB0eXBlaWQgPSBjcmVhdGVJRCh0eXBlLl9pdGVtLmlkLmNsaWVudCwgdHlwZS5faXRlbS5pZC5jbG9jayk7XG4gIH1cbiAgcmV0dXJuIG5ldyBSZWxhdGl2ZVBvc2l0aW9uKHR5cGVpZCwgdG5hbWUsIGl0ZW0sIGFzc29jKVxufTtcblxuLyoqXG4gKiBDcmVhdGUgYSByZWxhdGl2ZVBvc2l0aW9uIGJhc2VkIG9uIGEgYWJzb2x1dGUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZSBUaGUgYmFzZSB0eXBlIChlLmcuIFlUZXh0IG9yIFlBcnJheSkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGFic29sdXRlIHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFthc3NvY11cbiAqIEByZXR1cm4ge1JlbGF0aXZlUG9zaXRpb259XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4ID0gKHR5cGUsIGluZGV4LCBhc3NvYyA9IDApID0+IHtcbiAgbGV0IHQgPSB0eXBlLl9zdGFydDtcbiAgaWYgKGFzc29jIDwgMCkge1xuICAgIC8vIGFzc29jaWF0ZWQgdG8gdGhlIGxlZnQgY2hhcmFjdGVyIG9yIHRoZSBiZWdpbm5pbmcgb2YgYSB0eXBlLCBpbmNyZW1lbnQgaW5kZXggaWYgcG9zc2libGUuXG4gICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICByZXR1cm4gY3JlYXRlUmVsYXRpdmVQb3NpdGlvbih0eXBlLCBudWxsLCBhc3NvYylcbiAgICB9XG4gICAgaW5kZXgtLTtcbiAgfVxuICB3aGlsZSAodCAhPT0gbnVsbCkge1xuICAgIGlmICghdC5kZWxldGVkICYmIHQuY291bnRhYmxlKSB7XG4gICAgICBpZiAodC5sZW5ndGggPiBpbmRleCkge1xuICAgICAgICAvLyBjYXNlIDE6IGZvdW5kIHBvc2l0aW9uIHNvbWV3aGVyZSBpbiB0aGUgbGlua2VkIGxpc3RcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24odHlwZSwgY3JlYXRlSUQodC5pZC5jbGllbnQsIHQuaWQuY2xvY2sgKyBpbmRleCksIGFzc29jKVxuICAgICAgfVxuICAgICAgaW5kZXggLT0gdC5sZW5ndGg7XG4gICAgfVxuICAgIGlmICh0LnJpZ2h0ID09PSBudWxsICYmIGFzc29jIDwgMCkge1xuICAgICAgLy8gbGVmdC1hc3NvY2lhdGVkIHBvc2l0aW9uLCByZXR1cm4gbGFzdCBhdmFpbGFibGUgaWRcbiAgICAgIHJldHVybiBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uKHR5cGUsIHQubGFzdElkLCBhc3NvYylcbiAgICB9XG4gICAgdCA9IHQucmlnaHQ7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24odHlwZSwgbnVsbCwgYXNzb2MpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtSZWxhdGl2ZVBvc2l0aW9ufSBycG9zXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlUmVsYXRpdmVQb3NpdGlvbiA9IChlbmNvZGVyLCBycG9zKSA9PiB7XG4gIGNvbnN0IHsgdHlwZSwgdG5hbWUsIGl0ZW0sIGFzc29jIH0gPSBycG9zO1xuICBpZiAoaXRlbSAhPT0gbnVsbCkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCAwKTtcbiAgICB3cml0ZUlEKGVuY29kZXIsIGl0ZW0pO1xuICB9IGVsc2UgaWYgKHRuYW1lICE9PSBudWxsKSB7XG4gICAgLy8gY2FzZSAyOiBmb3VuZCBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCB0eXBlIGlzIHN0b3JlZCBpbiB5LnNoYXJlXG4gICAgZW5jb2Rpbmcud3JpdGVVaW50OChlbmNvZGVyLCAxKTtcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCB0bmFtZSk7XG4gIH0gZWxzZSBpZiAodHlwZSAhPT0gbnVsbCkge1xuICAgIC8vIGNhc2UgMzogZm91bmQgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdHlwZSBpcyBhdHRhY2hlZCB0byBhbiBpdGVtXG4gICAgZW5jb2Rpbmcud3JpdGVVaW50OChlbmNvZGVyLCAyKTtcbiAgICB3cml0ZUlEKGVuY29kZXIsIHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbiAgfVxuICBlbmNvZGluZy53cml0ZVZhckludChlbmNvZGVyLCBhc3NvYyk7XG4gIHJldHVybiBlbmNvZGVyXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7UmVsYXRpdmVQb3NpdGlvbn0gcnBvc1xuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZW5jb2RlUmVsYXRpdmVQb3NpdGlvbiA9IHJwb3MgPT4ge1xuICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpO1xuICB3cml0ZVJlbGF0aXZlUG9zaXRpb24oZW5jb2RlciwgcnBvcyk7XG4gIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2Rlcilcbn07XG5cbi8qKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtSZWxhdGl2ZVBvc2l0aW9ufVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkUmVsYXRpdmVQb3NpdGlvbiA9IGRlY29kZXIgPT4ge1xuICBsZXQgdHlwZSA9IG51bGw7XG4gIGxldCB0bmFtZSA9IG51bGw7XG4gIGxldCBpdGVtSUQgPSBudWxsO1xuICBzd2l0Y2ggKGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpKSB7XG4gICAgY2FzZSAwOlxuICAgICAgLy8gY2FzZSAxOiBmb3VuZCBwb3NpdGlvbiBzb21ld2hlcmUgaW4gdGhlIGxpbmtlZCBsaXN0XG4gICAgICBpdGVtSUQgPSByZWFkSUQoZGVjb2Rlcik7XG4gICAgICBicmVha1xuICAgIGNhc2UgMTpcbiAgICAgIC8vIGNhc2UgMjogZm91bmQgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdHlwZSBpcyBzdG9yZWQgaW4geS5zaGFyZVxuICAgICAgdG5hbWUgPSBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIDI6IHtcbiAgICAgIC8vIGNhc2UgMzogZm91bmQgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdHlwZSBpcyBhdHRhY2hlZCB0byBhbiBpdGVtXG4gICAgICB0eXBlID0gcmVhZElEKGRlY29kZXIpO1xuICAgIH1cbiAgfVxuICBjb25zdCBhc3NvYyA9IGRlY29kaW5nLmhhc0NvbnRlbnQoZGVjb2RlcikgPyBkZWNvZGluZy5yZWFkVmFySW50KGRlY29kZXIpIDogMDtcbiAgcmV0dXJuIG5ldyBSZWxhdGl2ZVBvc2l0aW9uKHR5cGUsIHRuYW1lLCBpdGVtSUQsIGFzc29jKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAqIEByZXR1cm4ge1JlbGF0aXZlUG9zaXRpb259XG4gKi9cbmNvbnN0IGRlY29kZVJlbGF0aXZlUG9zaXRpb24gPSB1aW50OEFycmF5ID0+IHJlYWRSZWxhdGl2ZVBvc2l0aW9uKGRlY29kaW5nLmNyZWF0ZURlY29kZXIodWludDhBcnJheSkpO1xuXG4vKipcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEfSBpZFxuICovXG5jb25zdCBnZXRJdGVtV2l0aE9mZnNldCA9IChzdG9yZSwgaWQpID0+IHtcbiAgY29uc3QgaXRlbSA9IGdldEl0ZW0oc3RvcmUsIGlkKTtcbiAgY29uc3QgZGlmZiA9IGlkLmNsb2NrIC0gaXRlbS5pZC5jbG9jaztcbiAgcmV0dXJuIHtcbiAgICBpdGVtLCBkaWZmXG4gIH1cbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcmVsYXRpdmUgcG9zaXRpb24gdG8gYW4gYWJzb2x1dGUgcG9zaXRpb24uXG4gKlxuICogSWYgeW91IHdhbnQgdG8gc2hhcmUgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIHdpdGggb3RoZXIgdXNlcnMsIHlvdSBzaG91bGQgc2V0XG4gKiBgZm9sbG93VW5kb25lRGVsZXRpb25zYCB0byBmYWxzZSB0byBnZXQgY29uc2lzdGVudCByZXN1bHRzIGFjcm9zcyBhbGwgY2xpZW50cy5cbiAqXG4gKiBXaGVuIGNhbGN1bGF0aW5nIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiwgd2UgdHJ5IHRvIGZvbGxvdyB0aGUgXCJ1bmRvbmUgZGVsZXRpb25zXCIuIFRoaXMgeWllbGRzXG4gKiBiZXR0ZXIgcmVzdWx0cyBmb3IgdGhlIHVzZXIgd2hvIHBlcmZvcm1lZCB1bmRvLiBIb3dldmVyLCBvbmx5IHRoZSB1c2VyIHdobyBwZXJmb3JtZWQgdGhlIHVuZG9cbiAqIHdpbGwgZ2V0IHRoZSBiZXR0ZXIgcmVzdWx0cywgdGhlIG90aGVyIHVzZXJzIGRvbid0IGtub3cgd2hpY2ggb3BlcmF0aW9ucyByZWNyZWF0ZWQgYSBkZWxldGVkXG4gKiByYW5nZSBvZiBjb250ZW50LiBUaGVyZSBpcyBtb3JlIGluZm9ybWF0aW9uIGluIHRoaXMgdGlja2V0OiBodHRwczovL2dpdGh1Yi5jb20veWpzL3lqcy9pc3N1ZXMvNjM4XG4gKlxuICogQHBhcmFtIHtSZWxhdGl2ZVBvc2l0aW9ufSBycG9zXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZvbGxvd1VuZG9uZURlbGV0aW9ucyAtIHdoZXRoZXIgdG8gZm9sbG93IHVuZG9uZSBkZWxldGlvbnMgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3lqcy95anMvaXNzdWVzLzYzOFxuICogQHJldHVybiB7QWJzb2x1dGVQb3NpdGlvbnxudWxsfVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24gPSAocnBvcywgZG9jLCBmb2xsb3dVbmRvbmVEZWxldGlvbnMgPSB0cnVlKSA9PiB7XG4gIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlO1xuICBjb25zdCByaWdodElEID0gcnBvcy5pdGVtO1xuICBjb25zdCB0eXBlSUQgPSBycG9zLnR5cGU7XG4gIGNvbnN0IHRuYW1lID0gcnBvcy50bmFtZTtcbiAgY29uc3QgYXNzb2MgPSBycG9zLmFzc29jO1xuICBsZXQgdHlwZSA9IG51bGw7XG4gIGxldCBpbmRleCA9IDA7XG4gIGlmIChyaWdodElEICE9PSBudWxsKSB7XG4gICAgaWYgKGdldFN0YXRlKHN0b3JlLCByaWdodElELmNsaWVudCkgPD0gcmlnaHRJRC5jbG9jaykge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgY29uc3QgcmVzID0gZm9sbG93VW5kb25lRGVsZXRpb25zID8gZm9sbG93UmVkb25lKHN0b3JlLCByaWdodElEKSA6IGdldEl0ZW1XaXRoT2Zmc2V0KHN0b3JlLCByaWdodElEKTtcbiAgICBjb25zdCByaWdodCA9IHJlcy5pdGVtO1xuICAgIGlmICghKHJpZ2h0IGluc3RhbmNlb2YgSXRlbSkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHR5cGUgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHQucGFyZW50KTtcbiAgICBpZiAodHlwZS5faXRlbSA9PT0gbnVsbCB8fCAhdHlwZS5faXRlbS5kZWxldGVkKSB7XG4gICAgICBpbmRleCA9IChyaWdodC5kZWxldGVkIHx8ICFyaWdodC5jb3VudGFibGUpID8gMCA6IChyZXMuZGlmZiArIChhc3NvYyA+PSAwID8gMCA6IDEpKTsgLy8gYWRqdXN0IHBvc2l0aW9uIGJhc2VkIG9uIGxlZnQgYXNzb2NpYXRpb24gaWYgbmVjZXNzYXJ5XG4gICAgICBsZXQgbiA9IHJpZ2h0LmxlZnQ7XG4gICAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIW4uZGVsZXRlZCAmJiBuLmNvdW50YWJsZSkge1xuICAgICAgICAgIGluZGV4ICs9IG4ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuLmxlZnQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0bmFtZSAhPT0gbnVsbCkge1xuICAgICAgdHlwZSA9IGRvYy5nZXQodG5hbWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZUlEICE9PSBudWxsKSB7XG4gICAgICBpZiAoZ2V0U3RhdGUoc3RvcmUsIHR5cGVJRC5jbGllbnQpIDw9IHR5cGVJRC5jbG9jaykge1xuICAgICAgICAvLyB0eXBlIGRvZXMgbm90IGV4aXN0IHlldFxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgY29uc3QgeyBpdGVtIH0gPSBmb2xsb3dVbmRvbmVEZWxldGlvbnMgPyBmb2xsb3dSZWRvbmUoc3RvcmUsIHR5cGVJRCkgOiB7IGl0ZW06IGdldEl0ZW0oc3RvcmUsIHR5cGVJRCkgfTtcbiAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgSXRlbSAmJiBpdGVtLmNvbnRlbnQgaW5zdGFuY2VvZiBDb250ZW50VHlwZSkge1xuICAgICAgICB0eXBlID0gaXRlbS5jb250ZW50LnR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzdHJ1Y3QgaXMgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICAgIH1cbiAgICBpZiAoYXNzb2MgPj0gMCkge1xuICAgICAgaW5kZXggPSB0eXBlLl9sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4ID0gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUFic29sdXRlUG9zaXRpb24odHlwZSwgaW5kZXgsIHJwb3MuYXNzb2MpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7UmVsYXRpdmVQb3NpdGlvbnxudWxsfSBhXG4gKiBAcGFyYW0ge1JlbGF0aXZlUG9zaXRpb258bnVsbH0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY29tcGFyZVJlbGF0aXZlUG9zaXRpb25zID0gKGEsIGIpID0+IGEgPT09IGIgfHwgKFxuICBhICE9PSBudWxsICYmIGIgIT09IG51bGwgJiYgYS50bmFtZSA9PT0gYi50bmFtZSAmJiBjb21wYXJlSURzKGEuaXRlbSwgYi5pdGVtKSAmJiBjb21wYXJlSURzKGEudHlwZSwgYi50eXBlKSAmJiBhLmFzc29jID09PSBiLmFzc29jXG4pO1xuXG5jbGFzcyBTbmFwc2hvdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAgICogQHBhcmFtIHtNYXA8bnVtYmVyLG51bWJlcj59IHN2IHN0YXRlIG1hcFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRzLCBzdikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtEZWxldGVTZXR9XG4gICAgICovXG4gICAgdGhpcy5kcyA9IGRzO1xuICAgIC8qKlxuICAgICAqIFN0YXRlIE1hcFxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5zdiA9IHN2O1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcDFcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXAyXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBlcXVhbFNuYXBzaG90cyA9IChzbmFwMSwgc25hcDIpID0+IHtcbiAgY29uc3QgZHMxID0gc25hcDEuZHMuY2xpZW50cztcbiAgY29uc3QgZHMyID0gc25hcDIuZHMuY2xpZW50cztcbiAgY29uc3Qgc3YxID0gc25hcDEuc3Y7XG4gIGNvbnN0IHN2MiA9IHNuYXAyLnN2O1xuICBpZiAoc3YxLnNpemUgIT09IHN2Mi5zaXplIHx8IGRzMS5zaXplICE9PSBkczIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHN2MS5lbnRyaWVzKCkpIHtcbiAgICBpZiAoc3YyLmdldChrZXkpICE9PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgW2NsaWVudCwgZHNpdGVtczFdIG9mIGRzMS5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCBkc2l0ZW1zMiA9IGRzMi5nZXQoY2xpZW50KSB8fCBbXTtcbiAgICBpZiAoZHNpdGVtczEubGVuZ3RoICE9PSBkc2l0ZW1zMi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRzaXRlbXMxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBkc2l0ZW0xID0gZHNpdGVtczFbaV07XG4gICAgICBjb25zdCBkc2l0ZW0yID0gZHNpdGVtczJbaV07XG4gICAgICBpZiAoZHNpdGVtMS5jbG9jayAhPT0gZHNpdGVtMi5jbG9jayB8fCBkc2l0ZW0xLmxlbiAhPT0gZHNpdGVtMi5sZW4pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXBzaG90XG4gKiBAcGFyYW0ge0RTRW5jb2RlclYxIHwgRFNFbmNvZGVyVjJ9IFtlbmNvZGVyXVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZW5jb2RlU25hcHNob3RWMiA9IChzbmFwc2hvdCwgZW5jb2RlciA9IG5ldyBEU0VuY29kZXJWMigpKSA9PiB7XG4gIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIHNuYXBzaG90LmRzKTtcbiAgd3JpdGVTdGF0ZVZlY3RvcihlbmNvZGVyLCBzbmFwc2hvdC5zdik7XG4gIHJldHVybiBlbmNvZGVyLnRvVWludDhBcnJheSgpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXBzaG90XG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBlbmNvZGVTbmFwc2hvdCA9IHNuYXBzaG90ID0+IGVuY29kZVNuYXBzaG90VjIoc25hcHNob3QsIG5ldyBEU0VuY29kZXJWMSgpKTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHBhcmFtIHtEU0RlY29kZXJWMSB8IERTRGVjb2RlclYyfSBbZGVjb2Rlcl1cbiAqIEByZXR1cm4ge1NuYXBzaG90fVxuICovXG5jb25zdCBkZWNvZGVTbmFwc2hvdFYyID0gKGJ1ZiwgZGVjb2RlciA9IG5ldyBEU0RlY29kZXJWMihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZikpKSA9PiB7XG4gIHJldHVybiBuZXcgU25hcHNob3QocmVhZERlbGV0ZVNldChkZWNvZGVyKSwgcmVhZFN0YXRlVmVjdG9yKGRlY29kZXIpKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybiB7U25hcHNob3R9XG4gKi9cbmNvbnN0IGRlY29kZVNuYXBzaG90ID0gYnVmID0+IGRlY29kZVNuYXBzaG90VjIoYnVmLCBuZXcgRFNEZWNvZGVyVjEoZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihidWYpKSk7XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge01hcDxudW1iZXIsbnVtYmVyPn0gc21cbiAqIEByZXR1cm4ge1NuYXBzaG90fVxuICovXG5jb25zdCBjcmVhdGVTbmFwc2hvdCA9IChkcywgc20pID0+IG5ldyBTbmFwc2hvdChkcywgc20pO1xuXG5jb25zdCBlbXB0eVNuYXBzaG90ID0gY3JlYXRlU25hcHNob3QoY3JlYXRlRGVsZXRlU2V0KCksIG5ldyBNYXAoKSk7XG5cbi8qKlxuICogQHBhcmFtIHtEb2N9IGRvY1xuICogQHJldHVybiB7U25hcHNob3R9XG4gKi9cbmNvbnN0IHNuYXBzaG90ID0gZG9jID0+IGNyZWF0ZVNuYXBzaG90KGNyZWF0ZURlbGV0ZVNldEZyb21TdHJ1Y3RTdG9yZShkb2Muc3RvcmUpLCBnZXRTdGF0ZVZlY3Rvcihkb2Muc3RvcmUpKTtcblxuLyoqXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7U25hcHNob3R8dW5kZWZpbmVkfSBzbmFwc2hvdFxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBpc1Zpc2libGUgPSAoaXRlbSwgc25hcHNob3QpID0+IHNuYXBzaG90ID09PSB1bmRlZmluZWRcbiAgPyAhaXRlbS5kZWxldGVkXG4gIDogc25hcHNob3Quc3YuaGFzKGl0ZW0uaWQuY2xpZW50KSAmJiAoc25hcHNob3Quc3YuZ2V0KGl0ZW0uaWQuY2xpZW50KSB8fCAwKSA+IGl0ZW0uaWQuY2xvY2sgJiYgIWlzRGVsZXRlZChzbmFwc2hvdC5kcywgaXRlbS5pZCk7XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXBzaG90XG4gKi9cbmNvbnN0IHNwbGl0U25hcHNob3RBZmZlY3RlZFN0cnVjdHMgPSAodHJhbnNhY3Rpb24sIHNuYXBzaG90KSA9PiB7XG4gIGNvbnN0IG1ldGEgPSBtYXAuc2V0SWZVbmRlZmluZWQodHJhbnNhY3Rpb24ubWV0YSwgc3BsaXRTbmFwc2hvdEFmZmVjdGVkU3RydWN0cywgc2V0LmNyZWF0ZSk7XG4gIGNvbnN0IHN0b3JlID0gdHJhbnNhY3Rpb24uZG9jLnN0b3JlO1xuICAvLyBjaGVjayBpZiB3ZSBhbHJlYWR5IHNwbGl0IGZvciB0aGlzIHNuYXBzaG90XG4gIGlmICghbWV0YS5oYXMoc25hcHNob3QpKSB7XG4gICAgc25hcHNob3Quc3YuZm9yRWFjaCgoY2xvY2ssIGNsaWVudCkgPT4ge1xuICAgICAgaWYgKGNsb2NrIDwgZ2V0U3RhdGUoc3RvcmUsIGNsaWVudCkpIHtcbiAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpdGVyYXRlRGVsZXRlZFN0cnVjdHModHJhbnNhY3Rpb24sIHNuYXBzaG90LmRzLCBfaXRlbSA9PiB7fSk7XG4gICAgbWV0YS5hZGQoc25hcHNob3QpO1xuICB9XG59O1xuXG4vKipcbiAqIEBleGFtcGxlXG4gKiAgY29uc3QgeWRvYyA9IG5ldyBZLkRvYyh7IGdjOiBmYWxzZSB9KVxuICogIHlkb2MuZ2V0VGV4dCgpLmluc2VydCgwLCAnd29ybGQhJylcbiAqICBjb25zdCBzbmFwc2hvdCA9IFkuc25hcHNob3QoeWRvYylcbiAqICB5ZG9jLmdldFRleHQoKS5pbnNlcnQoMCwgJ2hlbGxvICcpXG4gKiAgY29uc3QgcmVzdG9yZWQgPSBZLmNyZWF0ZURvY0Zyb21TbmFwc2hvdCh5ZG9jLCBzbmFwc2hvdClcbiAqICBhc3NlcnQocmVzdG9yZWQuZ2V0VGV4dCgpLnRvU3RyaW5nKCkgPT09ICd3b3JsZCEnKVxuICpcbiAqIEBwYXJhbSB7RG9jfSBvcmlnaW5Eb2NcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXBzaG90XG4gKiBAcGFyYW0ge0RvY30gW25ld0RvY10gT3B0aW9uYWxseSwgeW91IG1heSBkZWZpbmUgdGhlIFlqcyBkb2N1bWVudCB0aGF0IHJlY2VpdmVzIHRoZSBkYXRhIGZyb20gb3JpZ2luRG9jXG4gKiBAcmV0dXJuIHtEb2N9XG4gKi9cbmNvbnN0IGNyZWF0ZURvY0Zyb21TbmFwc2hvdCA9IChvcmlnaW5Eb2MsIHNuYXBzaG90LCBuZXdEb2MgPSBuZXcgRG9jKCkpID0+IHtcbiAgaWYgKG9yaWdpbkRvYy5nYykge1xuICAgIC8vIHdlIHNob3VsZCBub3QgdHJ5IHRvIHJlc3RvcmUgYSBHQy1lZCBkb2N1bWVudCwgYmVjYXVzZSBzb21lIG9mIHRoZSByZXN0b3JlZCBpdGVtcyBtaWdodCBoYXZlIHRoZWlyIGNvbnRlbnQgZGVsZXRlZFxuICAgIHRocm93IG5ldyBFcnJvcignR2FyYmFnZS1jb2xsZWN0aW9uIG11c3QgYmUgZGlzYWJsZWQgaW4gYG9yaWdpbkRvY2AhJylcbiAgfVxuICBjb25zdCB7IHN2LCBkcyB9ID0gc25hcHNob3Q7XG5cbiAgY29uc3QgZW5jb2RlciA9IG5ldyBVcGRhdGVFbmNvZGVyVjIoKTtcbiAgb3JpZ2luRG9jLnRyYW5zYWN0KHRyYW5zYWN0aW9uID0+IHtcbiAgICBsZXQgc2l6ZSA9IDA7XG4gICAgc3YuZm9yRWFjaChjbG9jayA9PiB7XG4gICAgICBpZiAoY2xvY2sgPiAwKSB7XG4gICAgICAgIHNpemUrKztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2Rlciwgc2l6ZSk7XG4gICAgLy8gc3BsaXR0aW5nIHRoZSBzdHJ1Y3RzIGJlZm9yZSB3cml0aW5nIHRoZW0gdG8gdGhlIGVuY29kZXJcbiAgICBmb3IgKGNvbnN0IFtjbGllbnQsIGNsb2NrXSBvZiBzdikge1xuICAgICAgaWYgKGNsb2NrID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBpZiAoY2xvY2sgPCBnZXRTdGF0ZShvcmlnaW5Eb2Muc3RvcmUsIGNsaWVudCkpIHtcbiAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0cnVjdHMgPSBvcmlnaW5Eb2Muc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSB8fCBbXTtcbiAgICAgIGNvbnN0IGxhc3RTdHJ1Y3RJbmRleCA9IGZpbmRJbmRleFNTKHN0cnVjdHMsIGNsb2NrIC0gMSk7XG4gICAgICAvLyB3cml0ZSAjIGVuY29kZWQgc3RydWN0c1xuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGxhc3RTdHJ1Y3RJbmRleCArIDEpO1xuICAgICAgZW5jb2Rlci53cml0ZUNsaWVudChjbGllbnQpO1xuICAgICAgLy8gZmlyc3QgY2xvY2sgd3JpdHRlbiBpcyAwXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgMCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBsYXN0U3RydWN0SW5kZXg7IGkrKykge1xuICAgICAgICBzdHJ1Y3RzW2ldLndyaXRlKGVuY29kZXIsIDApO1xuICAgICAgfVxuICAgIH1cbiAgICB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCBkcyk7XG4gIH0pO1xuXG4gIGFwcGx5VXBkYXRlVjIobmV3RG9jLCBlbmNvZGVyLnRvVWludDhBcnJheSgpLCAnc25hcHNob3QnKTtcbiAgcmV0dXJuIG5ld0RvY1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMiB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjF9IFtZRGVjb2Rlcl1cbiAqL1xuY29uc3Qgc25hcHNob3RDb250YWluc1VwZGF0ZVYyID0gKHNuYXBzaG90LCB1cGRhdGUsIFlEZWNvZGVyID0gVXBkYXRlRGVjb2RlclYyKSA9PiB7XG4gIGNvbnN0IHVwZGF0ZURlY29kZXIgPSBuZXcgWURlY29kZXIoZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpKTtcbiAgY29uc3QgbGF6eURlY29kZXIgPSBuZXcgTGF6eVN0cnVjdFJlYWRlcih1cGRhdGVEZWNvZGVyLCBmYWxzZSk7XG4gIGZvciAobGV0IGN1cnIgPSBsYXp5RGVjb2Rlci5jdXJyOyBjdXJyICE9PSBudWxsOyBjdXJyID0gbGF6eURlY29kZXIubmV4dCgpKSB7XG4gICAgaWYgKChzbmFwc2hvdC5zdi5nZXQoY3Vyci5pZC5jbGllbnQpIHx8IDApIDwgY3Vyci5pZC5jbG9jayArIGN1cnIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgY29uc3QgbWVyZ2VkRFMgPSBtZXJnZURlbGV0ZVNldHMoW3NuYXBzaG90LmRzLCByZWFkRGVsZXRlU2V0KHVwZGF0ZURlY29kZXIpXSk7XG4gIHJldHVybiBlcXVhbERlbGV0ZVNldHMoc25hcHNob3QuZHMsIG1lcmdlZERTKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqL1xuY29uc3Qgc25hcHNob3RDb250YWluc1VwZGF0ZSA9IChzbmFwc2hvdCwgdXBkYXRlKSA9PiBzbmFwc2hvdENvbnRhaW5zVXBkYXRlVjIoc25hcHNob3QsIHVwZGF0ZSwgVXBkYXRlRGVjb2RlclYxKTtcblxuY2xhc3MgU3RydWN0U3RvcmUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsQXJyYXk8R0N8SXRlbT4+fVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50cyA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVsbCB8IHsgbWlzc2luZzogTWFwPG51bWJlciwgbnVtYmVyPiwgdXBkYXRlOiBVaW50OEFycmF5IH19XG4gICAgICovXG4gICAgdGhpcy5wZW5kaW5nU3RydWN0cyA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bGwgfCBVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHRoaXMucGVuZGluZ0RzID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgc3RhdGVzIGFzIGEgTWFwPGNsaWVudCxjbG9jaz4uXG4gKiBOb3RlIHRoYXQgY2xvY2sgcmVmZXJzIHRvIHRoZSBuZXh0IGV4cGVjdGVkIGNsb2NrIGlkLlxuICpcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcmV0dXJuIHtNYXA8bnVtYmVyLG51bWJlcj59XG4gKlxuICogQHB1YmxpY1xuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGdldFN0YXRlVmVjdG9yID0gc3RvcmUgPT4ge1xuICBjb25zdCBzbSA9IG5ldyBNYXAoKTtcbiAgc3RvcmUuY2xpZW50cy5mb3JFYWNoKChzdHJ1Y3RzLCBjbGllbnQpID0+IHtcbiAgICBjb25zdCBzdHJ1Y3QgPSBzdHJ1Y3RzW3N0cnVjdHMubGVuZ3RoIC0gMV07XG4gICAgc20uc2V0KGNsaWVudCwgc3RydWN0LmlkLmNsb2NrICsgc3RydWN0Lmxlbmd0aCk7XG4gIH0pO1xuICByZXR1cm4gc21cbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqXG4gKiBAcHVibGljXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZ2V0U3RhdGUgPSAoc3RvcmUsIGNsaWVudCkgPT4ge1xuICBjb25zdCBzdHJ1Y3RzID0gc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KTtcbiAgaWYgKHN0cnVjdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgY29uc3QgbGFzdFN0cnVjdCA9IHN0cnVjdHNbc3RydWN0cy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGxhc3RTdHJ1Y3QuaWQuY2xvY2sgKyBsYXN0U3RydWN0Lmxlbmd0aFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtHQ3xJdGVtfSBzdHJ1Y3RcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGFkZFN0cnVjdCA9IChzdG9yZSwgc3RydWN0KSA9PiB7XG4gIGxldCBzdHJ1Y3RzID0gc3RvcmUuY2xpZW50cy5nZXQoc3RydWN0LmlkLmNsaWVudCk7XG4gIGlmIChzdHJ1Y3RzID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHJ1Y3RzID0gW107XG4gICAgc3RvcmUuY2xpZW50cy5zZXQoc3RydWN0LmlkLmNsaWVudCwgc3RydWN0cyk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGFzdFN0cnVjdCA9IHN0cnVjdHNbc3RydWN0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAobGFzdFN0cnVjdC5pZC5jbG9jayArIGxhc3RTdHJ1Y3QubGVuZ3RoICE9PSBzdHJ1Y3QuaWQuY2xvY2spIHtcbiAgICAgIHRocm93IGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbiAgICB9XG4gIH1cbiAgc3RydWN0cy5wdXNoKHN0cnVjdCk7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIG9uIGEgc29ydGVkIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5PEl0ZW18R0M+fSBzdHJ1Y3RzXG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGZpbmRJbmRleFNTID0gKHN0cnVjdHMsIGNsb2NrKSA9PiB7XG4gIGxldCBsZWZ0ID0gMDtcbiAgbGV0IHJpZ2h0ID0gc3RydWN0cy5sZW5ndGggLSAxO1xuICBsZXQgbWlkID0gc3RydWN0c1tyaWdodF07XG4gIGxldCBtaWRjbG9jayA9IG1pZC5pZC5jbG9jaztcbiAgaWYgKG1pZGNsb2NrID09PSBjbG9jaykge1xuICAgIHJldHVybiByaWdodFxuICB9XG4gIC8vIEB0b2RvIGRvZXMgaXQgZXZlbiBtYWtlIHNlbnNlIHRvIHBpdm90IHRoZSBzZWFyY2g/XG4gIC8vIElmIGEgZ29vZCBzcGxpdCBtaXNzZXMsIGl0IG1pZ2h0IGFjdHVhbGx5IGluY3JlYXNlIHRoZSB0aW1lIHRvIGZpbmQgdGhlIGNvcnJlY3QgaXRlbS5cbiAgLy8gQ3VycmVudGx5LCB0aGUgb25seSBhZHZhbnRhZ2UgaXMgdGhhdCBzZWFyY2ggd2l0aCBwaXZvdGluZyBtaWdodCBmaW5kIHRoZSBpdGVtIG9uIHRoZSBmaXJzdCB0cnkuXG4gIGxldCBtaWRpbmRleCA9IG1hdGguZmxvb3IoKGNsb2NrIC8gKG1pZGNsb2NrICsgbWlkLmxlbmd0aCAtIDEpKSAqIHJpZ2h0KTsgLy8gcGl2b3RpbmcgdGhlIHNlYXJjaFxuICB3aGlsZSAobGVmdCA8PSByaWdodCkge1xuICAgIG1pZCA9IHN0cnVjdHNbbWlkaW5kZXhdO1xuICAgIG1pZGNsb2NrID0gbWlkLmlkLmNsb2NrO1xuICAgIGlmIChtaWRjbG9jayA8PSBjbG9jaykge1xuICAgICAgaWYgKGNsb2NrIDwgbWlkY2xvY2sgKyBtaWQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBtaWRpbmRleFxuICAgICAgfVxuICAgICAgbGVmdCA9IG1pZGluZGV4ICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmlnaHQgPSBtaWRpbmRleCAtIDE7XG4gICAgfVxuICAgIG1pZGluZGV4ID0gbWF0aC5mbG9vcigobGVmdCArIHJpZ2h0KSAvIDIpO1xuICB9XG4gIC8vIEFsd2F5cyBjaGVjayBzdGF0ZSBiZWZvcmUgbG9va2luZyBmb3IgYSBzdHJ1Y3QgaW4gU3RydWN0U3RvcmVcbiAgLy8gVGhlcmVmb3JlIHRoZSBjYXNlIG9mIG5vdCBmaW5kaW5nIGEgc3RydWN0IGlzIHVuZXhwZWN0ZWRcbiAgdGhyb3cgZXJyb3IudW5leHBlY3RlZENhc2UoKVxufTtcblxuLyoqXG4gKiBFeHBlY3RzIHRoYXQgaWQgaXMgYWN0dWFsbHkgaW4gc3RvcmUuIFRoaXMgZnVuY3Rpb24gdGhyb3dzIG9yIGlzIGFuIGluZmluaXRlIGxvb3Agb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEfSBpZFxuICogQHJldHVybiB7R0N8SXRlbX1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGZpbmQgPSAoc3RvcmUsIGlkKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59XG4gICAqL1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IHN0cnVjdHMgPSBzdG9yZS5jbGllbnRzLmdldChpZC5jbGllbnQpO1xuICByZXR1cm4gc3RydWN0c1tmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBpZC5jbG9jayldXG59O1xuXG4vKipcbiAqIEV4cGVjdHMgdGhhdCBpZCBpcyBhY3R1YWxseSBpbiBzdG9yZS4gVGhpcyBmdW5jdGlvbiB0aHJvd3Mgb3IgaXMgYW4gaW5maW5pdGUgbG9vcCBvdGhlcndpc2UuXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGdldEl0ZW0gPSAvKiogQHR5cGUge2Z1bmN0aW9uKFN0cnVjdFN0b3JlLElEKTpJdGVtfSAqLyAoZmluZCk7XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXk8SXRlbXxHQz59IHN0cnVjdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICovXG5jb25zdCBmaW5kSW5kZXhDbGVhblN0YXJ0ID0gKHRyYW5zYWN0aW9uLCBzdHJ1Y3RzLCBjbG9jaykgPT4ge1xuICBjb25zdCBpbmRleCA9IGZpbmRJbmRleFNTKHN0cnVjdHMsIGNsb2NrKTtcbiAgY29uc3Qgc3RydWN0ID0gc3RydWN0c1tpbmRleF07XG4gIGlmIChzdHJ1Y3QuaWQuY2xvY2sgPCBjbG9jayAmJiBzdHJ1Y3QgaW5zdGFuY2VvZiBJdGVtKSB7XG4gICAgc3RydWN0cy5zcGxpY2UoaW5kZXggKyAxLCAwLCBzcGxpdEl0ZW0odHJhbnNhY3Rpb24sIHN0cnVjdCwgY2xvY2sgLSBzdHJ1Y3QuaWQuY2xvY2spKTtcbiAgICByZXR1cm4gaW5kZXggKyAxXG4gIH1cbiAgcmV0dXJuIGluZGV4XG59O1xuXG4vKipcbiAqIEV4cGVjdHMgdGhhdCBpZCBpcyBhY3R1YWxseSBpbiBzdG9yZS4gVGhpcyBmdW5jdGlvbiB0aHJvd3Mgb3IgaXMgYW4gaW5maW5pdGUgbG9vcCBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7SUR9IGlkXG4gKiBAcmV0dXJuIHtJdGVtfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZ2V0SXRlbUNsZWFuU3RhcnQgPSAodHJhbnNhY3Rpb24sIGlkKSA9PiB7XG4gIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEl0ZW0+fSAqLyAodHJhbnNhY3Rpb24uZG9jLnN0b3JlLmNsaWVudHMuZ2V0KGlkLmNsaWVudCkpO1xuICByZXR1cm4gc3RydWN0c1tmaW5kSW5kZXhDbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBzdHJ1Y3RzLCBpZC5jbG9jayldXG59O1xuXG4vKipcbiAqIEV4cGVjdHMgdGhhdCBpZCBpcyBhY3R1YWxseSBpbiBzdG9yZS4gVGhpcyBmdW5jdGlvbiB0aHJvd3Mgb3IgaXMgYW4gaW5maW5pdGUgbG9vcCBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEfSBpZFxuICogQHJldHVybiB7SXRlbX1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGdldEl0ZW1DbGVhbkVuZCA9ICh0cmFuc2FjdGlvbiwgc3RvcmUsIGlkKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8SXRlbT59XG4gICAqL1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IHN0cnVjdHMgPSBzdG9yZS5jbGllbnRzLmdldChpZC5jbGllbnQpO1xuICBjb25zdCBpbmRleCA9IGZpbmRJbmRleFNTKHN0cnVjdHMsIGlkLmNsb2NrKTtcbiAgY29uc3Qgc3RydWN0ID0gc3RydWN0c1tpbmRleF07XG4gIGlmIChpZC5jbG9jayAhPT0gc3RydWN0LmlkLmNsb2NrICsgc3RydWN0Lmxlbmd0aCAtIDEgJiYgc3RydWN0LmNvbnN0cnVjdG9yICE9PSBHQykge1xuICAgIHN0cnVjdHMuc3BsaWNlKGluZGV4ICsgMSwgMCwgc3BsaXRJdGVtKHRyYW5zYWN0aW9uLCBzdHJ1Y3QsIGlkLmNsb2NrIC0gc3RydWN0LmlkLmNsb2NrICsgMSkpO1xuICB9XG4gIHJldHVybiBzdHJ1Y3Rcbn07XG5cbi8qKlxuICogUmVwbGFjZSBgaXRlbWAgd2l0aCBgbmV3aXRlbWAgaW4gc3RvcmVcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0dDfEl0ZW19IHN0cnVjdFxuICogQHBhcmFtIHtHQ3xJdGVtfSBuZXdTdHJ1Y3RcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlcGxhY2VTdHJ1Y3QgPSAoc3RvcmUsIHN0cnVjdCwgbmV3U3RydWN0KSA9PiB7XG4gIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEdDfEl0ZW0+fSAqLyAoc3RvcmUuY2xpZW50cy5nZXQoc3RydWN0LmlkLmNsaWVudCkpO1xuICBzdHJ1Y3RzW2ZpbmRJbmRleFNTKHN0cnVjdHMsIHN0cnVjdC5pZC5jbG9jayldID0gbmV3U3RydWN0O1xufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYSByYW5nZSBvZiBzdHJ1Y3RzXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXk8SXRlbXxHQz59IHN0cnVjdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1N0YXJ0IEluY2x1c2l2ZSBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICogQHBhcmFtIHtmdW5jdGlvbihHQ3xJdGVtKTp2b2lkfSBmXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGl0ZXJhdGVTdHJ1Y3RzID0gKHRyYW5zYWN0aW9uLCBzdHJ1Y3RzLCBjbG9ja1N0YXJ0LCBsZW4sIGYpID0+IHtcbiAgaWYgKGxlbiA9PT0gMCkge1xuICAgIHJldHVyblxuICB9XG4gIGNvbnN0IGNsb2NrRW5kID0gY2xvY2tTdGFydCArIGxlbjtcbiAgbGV0IGluZGV4ID0gZmluZEluZGV4Q2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgc3RydWN0cywgY2xvY2tTdGFydCk7XG4gIGxldCBzdHJ1Y3Q7XG4gIGRvIHtcbiAgICBzdHJ1Y3QgPSBzdHJ1Y3RzW2luZGV4KytdO1xuICAgIGlmIChjbG9ja0VuZCA8IHN0cnVjdC5pZC5jbG9jayArIHN0cnVjdC5sZW5ndGgpIHtcbiAgICAgIGZpbmRJbmRleENsZWFuU3RhcnQodHJhbnNhY3Rpb24sIHN0cnVjdHMsIGNsb2NrRW5kKTtcbiAgICB9XG4gICAgZihzdHJ1Y3QpO1xuICB9IHdoaWxlIChpbmRleCA8IHN0cnVjdHMubGVuZ3RoICYmIHN0cnVjdHNbaW5kZXhdLmlkLmNsb2NrIDwgY2xvY2tFbmQpXG59O1xuXG4vKipcbiAqIEEgdHJhbnNhY3Rpb24gaXMgY3JlYXRlZCBmb3IgZXZlcnkgY2hhbmdlIG9uIHRoZSBZanMgbW9kZWwuIEl0IGlzIHBvc3NpYmxlXG4gKiB0byBidW5kbGUgY2hhbmdlcyBvbiB0aGUgWWpzIG1vZGVsIGluIGEgc2luZ2xlIHRyYW5zYWN0aW9uIHRvXG4gKiBtaW5pbWl6ZSB0aGUgbnVtYmVyIG9uIG1lc3NhZ2VzIHNlbnQgYW5kIHRoZSBudW1iZXIgb2Ygb2JzZXJ2ZXIgY2FsbHMuXG4gKiBJZiBwb3NzaWJsZSB0aGUgdXNlciBvZiB0aGlzIGxpYnJhcnkgc2hvdWxkIGJ1bmRsZSBhcyBtYW55IGNoYW5nZXMgYXNcbiAqIHBvc3NpYmxlLiBIZXJlIGlzIGFuIGV4YW1wbGUgdG8gaWxsdXN0cmF0ZSB0aGUgYWR2YW50YWdlcyBvZiBidW5kbGluZzpcbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgeWRvYyA9IG5ldyBZLkRvYygpXG4gKiBjb25zdCBtYXAgPSB5ZG9jLmdldE1hcCgnbWFwJylcbiAqIC8vIExvZyBjb250ZW50IHdoZW4gY2hhbmdlIGlzIHRyaWdnZXJlZFxuICogbWFwLm9ic2VydmUoKCkgPT4ge1xuICogICBjb25zb2xlLmxvZygnY2hhbmdlIHRyaWdnZXJlZCcpXG4gKiB9KVxuICogLy8gRWFjaCBjaGFuZ2Ugb24gdGhlIG1hcCB0eXBlIHRyaWdnZXJzIGEgbG9nIG1lc3NhZ2U6XG4gKiBtYXAuc2V0KCdhJywgMCkgLy8gPT4gXCJjaGFuZ2UgdHJpZ2dlcmVkXCJcbiAqIG1hcC5zZXQoJ2InLCAwKSAvLyA9PiBcImNoYW5nZSB0cmlnZ2VyZWRcIlxuICogLy8gV2hlbiBwdXQgaW4gYSB0cmFuc2FjdGlvbiwgaXQgd2lsbCB0cmlnZ2VyIHRoZSBsb2cgYWZ0ZXIgdGhlIHRyYW5zYWN0aW9uOlxuICogeWRvYy50cmFuc2FjdCgoKSA9PiB7XG4gKiAgIG1hcC5zZXQoJ2EnLCAxKVxuICogICBtYXAuc2V0KCdiJywgMSlcbiAqIH0pIC8vID0+IFwiY2hhbmdlIHRyaWdnZXJlZFwiXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBUcmFuc2FjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30gZG9jXG4gICAqIEBwYXJhbSB7YW55fSBvcmlnaW5cbiAgICogQHBhcmFtIHtib29sZWFufSBsb2NhbFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRvYywgb3JpZ2luLCBsb2NhbCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBZanMgaW5zdGFuY2UuXG4gICAgICogQHR5cGUge0RvY31cbiAgICAgKi9cbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAvKipcbiAgICAgKiBEZXNjcmliZXMgdGhlIHNldCBvZiBkZWxldGVkIGl0ZW1zIGJ5IGlkc1xuICAgICAqIEB0eXBlIHtEZWxldGVTZXR9XG4gICAgICovXG4gICAgdGhpcy5kZWxldGVTZXQgPSBuZXcgRGVsZXRlU2V0KCk7XG4gICAgLyoqXG4gICAgICogSG9sZHMgdGhlIHN0YXRlIGJlZm9yZSB0aGUgdHJhbnNhY3Rpb24gc3RhcnRlZC5cbiAgICAgKiBAdHlwZSB7TWFwPE51bWJlcixOdW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuYmVmb3JlU3RhdGUgPSBnZXRTdGF0ZVZlY3Rvcihkb2Muc3RvcmUpO1xuICAgIC8qKlxuICAgICAqIEhvbGRzIHRoZSBzdGF0ZSBhZnRlciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogQHR5cGUge01hcDxOdW1iZXIsTnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmFmdGVyU3RhdGUgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogQWxsIHR5cGVzIHRoYXQgd2VyZSBkaXJlY3RseSBtb2RpZmllZCAocHJvcGVydHkgYWRkZWQgb3IgY2hpbGRcbiAgICAgKiBpbnNlcnRlZC9kZWxldGVkKS4gTmV3IHR5cGVzIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhpcyBTZXQuXG4gICAgICogTWFwcyBmcm9tIHR5cGUgdG8gcGFyZW50U3VicyAoYGl0ZW0ucGFyZW50U3ViID0gbnVsbGAgZm9yIFlBcnJheSlcbiAgICAgKiBAdHlwZSB7TWFwPEFic3RyYWN0VHlwZTxZRXZlbnQ8YW55Pj4sU2V0PFN0cmluZ3xudWxsPj59XG4gICAgICovXG4gICAgdGhpcy5jaGFuZ2VkID0gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIFN0b3JlcyB0aGUgZXZlbnRzIGZvciB0aGUgdHlwZXMgdGhhdCBvYnNlcnZlIGFsc28gY2hpbGQgZWxlbWVudHMuXG4gICAgICogSXQgaXMgbWFpbmx5IHVzZWQgYnkgYG9ic2VydmVEZWVwYC5cbiAgICAgKiBAdHlwZSB7TWFwPEFic3RyYWN0VHlwZTxZRXZlbnQ8YW55Pj4sQXJyYXk8WUV2ZW50PGFueT4+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNoYW5nZWRQYXJlbnRUeXBlcyA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8QWJzdHJhY3RTdHJ1Y3Q+fVxuICAgICAqL1xuICAgIHRoaXMuX21lcmdlU3RydWN0cyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHthbnl9XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW47XG4gICAgLyoqXG4gICAgICogU3RvcmVzIG1ldGEgaW5mb3JtYXRpb24gb24gdGhlIHRyYW5zYWN0aW9uXG4gICAgICogQHR5cGUge01hcDxhbnksYW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLm1ldGEgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGNoYW5nZSBvcmlnaW5hdGVzIGZyb20gdGhpcyBkb2MuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sb2NhbCA9IGxvY2FsO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtTZXQ8RG9jPn1cbiAgICAgKi9cbiAgICB0aGlzLnN1YmRvY3NBZGRlZCA9IG5ldyBTZXQoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7U2V0PERvYz59XG4gICAgICovXG4gICAgdGhpcy5zdWJkb2NzUmVtb3ZlZCA9IG5ldyBTZXQoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7U2V0PERvYz59XG4gICAgICovXG4gICAgdGhpcy5zdWJkb2NzTG9hZGVkID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuX25lZWRGb3JtYXR0aW5nQ2xlYW51cCA9IGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIGRhdGEgd2FzIHdyaXR0ZW4uXG4gKi9cbmNvbnN0IHdyaXRlVXBkYXRlTWVzc2FnZUZyb21UcmFuc2FjdGlvbiA9IChlbmNvZGVyLCB0cmFuc2FjdGlvbikgPT4ge1xuICBpZiAodHJhbnNhY3Rpb24uZGVsZXRlU2V0LmNsaWVudHMuc2l6ZSA9PT0gMCAmJiAhbWFwLmFueSh0cmFuc2FjdGlvbi5hZnRlclN0YXRlLCAoY2xvY2ssIGNsaWVudCkgPT4gdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGNsaWVudCkgIT09IGNsb2NrKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHNvcnRBbmRNZXJnZURlbGV0ZVNldCh0cmFuc2FjdGlvbi5kZWxldGVTZXQpO1xuICB3cml0ZVN0cnVjdHNGcm9tVHJhbnNhY3Rpb24oZW5jb2RlciwgdHJhbnNhY3Rpb24pO1xuICB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCB0cmFuc2FjdGlvbi5kZWxldGVTZXQpO1xuICByZXR1cm4gdHJ1ZVxufTtcblxuLyoqXG4gKiBJZiBgdHlwZS5wYXJlbnRgIHdhcyBhZGRlZCBpbiBjdXJyZW50IHRyYW5zYWN0aW9uLCBgdHlwZWAgdGVjaG5pY2FsbHlcbiAqIGRpZCBub3QgY2hhbmdlLCBpdCB3YXMganVzdCBhZGRlZCBhbmQgd2Ugc2hvdWxkIG5vdCBmaXJlIGV2ZW50cyBmb3IgYHR5cGVgLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxZRXZlbnQ8YW55Pj59IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bGx9IHBhcmVudFN1YlxuICovXG5jb25zdCBhZGRDaGFuZ2VkVHlwZVRvVHJhbnNhY3Rpb24gPSAodHJhbnNhY3Rpb24sIHR5cGUsIHBhcmVudFN1YikgPT4ge1xuICBjb25zdCBpdGVtID0gdHlwZS5faXRlbTtcbiAgaWYgKGl0ZW0gPT09IG51bGwgfHwgKGl0ZW0uaWQuY2xvY2sgPCAodHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGl0ZW0uaWQuY2xpZW50KSB8fCAwKSAmJiAhaXRlbS5kZWxldGVkKSkge1xuICAgIG1hcC5zZXRJZlVuZGVmaW5lZCh0cmFuc2FjdGlvbi5jaGFuZ2VkLCB0eXBlLCBzZXQuY3JlYXRlKS5hZGQocGFyZW50U3ViKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PEFic3RyYWN0U3RydWN0Pn0gc3RydWN0c1xuICogQHBhcmFtIHtudW1iZXJ9IHBvc1xuICogQHJldHVybiB7bnVtYmVyfSAjIG9mIG1lcmdlZCBzdHJ1Y3RzXG4gKi9cbmNvbnN0IHRyeVRvTWVyZ2VXaXRoTGVmdHMgPSAoc3RydWN0cywgcG9zKSA9PiB7XG4gIGxldCByaWdodCA9IHN0cnVjdHNbcG9zXTtcbiAgbGV0IGxlZnQgPSBzdHJ1Y3RzW3BvcyAtIDFdO1xuICBsZXQgaSA9IHBvcztcbiAgZm9yICg7IGkgPiAwOyByaWdodCA9IGxlZnQsIGxlZnQgPSBzdHJ1Y3RzWy0taSAtIDFdKSB7XG4gICAgaWYgKGxlZnQuZGVsZXRlZCA9PT0gcmlnaHQuZGVsZXRlZCAmJiBsZWZ0LmNvbnN0cnVjdG9yID09PSByaWdodC5jb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKGxlZnQubWVyZ2VXaXRoKHJpZ2h0KSkge1xuICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBJdGVtICYmIHJpZ2h0LnBhcmVudFN1YiAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHQucGFyZW50KS5fbWFwLmdldChyaWdodC5wYXJlbnRTdWIpID09PSByaWdodCkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChyaWdodC5wYXJlbnQpLl9tYXAuc2V0KHJpZ2h0LnBhcmVudFN1YiwgLyoqIEB0eXBlIHtJdGVtfSAqLyAobGVmdCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrXG4gIH1cbiAgY29uc3QgbWVyZ2VkID0gcG9zIC0gaTtcbiAgaWYgKG1lcmdlZCkge1xuICAgIC8vIHJlbW92ZSBhbGwgbWVyZ2VkIHN0cnVjdHMgZnJvbSB0aGUgYXJyYXlcbiAgICBzdHJ1Y3RzLnNwbGljZShwb3MgKyAxIC0gbWVyZ2VkLCBtZXJnZWQpO1xuICB9XG4gIHJldHVybiBtZXJnZWRcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtmdW5jdGlvbihJdGVtKTpib29sZWFufSBnY0ZpbHRlclxuICovXG5jb25zdCB0cnlHY0RlbGV0ZVNldCA9IChkcywgc3RvcmUsIGdjRmlsdGVyKSA9PiB7XG4gIGZvciAoY29uc3QgW2NsaWVudCwgZGVsZXRlSXRlbXNdIG9mIGRzLmNsaWVudHMuZW50cmllcygpKSB7XG4gICAgY29uc3Qgc3RydWN0cyA9IC8qKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59ICovIChzdG9yZS5jbGllbnRzLmdldChjbGllbnQpKTtcbiAgICBmb3IgKGxldCBkaSA9IGRlbGV0ZUl0ZW1zLmxlbmd0aCAtIDE7IGRpID49IDA7IGRpLS0pIHtcbiAgICAgIGNvbnN0IGRlbGV0ZUl0ZW0gPSBkZWxldGVJdGVtc1tkaV07XG4gICAgICBjb25zdCBlbmREZWxldGVJdGVtQ2xvY2sgPSBkZWxldGVJdGVtLmNsb2NrICsgZGVsZXRlSXRlbS5sZW47XG4gICAgICBmb3IgKFxuICAgICAgICBsZXQgc2kgPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBkZWxldGVJdGVtLmNsb2NrKSwgc3RydWN0ID0gc3RydWN0c1tzaV07XG4gICAgICAgIHNpIDwgc3RydWN0cy5sZW5ndGggJiYgc3RydWN0LmlkLmNsb2NrIDwgZW5kRGVsZXRlSXRlbUNsb2NrO1xuICAgICAgICBzdHJ1Y3QgPSBzdHJ1Y3RzWysrc2ldXG4gICAgICApIHtcbiAgICAgICAgY29uc3Qgc3RydWN0ID0gc3RydWN0c1tzaV07XG4gICAgICAgIGlmIChkZWxldGVJdGVtLmNsb2NrICsgZGVsZXRlSXRlbS5sZW4gPD0gc3RydWN0LmlkLmNsb2NrKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RydWN0IGluc3RhbmNlb2YgSXRlbSAmJiBzdHJ1Y3QuZGVsZXRlZCAmJiAhc3RydWN0LmtlZXAgJiYgZ2NGaWx0ZXIoc3RydWN0KSkge1xuICAgICAgICAgIHN0cnVjdC5nYyhzdG9yZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqL1xuY29uc3QgdHJ5TWVyZ2VEZWxldGVTZXQgPSAoZHMsIHN0b3JlKSA9PiB7XG4gIC8vIHRyeSB0byBtZXJnZSBkZWxldGVkIC8gZ2MnZCBpdGVtc1xuICAvLyBtZXJnZSBmcm9tIHJpZ2h0IHRvIGxlZnQgZm9yIGJldHRlciBlZmZpY2llbmN5IGFuZCBzbyB3ZSBkb24ndCBtaXNzIGFueSBtZXJnZSB0YXJnZXRzXG4gIGRzLmNsaWVudHMuZm9yRWFjaCgoZGVsZXRlSXRlbXMsIGNsaWVudCkgPT4ge1xuICAgIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEdDfEl0ZW0+fSAqLyAoc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSk7XG4gICAgZm9yIChsZXQgZGkgPSBkZWxldGVJdGVtcy5sZW5ndGggLSAxOyBkaSA+PSAwOyBkaS0tKSB7XG4gICAgICBjb25zdCBkZWxldGVJdGVtID0gZGVsZXRlSXRlbXNbZGldO1xuICAgICAgLy8gc3RhcnQgd2l0aCBtZXJnaW5nIHRoZSBpdGVtIG5leHQgdG8gdGhlIGxhc3QgZGVsZXRlZCBpdGVtXG4gICAgICBjb25zdCBtb3N0UmlnaHRJbmRleFRvQ2hlY2sgPSBtYXRoLm1pbihzdHJ1Y3RzLmxlbmd0aCAtIDEsIDEgKyBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBkZWxldGVJdGVtLmNsb2NrICsgZGVsZXRlSXRlbS5sZW4gLSAxKSk7XG4gICAgICBmb3IgKFxuICAgICAgICBsZXQgc2kgPSBtb3N0UmlnaHRJbmRleFRvQ2hlY2ssIHN0cnVjdCA9IHN0cnVjdHNbc2ldO1xuICAgICAgICBzaSA+IDAgJiYgc3RydWN0LmlkLmNsb2NrID49IGRlbGV0ZUl0ZW0uY2xvY2s7XG4gICAgICAgIHN0cnVjdCA9IHN0cnVjdHNbc2ldXG4gICAgICApIHtcbiAgICAgICAgc2kgLT0gMSArIHRyeVRvTWVyZ2VXaXRoTGVmdHMoc3RydWN0cywgc2kpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oSXRlbSk6Ym9vbGVhbn0gZ2NGaWx0ZXJcbiAqL1xuY29uc3QgdHJ5R2MgPSAoZHMsIHN0b3JlLCBnY0ZpbHRlcikgPT4ge1xuICB0cnlHY0RlbGV0ZVNldChkcywgc3RvcmUsIGdjRmlsdGVyKTtcbiAgdHJ5TWVyZ2VEZWxldGVTZXQoZHMsIHN0b3JlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxUcmFuc2FjdGlvbj59IHRyYW5zYWN0aW9uQ2xlYW51cHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gKi9cbmNvbnN0IGNsZWFudXBUcmFuc2FjdGlvbnMgPSAodHJhbnNhY3Rpb25DbGVhbnVwcywgaSkgPT4ge1xuICBpZiAoaSA8IHRyYW5zYWN0aW9uQ2xlYW51cHMubGVuZ3RoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbkNsZWFudXBzW2ldO1xuICAgIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgICBjb25zdCBzdG9yZSA9IGRvYy5zdG9yZTtcbiAgICBjb25zdCBkcyA9IHRyYW5zYWN0aW9uLmRlbGV0ZVNldDtcbiAgICBjb25zdCBtZXJnZVN0cnVjdHMgPSB0cmFuc2FjdGlvbi5fbWVyZ2VTdHJ1Y3RzO1xuICAgIHRyeSB7XG4gICAgICBzb3J0QW5kTWVyZ2VEZWxldGVTZXQoZHMpO1xuICAgICAgdHJhbnNhY3Rpb24uYWZ0ZXJTdGF0ZSA9IGdldFN0YXRlVmVjdG9yKHRyYW5zYWN0aW9uLmRvYy5zdG9yZSk7XG4gICAgICBkb2MuZW1pdCgnYmVmb3JlT2JzZXJ2ZXJDYWxscycsIFt0cmFuc2FjdGlvbiwgZG9jXSk7XG4gICAgICAvKipcbiAgICAgICAqIEFuIGFycmF5IG9mIGV2ZW50IGNhbGxiYWNrcy5cbiAgICAgICAqXG4gICAgICAgKiBFYWNoIGNhbGxiYWNrIGlzIGNhbGxlZCBldmVuIGlmIHRoZSBvdGhlciBvbmVzIHRocm93IGVycm9ycy5cbiAgICAgICAqXG4gICAgICAgKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24oKTp2b2lkPn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgZnMgPSBbXTtcbiAgICAgIC8vIG9ic2VydmUgZXZlbnRzIG9uIGNoYW5nZWQgdHlwZXNcbiAgICAgIHRyYW5zYWN0aW9uLmNoYW5nZWQuZm9yRWFjaCgoc3VicywgaXRlbXR5cGUpID0+XG4gICAgICAgIGZzLnB1c2goKCkgPT4ge1xuICAgICAgICAgIGlmIChpdGVtdHlwZS5faXRlbSA9PT0gbnVsbCB8fCAhaXRlbXR5cGUuX2l0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgaXRlbXR5cGUuX2NhbGxPYnNlcnZlcih0cmFuc2FjdGlvbiwgc3Vicyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGZzLnB1c2goKCkgPT4ge1xuICAgICAgICAvLyBkZWVwIG9ic2VydmUgZXZlbnRzXG4gICAgICAgIHRyYW5zYWN0aW9uLmNoYW5nZWRQYXJlbnRUeXBlcy5mb3JFYWNoKChldmVudHMsIHR5cGUpID0+IHtcbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIHRoaW5rIGFib3V0IHRoZSBwb3NzaWJpbGl0eSB0aGF0IHRoZSB1c2VyIHRyYW5zZm9ybXMgdGhlXG4gICAgICAgICAgLy8gWS5Eb2MgaW4gdGhlIGV2ZW50LlxuICAgICAgICAgIGlmICh0eXBlLl9kRUgubC5sZW5ndGggPiAwICYmICh0eXBlLl9pdGVtID09PSBudWxsIHx8ICF0eXBlLl9pdGVtLmRlbGV0ZWQpKSB7XG4gICAgICAgICAgICBldmVudHMgPSBldmVudHNcbiAgICAgICAgICAgICAgLmZpbHRlcihldmVudCA9PlxuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5faXRlbSA9PT0gbnVsbCB8fCAhZXZlbnQudGFyZ2V0Ll9pdGVtLmRlbGV0ZWRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGV2ZW50c1xuICAgICAgICAgICAgICAuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IHR5cGU7XG4gICAgICAgICAgICAgICAgLy8gcGF0aCBpcyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCB0YXJnZXRcbiAgICAgICAgICAgICAgICBldmVudC5fcGF0aCA9IG51bGw7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gc29ydCBldmVudHMgYnkgcGF0aCBsZW5ndGggc28gdGhhdCB0b3AtbGV2ZWwgZXZlbnRzIGFyZSBmaXJlZCBmaXJzdC5cbiAgICAgICAgICAgIGV2ZW50c1xuICAgICAgICAgICAgICAuc29ydCgoZXZlbnQxLCBldmVudDIpID0+IGV2ZW50MS5wYXRoLmxlbmd0aCAtIGV2ZW50Mi5wYXRoLmxlbmd0aCk7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGNoZWNrIGZvciBldmVudHMubGVuZ3RoXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHdlIGtub3cgaXQgaGFzIGF0IGxlYXN0IG9uZSBlbGVtZW50XG4gICAgICAgICAgICBjYWxsRXZlbnRIYW5kbGVyTGlzdGVuZXJzKHR5cGUuX2RFSCwgZXZlbnRzLCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZnMucHVzaCgoKSA9PiBkb2MuZW1pdCgnYWZ0ZXJUcmFuc2FjdGlvbicsIFt0cmFuc2FjdGlvbiwgZG9jXSkpO1xuICAgICAgY2FsbEFsbChmcywgW10pO1xuICAgICAgaWYgKHRyYW5zYWN0aW9uLl9uZWVkRm9ybWF0dGluZ0NsZWFudXApIHtcbiAgICAgICAgY2xlYW51cFlUZXh0QWZ0ZXJUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIFJlcGxhY2UgZGVsZXRlZCBpdGVtcyB3aXRoIEl0ZW1EZWxldGVkIC8gR0MuXG4gICAgICAvLyBUaGlzIGlzIHdoZXJlIGNvbnRlbnQgaXMgYWN0dWFsbHkgcmVtb3ZlIGZyb20gdGhlIFlqcyBEb2MuXG4gICAgICBpZiAoZG9jLmdjKSB7XG4gICAgICAgIHRyeUdjRGVsZXRlU2V0KGRzLCBzdG9yZSwgZG9jLmdjRmlsdGVyKTtcbiAgICAgIH1cbiAgICAgIHRyeU1lcmdlRGVsZXRlU2V0KGRzLCBzdG9yZSk7XG5cbiAgICAgIC8vIG9uIGFsbCBhZmZlY3RlZCBzdG9yZS5jbGllbnRzIHByb3BzLCB0cnkgdG8gbWVyZ2VcbiAgICAgIHRyYW5zYWN0aW9uLmFmdGVyU3RhdGUuZm9yRWFjaCgoY2xvY2ssIGNsaWVudCkgPT4ge1xuICAgICAgICBjb25zdCBiZWZvcmVDbG9jayA9IHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChjbGllbnQpIHx8IDA7XG4gICAgICAgIGlmIChiZWZvcmVDbG9jayAhPT0gY2xvY2spIHtcbiAgICAgICAgICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpO1xuICAgICAgICAgIC8vIHdlIGl0ZXJhdGUgZnJvbSByaWdodCB0byBsZWZ0IHNvIHdlIGNhbiBzYWZlbHkgcmVtb3ZlIGVudHJpZXNcbiAgICAgICAgICBjb25zdCBmaXJzdENoYW5nZVBvcyA9IG1hdGgubWF4KGZpbmRJbmRleFNTKHN0cnVjdHMsIGJlZm9yZUNsb2NrKSwgMSk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IHN0cnVjdHMubGVuZ3RoIC0gMTsgaSA+PSBmaXJzdENoYW5nZVBvczspIHtcbiAgICAgICAgICAgIGkgLT0gMSArIHRyeVRvTWVyZ2VXaXRoTGVmdHMoc3RydWN0cywgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIHRyeSB0byBtZXJnZSBtZXJnZVN0cnVjdHNcbiAgICAgIC8vIEB0b2RvOiBpdCBtYWtlcyBtb3JlIHNlbnNlIHRvIHRyYW5zZm9ybSBtZXJnZVN0cnVjdHMgdG8gYSBEUywgc29ydCBpdCwgYW5kIG1lcmdlIGZyb20gcmlnaHQgdG8gbGVmdFxuICAgICAgLy8gICAgICAgIGJ1dCBhdCB0aGUgbW9tZW50IERTIGRvZXMgbm90IGhhbmRsZSBkdXBsaWNhdGVzXG4gICAgICBmb3IgKGxldCBpID0gbWVyZ2VTdHJ1Y3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IHsgY2xpZW50LCBjbG9jayB9ID0gbWVyZ2VTdHJ1Y3RzW2ldLmlkO1xuICAgICAgICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpO1xuICAgICAgICBjb25zdCByZXBsYWNlZFN0cnVjdFBvcyA9IGZpbmRJbmRleFNTKHN0cnVjdHMsIGNsb2NrKTtcbiAgICAgICAgaWYgKHJlcGxhY2VkU3RydWN0UG9zICsgMSA8IHN0cnVjdHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHRyeVRvTWVyZ2VXaXRoTGVmdHMoc3RydWN0cywgcmVwbGFjZWRTdHJ1Y3RQb3MgKyAxKSA+IDEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlIC8vIG5vIG5lZWQgdG8gcGVyZm9ybSBuZXh0IGNoZWNrLCBib3RoIGFyZSBhbHJlYWR5IG1lcmdlZFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVwbGFjZWRTdHJ1Y3RQb3MgPiAwKSB7XG4gICAgICAgICAgdHJ5VG9NZXJnZVdpdGhMZWZ0cyhzdHJ1Y3RzLCByZXBsYWNlZFN0cnVjdFBvcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdHJhbnNhY3Rpb24ubG9jYWwgJiYgdHJhbnNhY3Rpb24uYWZ0ZXJTdGF0ZS5nZXQoZG9jLmNsaWVudElEKSAhPT0gdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGRvYy5jbGllbnRJRCkpIHtcbiAgICAgICAgbG9nZ2luZy5wcmludChsb2dnaW5nLk9SQU5HRSwgbG9nZ2luZy5CT0xELCAnW3lqc10gJywgbG9nZ2luZy5VTkJPTEQsIGxvZ2dpbmcuUkVELCAnQ2hhbmdlZCB0aGUgY2xpZW50LWlkIGJlY2F1c2UgYW5vdGhlciBjbGllbnQgc2VlbXMgdG8gYmUgdXNpbmcgaXQuJyk7XG4gICAgICAgIGRvYy5jbGllbnRJRCA9IGdlbmVyYXRlTmV3Q2xpZW50SWQoKTtcbiAgICAgIH1cbiAgICAgIC8vIEB0b2RvIE1lcmdlIGFsbCB0aGUgdHJhbnNhY3Rpb25zIGludG8gb25lIGFuZCBwcm92aWRlIHNlbmQgdGhlIGRhdGEgYXMgYSBzaW5nbGUgdXBkYXRlIG1lc3NhZ2VcbiAgICAgIGRvYy5lbWl0KCdhZnRlclRyYW5zYWN0aW9uQ2xlYW51cCcsIFt0cmFuc2FjdGlvbiwgZG9jXSk7XG4gICAgICBpZiAoZG9jLl9vYnNlcnZlcnMuaGFzKCd1cGRhdGUnKSkge1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFVwZGF0ZUVuY29kZXJWMSgpO1xuICAgICAgICBjb25zdCBoYXNDb250ZW50ID0gd3JpdGVVcGRhdGVNZXNzYWdlRnJvbVRyYW5zYWN0aW9uKGVuY29kZXIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgaWYgKGhhc0NvbnRlbnQpIHtcbiAgICAgICAgICBkb2MuZW1pdCgndXBkYXRlJywgW2VuY29kZXIudG9VaW50OEFycmF5KCksIHRyYW5zYWN0aW9uLm9yaWdpbiwgZG9jLCB0cmFuc2FjdGlvbl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZG9jLl9vYnNlcnZlcnMuaGFzKCd1cGRhdGVWMicpKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYyKCk7XG4gICAgICAgIGNvbnN0IGhhc0NvbnRlbnQgPSB3cml0ZVVwZGF0ZU1lc3NhZ2VGcm9tVHJhbnNhY3Rpb24oZW5jb2RlciwgdHJhbnNhY3Rpb24pO1xuICAgICAgICBpZiAoaGFzQ29udGVudCkge1xuICAgICAgICAgIGRvYy5lbWl0KCd1cGRhdGVWMicsIFtlbmNvZGVyLnRvVWludDhBcnJheSgpLCB0cmFuc2FjdGlvbi5vcmlnaW4sIGRvYywgdHJhbnNhY3Rpb25dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgeyBzdWJkb2NzQWRkZWQsIHN1YmRvY3NMb2FkZWQsIHN1YmRvY3NSZW1vdmVkIH0gPSB0cmFuc2FjdGlvbjtcbiAgICAgIGlmIChzdWJkb2NzQWRkZWQuc2l6ZSA+IDAgfHwgc3ViZG9jc1JlbW92ZWQuc2l6ZSA+IDAgfHwgc3ViZG9jc0xvYWRlZC5zaXplID4gMCkge1xuICAgICAgICBzdWJkb2NzQWRkZWQuZm9yRWFjaChzdWJkb2MgPT4ge1xuICAgICAgICAgIHN1YmRvYy5jbGllbnRJRCA9IGRvYy5jbGllbnRJRDtcbiAgICAgICAgICBpZiAoc3ViZG9jLmNvbGxlY3Rpb25pZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdWJkb2MuY29sbGVjdGlvbmlkID0gZG9jLmNvbGxlY3Rpb25pZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZG9jLnN1YmRvY3MuYWRkKHN1YmRvYyk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdWJkb2NzUmVtb3ZlZC5mb3JFYWNoKHN1YmRvYyA9PiBkb2Muc3ViZG9jcy5kZWxldGUoc3ViZG9jKSk7XG4gICAgICAgIGRvYy5lbWl0KCdzdWJkb2NzJywgW3sgbG9hZGVkOiBzdWJkb2NzTG9hZGVkLCBhZGRlZDogc3ViZG9jc0FkZGVkLCByZW1vdmVkOiBzdWJkb2NzUmVtb3ZlZCB9LCBkb2MsIHRyYW5zYWN0aW9uXSk7XG4gICAgICAgIHN1YmRvY3NSZW1vdmVkLmZvckVhY2goc3ViZG9jID0+IHN1YmRvYy5kZXN0cm95KCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNhY3Rpb25DbGVhbnVwcy5sZW5ndGggPD0gaSArIDEpIHtcbiAgICAgICAgZG9jLl90cmFuc2FjdGlvbkNsZWFudXBzID0gW107XG4gICAgICAgIGRvYy5lbWl0KCdhZnRlckFsbFRyYW5zYWN0aW9ucycsIFtkb2MsIHRyYW5zYWN0aW9uQ2xlYW51cHNdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsZWFudXBUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25DbGVhbnVwcywgaSArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGB5LnRyYW5zYWN0KCgpPT57Li59KWBcbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtEb2N9IGRvY1xuICogQHBhcmFtIHtmdW5jdGlvbihUcmFuc2FjdGlvbik6VH0gZlxuICogQHBhcmFtIHthbnl9IFtvcmlnaW49dHJ1ZV1cbiAqIEByZXR1cm4ge1R9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHRyYW5zYWN0ID0gKGRvYywgZiwgb3JpZ2luID0gbnVsbCwgbG9jYWwgPSB0cnVlKSA9PiB7XG4gIGNvbnN0IHRyYW5zYWN0aW9uQ2xlYW51cHMgPSBkb2MuX3RyYW5zYWN0aW9uQ2xlYW51cHM7XG4gIGxldCBpbml0aWFsQ2FsbCA9IGZhbHNlO1xuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIGxldCByZXN1bHQgPSBudWxsO1xuICBpZiAoZG9jLl90cmFuc2FjdGlvbiA9PT0gbnVsbCkge1xuICAgIGluaXRpYWxDYWxsID0gdHJ1ZTtcbiAgICBkb2MuX3RyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKGRvYywgb3JpZ2luLCBsb2NhbCk7XG4gICAgdHJhbnNhY3Rpb25DbGVhbnVwcy5wdXNoKGRvYy5fdHJhbnNhY3Rpb24pO1xuICAgIGlmICh0cmFuc2FjdGlvbkNsZWFudXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZG9jLmVtaXQoJ2JlZm9yZUFsbFRyYW5zYWN0aW9ucycsIFtkb2NdKTtcbiAgICB9XG4gICAgZG9jLmVtaXQoJ2JlZm9yZVRyYW5zYWN0aW9uJywgW2RvYy5fdHJhbnNhY3Rpb24sIGRvY10pO1xuICB9XG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gZihkb2MuX3RyYW5zYWN0aW9uKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAoaW5pdGlhbENhbGwpIHtcbiAgICAgIGNvbnN0IGZpbmlzaENsZWFudXAgPSBkb2MuX3RyYW5zYWN0aW9uID09PSB0cmFuc2FjdGlvbkNsZWFudXBzWzBdO1xuICAgICAgZG9jLl90cmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICBpZiAoZmluaXNoQ2xlYW51cCkge1xuICAgICAgICAvLyBUaGUgZmlyc3QgdHJhbnNhY3Rpb24gZW5kZWQsIG5vdyBwcm9jZXNzIG9ic2VydmVyIGNhbGxzLlxuICAgICAgICAvLyBPYnNlcnZlciBjYWxsIG1heSBjcmVhdGUgbmV3IHRyYW5zYWN0aW9ucyBmb3Igd2hpY2ggd2UgbmVlZCB0byBjYWxsIHRoZSBvYnNlcnZlcnMgYW5kIGRvIGNsZWFudXAuXG4gICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gbmVzdCB0aGVzZSBjYWxscywgc28gd2UgZXhlY3V0ZSB0aGVzZSBjYWxscyBvbmUgYWZ0ZXJcbiAgICAgICAgLy8gYW5vdGhlci5cbiAgICAgICAgLy8gQWxzbyB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IGFsbCBjbGVhbnVwcyBhcmUgY2FsbGVkLCBldmVuIGlmIHRoZVxuICAgICAgICAvLyBvYnNlcnZlcyB0aHJvdyBlcnJvcnMuXG4gICAgICAgIC8vIFRoaXMgZmlsZSBpcyBmdWxsIG9mIGhhY2t5IHRyeSB7fSBmaW5hbGx5IHt9IGJsb2NrcyB0byBlbnN1cmUgdGhhdCBhblxuICAgICAgICAvLyBldmVudCBjYW4gdGhyb3cgZXJyb3JzIGFuZCBhbHNvIHRoYXQgdGhlIGNsZWFudXAgaXMgY2FsbGVkLlxuICAgICAgICBjbGVhbnVwVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9uQ2xlYW51cHMsIDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59O1xuXG5jbGFzcyBTdGFja0l0ZW0ge1xuICAvKipcbiAgICogQHBhcmFtIHtEZWxldGVTZXR9IGRlbGV0aW9uc1xuICAgKiBAcGFyYW0ge0RlbGV0ZVNldH0gaW5zZXJ0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGRlbGV0aW9ucywgaW5zZXJ0aW9ucykge1xuICAgIHRoaXMuaW5zZXJ0aW9ucyA9IGluc2VydGlvbnM7XG4gICAgdGhpcy5kZWxldGlvbnMgPSBkZWxldGlvbnM7XG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgdG8gc2F2ZSBhbmQgcmVzdG9yZSBtZXRhZGF0YSBsaWtlIHNlbGVjdGlvbiByYW5nZVxuICAgICAqL1xuICAgIHRoaXMubWV0YSA9IG5ldyBNYXAoKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0clxuICogQHBhcmFtIHtVbmRvTWFuYWdlcn0gdW1cbiAqIEBwYXJhbSB7U3RhY2tJdGVtfSBzdGFja0l0ZW1cbiAqL1xuY29uc3QgY2xlYXJVbmRvTWFuYWdlclN0YWNrSXRlbSA9ICh0ciwgdW0sIHN0YWNrSXRlbSkgPT4ge1xuICBpdGVyYXRlRGVsZXRlZFN0cnVjdHModHIsIHN0YWNrSXRlbS5kZWxldGlvbnMsIGl0ZW0gPT4ge1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgSXRlbSAmJiB1bS5zY29wZS5zb21lKHR5cGUgPT4gdHlwZSA9PT0gdHIuZG9jIHx8IGlzUGFyZW50T2YoLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHR5cGUpLCBpdGVtKSkpIHtcbiAgICAgIGtlZXBJdGVtKGl0ZW0sIGZhbHNlKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VuZG9NYW5hZ2VyfSB1bmRvTWFuYWdlclxuICogQHBhcmFtIHtBcnJheTxTdGFja0l0ZW0+fSBzdGFja1xuICogQHBhcmFtIHsndW5kbyd8J3JlZG8nfSBldmVudFR5cGVcbiAqIEByZXR1cm4ge1N0YWNrSXRlbT99XG4gKi9cbmNvbnN0IHBvcFN0YWNrSXRlbSA9ICh1bmRvTWFuYWdlciwgc3RhY2ssIGV2ZW50VHlwZSkgPT4ge1xuICAvKipcbiAgICogS2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgdHJhbnNhY3Rpb24gc28gd2UgY2FuIGZpcmUgdGhlIGV2ZW50IHdpdGggdGhlIGNoYW5nZWRQYXJlbnRUeXBlc1xuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgbGV0IF90ciA9IG51bGw7XG4gIGNvbnN0IGRvYyA9IHVuZG9NYW5hZ2VyLmRvYztcbiAgY29uc3Qgc2NvcGUgPSB1bmRvTWFuYWdlci5zY29wZTtcbiAgdHJhbnNhY3QoZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDAgJiYgdW5kb01hbmFnZXIuY3VyclN0YWNrSXRlbSA9PT0gbnVsbCkge1xuICAgICAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmU7XG4gICAgICBjb25zdCBzdGFja0l0ZW0gPSAvKiogQHR5cGUge1N0YWNrSXRlbX0gKi8gKHN0YWNrLnBvcCgpKTtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge1NldDxJdGVtPn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgaXRlbXNUb1JlZG8gPSBuZXcgU2V0KCk7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtBcnJheTxJdGVtPn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgaXRlbXNUb0RlbGV0ZSA9IFtdO1xuICAgICAgbGV0IHBlcmZvcm1lZENoYW5nZSA9IGZhbHNlO1xuICAgICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCBzdGFja0l0ZW0uaW5zZXJ0aW9ucywgc3RydWN0ID0+IHtcbiAgICAgICAgaWYgKHN0cnVjdCBpbnN0YW5jZW9mIEl0ZW0pIHtcbiAgICAgICAgICBpZiAoc3RydWN0LnJlZG9uZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGV0IHsgaXRlbSwgZGlmZiB9ID0gZm9sbG93UmVkb25lKHN0b3JlLCBzdHJ1Y3QuaWQpO1xuICAgICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICAgIGl0ZW0gPSBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQoaXRlbS5pZC5jbGllbnQsIGl0ZW0uaWQuY2xvY2sgKyBkaWZmKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJ1Y3QgPSBpdGVtO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXN0cnVjdC5kZWxldGVkICYmIHNjb3BlLnNvbWUodHlwZSA9PiB0eXBlID09PSB0cmFuc2FjdGlvbi5kb2MgfHwgaXNQYXJlbnRPZigvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodHlwZSksIC8qKiBAdHlwZSB7SXRlbX0gKi8gKHN0cnVjdCkpKSkge1xuICAgICAgICAgICAgaXRlbXNUb0RlbGV0ZS5wdXNoKHN0cnVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgc3RhY2tJdGVtLmRlbGV0aW9ucywgc3RydWN0ID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHN0cnVjdCBpbnN0YW5jZW9mIEl0ZW0gJiZcbiAgICAgICAgICBzY29wZS5zb21lKHR5cGUgPT4gdHlwZSA9PT0gdHJhbnNhY3Rpb24uZG9jIHx8IGlzUGFyZW50T2YoLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHR5cGUpLCBzdHJ1Y3QpKSAmJlxuICAgICAgICAgIC8vIE5ldmVyIHJlZG8gc3RydWN0cyBpbiBzdGFja0l0ZW0uaW5zZXJ0aW9ucyBiZWNhdXNlIHRoZXkgd2VyZSBjcmVhdGVkIGFuZCBkZWxldGVkIGluIHRoZSBzYW1lIGNhcHR1cmUgaW50ZXJ2YWwuXG4gICAgICAgICAgIWlzRGVsZXRlZChzdGFja0l0ZW0uaW5zZXJ0aW9ucywgc3RydWN0LmlkKVxuICAgICAgICApIHtcbiAgICAgICAgICBpdGVtc1RvUmVkby5hZGQoc3RydWN0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpdGVtc1RvUmVkby5mb3JFYWNoKHN0cnVjdCA9PiB7XG4gICAgICAgIHBlcmZvcm1lZENoYW5nZSA9IHJlZG9JdGVtKHRyYW5zYWN0aW9uLCBzdHJ1Y3QsIGl0ZW1zVG9SZWRvLCBzdGFja0l0ZW0uaW5zZXJ0aW9ucywgdW5kb01hbmFnZXIuaWdub3JlUmVtb3RlTWFwQ2hhbmdlcywgdW5kb01hbmFnZXIpICE9PSBudWxsIHx8IHBlcmZvcm1lZENoYW5nZTtcbiAgICAgIH0pO1xuICAgICAgLy8gV2Ugd2FudCB0byBkZWxldGUgaW4gcmV2ZXJzZSBvcmRlciBzbyB0aGF0IGNoaWxkcmVuIGFyZSBkZWxldGVkIGJlZm9yZVxuICAgICAgLy8gcGFyZW50cywgc28gd2UgaGF2ZSBtb3JlIGluZm9ybWF0aW9uIGF2YWlsYWJsZSB3aGVuIGl0ZW1zIGFyZSBmaWx0ZXJlZC5cbiAgICAgIGZvciAobGV0IGkgPSBpdGVtc1RvRGVsZXRlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1RvRGVsZXRlW2ldO1xuICAgICAgICBpZiAodW5kb01hbmFnZXIuZGVsZXRlRmlsdGVyKGl0ZW0pKSB7XG4gICAgICAgICAgaXRlbS5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgICAgIHBlcmZvcm1lZENoYW5nZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHVuZG9NYW5hZ2VyLmN1cnJTdGFja0l0ZW0gPSBwZXJmb3JtZWRDaGFuZ2UgPyBzdGFja0l0ZW0gOiBudWxsO1xuICAgIH1cbiAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkLmZvckVhY2goKHN1YlByb3BzLCB0eXBlKSA9PiB7XG4gICAgICAvLyBkZXN0cm95IHNlYXJjaCBtYXJrZXIgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAoc3ViUHJvcHMuaGFzKG51bGwpICYmIHR5cGUuX3NlYXJjaE1hcmtlcikge1xuICAgICAgICB0eXBlLl9zZWFyY2hNYXJrZXIubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfdHIgPSB0cmFuc2FjdGlvbjtcbiAgfSwgdW5kb01hbmFnZXIpO1xuICBjb25zdCByZXMgPSB1bmRvTWFuYWdlci5jdXJyU3RhY2tJdGVtO1xuICBpZiAocmVzICE9IG51bGwpIHtcbiAgICBjb25zdCBjaGFuZ2VkUGFyZW50VHlwZXMgPSBfdHIuY2hhbmdlZFBhcmVudFR5cGVzO1xuICAgIHVuZG9NYW5hZ2VyLmVtaXQoJ3N0YWNrLWl0ZW0tcG9wcGVkJywgW3sgc3RhY2tJdGVtOiByZXMsIHR5cGU6IGV2ZW50VHlwZSwgY2hhbmdlZFBhcmVudFR5cGVzLCBvcmlnaW46IHVuZG9NYW5hZ2VyIH0sIHVuZG9NYW5hZ2VyXSk7XG4gICAgdW5kb01hbmFnZXIuY3VyclN0YWNrSXRlbSA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHJlc1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBVbmRvTWFuYWdlck9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbVW5kb01hbmFnZXJPcHRpb25zLmNhcHR1cmVUaW1lb3V0PTUwMF1cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oVHJhbnNhY3Rpb24pOmJvb2xlYW59IFtVbmRvTWFuYWdlck9wdGlvbnMuY2FwdHVyZVRyYW5zYWN0aW9uXSBEbyBub3QgY2FwdHVyZSBjaGFuZ2VzIG9mIGEgVHJhbnNhY3Rpb24gaWYgcmVzdWx0IGZhbHNlLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihJdGVtKTpib29sZWFufSBbVW5kb01hbmFnZXJPcHRpb25zLmRlbGV0ZUZpbHRlcj0oKT0+dHJ1ZV0gU29tZXRpbWVzXG4gKiBpdCBpcyBuZWNlc3NhcnkgdG8gZmlsdGVyIHdoYXQgYW4gVW5kby9SZWRvIG9wZXJhdGlvbiBjYW4gZGVsZXRlLiBJZiB0aGlzXG4gKiBmaWx0ZXIgcmV0dXJucyBmYWxzZSwgdGhlIHR5cGUvaXRlbSB3b24ndCBiZSBkZWxldGVkIGV2ZW4gaXQgaXMgaW4gdGhlXG4gKiB1bmRvL3JlZG8gc2NvcGUuXG4gKiBAcHJvcGVydHkge1NldDxhbnk+fSBbVW5kb01hbmFnZXJPcHRpb25zLnRyYWNrZWRPcmlnaW5zPW5ldyBTZXQoW251bGxdKV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2lnbm9yZVJlbW90ZU1hcENoYW5nZXNdIEV4cGVyaW1lbnRhbC4gQnkgZGVmYXVsdCwgdGhlIFVuZG9NYW5hZ2VyIHdpbGwgbmV2ZXIgb3ZlcndyaXRlIHJlbW90ZSBjaGFuZ2VzLiBFbmFibGUgdGhpcyBwcm9wZXJ0eSB0byBlbmFibGUgb3ZlcndyaXRpbmcgcmVtb3RlIGNoYW5nZXMgb24ga2V5LXZhbHVlIGNoYW5nZXMgKFkuTWFwLCBwcm9wZXJ0aWVzIG9uIFkuWG1sLCBldGMuLikuXG4gKiBAcHJvcGVydHkge0RvY30gW2RvY10gVGhlIGRvY3VtZW50IHRoYXQgdGhpcyBVbmRvTWFuYWdlciBvcGVyYXRlcyBvbi4gT25seSBuZWVkZWQgaWYgdHlwZVNjb3BlIGlzIGVtcHR5LlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU3RhY2tJdGVtRXZlbnRcbiAqIEBwcm9wZXJ0eSB7U3RhY2tJdGVtfSBTdGFja0l0ZW1FdmVudC5zdGFja0l0ZW1cbiAqIEBwcm9wZXJ0eSB7YW55fSBTdGFja0l0ZW1FdmVudC5vcmlnaW5cbiAqIEBwcm9wZXJ0eSB7J3VuZG8nfCdyZWRvJ30gU3RhY2tJdGVtRXZlbnQudHlwZVxuICogQHByb3BlcnR5IHtNYXA8QWJzdHJhY3RUeXBlPFlFdmVudDxhbnk+PixBcnJheTxZRXZlbnQ8YW55Pj4+fSBTdGFja0l0ZW1FdmVudC5jaGFuZ2VkUGFyZW50VHlwZXNcbiAqL1xuXG4vKipcbiAqIEZpcmVzICdzdGFjay1pdGVtLWFkZGVkJyBldmVudCB3aGVuIGEgc3RhY2sgaXRlbSB3YXMgYWRkZWQgdG8gZWl0aGVyIHRoZSB1bmRvLSBvclxuICogdGhlIHJlZG8tc3RhY2suIFlvdSBtYXkgc3RvcmUgYWRkaXRpb25hbCBzdGFjayBpbmZvcm1hdGlvbiB2aWEgdGhlXG4gKiBtZXRhZGF0YSBwcm9wZXJ0eSBvbiBgZXZlbnQuc3RhY2tJdGVtLm1ldGFgIChpdCBpcyBhIGBNYXBgIG9mIG1ldGFkYXRhIHByb3BlcnRpZXMpLlxuICogRmlyZXMgJ3N0YWNrLWl0ZW0tcG9wcGVkJyBldmVudCB3aGVuIGEgc3RhY2sgaXRlbSB3YXMgcG9wcGVkIGZyb20gZWl0aGVyIHRoZVxuICogdW5kby0gb3IgdGhlIHJlZG8tc3RhY2suIFlvdSBtYXkgcmVzdG9yZSB0aGUgc2F2ZWQgc3RhY2sgaW5mb3JtYXRpb24gZnJvbSBgZXZlbnQuc3RhY2tJdGVtLm1ldGFgLlxuICpcbiAqIEBleHRlbmRzIHtPYnNlcnZhYmxlVjI8eydzdGFjay1pdGVtLWFkZGVkJzpmdW5jdGlvbihTdGFja0l0ZW1FdmVudCwgVW5kb01hbmFnZXIpOnZvaWQsICdzdGFjay1pdGVtLXBvcHBlZCc6IGZ1bmN0aW9uKFN0YWNrSXRlbUV2ZW50LCBVbmRvTWFuYWdlcik6dm9pZCwgJ3N0YWNrLWNsZWFyZWQnOiBmdW5jdGlvbih7IHVuZG9TdGFja0NsZWFyZWQ6IGJvb2xlYW4sIHJlZG9TdGFja0NsZWFyZWQ6IGJvb2xlYW4gfSk6dm9pZCwgJ3N0YWNrLWl0ZW0tdXBkYXRlZCc6IGZ1bmN0aW9uKFN0YWNrSXRlbUV2ZW50LCBVbmRvTWFuYWdlcik6dm9pZCB9Pn1cbiAqL1xuY2xhc3MgVW5kb01hbmFnZXIgZXh0ZW5kcyBPYnNlcnZhYmxlVjIge1xuICAvKipcbiAgICogQHBhcmFtIHtEb2N8QWJzdHJhY3RUeXBlPGFueT58QXJyYXk8QWJzdHJhY3RUeXBlPGFueT4+fSB0eXBlU2NvcGUgTGltaXRzIHRoZSBzY29wZSBvZiB0aGUgVW5kb01hbmFnZXIuIElmIHRoaXMgaXMgc2V0IHRvIGEgeWRvYyBpbnN0YW5jZSwgYWxsIGNoYW5nZXMgb24gdGhhdCB5ZG9jIHdpbGwgYmUgdW5kb25lLiBJZiBzZXQgdG8gYSBzcGVjaWZpYyB0eXBlLCBvbmx5IGNoYW5nZXMgb24gdGhhdCB0eXBlIG9yIGl0cyBjaGlsZHJlbiB3aWxsIGJlIHVuZG9uZS4gQWxzbyBhY2NlcHRzIGFuIGFycmF5IG9mIHR5cGVzLlxuICAgKiBAcGFyYW0ge1VuZG9NYW5hZ2VyT3B0aW9uc30gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHR5cGVTY29wZSwge1xuICAgIGNhcHR1cmVUaW1lb3V0ID0gNTAwLFxuICAgIGNhcHR1cmVUcmFuc2FjdGlvbiA9IF90ciA9PiB0cnVlLFxuICAgIGRlbGV0ZUZpbHRlciA9ICgpID0+IHRydWUsXG4gICAgdHJhY2tlZE9yaWdpbnMgPSBuZXcgU2V0KFtudWxsXSksXG4gICAgaWdub3JlUmVtb3RlTWFwQ2hhbmdlcyA9IGZhbHNlLFxuICAgIGRvYyA9IC8qKiBAdHlwZSB7RG9jfSAqLyAoYXJyYXkuaXNBcnJheSh0eXBlU2NvcGUpID8gdHlwZVNjb3BlWzBdLmRvYyA6IHR5cGVTY29wZSBpbnN0YW5jZW9mIERvYyA/IHR5cGVTY29wZSA6IHR5cGVTY29wZS5kb2MpXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PEFic3RyYWN0VHlwZTxhbnk+IHwgRG9jPn1cbiAgICAgKi9cbiAgICB0aGlzLnNjb3BlID0gW107XG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgdGhpcy5hZGRUb1Njb3BlKHR5cGVTY29wZSk7XG4gICAgdGhpcy5kZWxldGVGaWx0ZXIgPSBkZWxldGVGaWx0ZXI7XG4gICAgdHJhY2tlZE9yaWdpbnMuYWRkKHRoaXMpO1xuICAgIHRoaXMudHJhY2tlZE9yaWdpbnMgPSB0cmFja2VkT3JpZ2lucztcbiAgICB0aGlzLmNhcHR1cmVUcmFuc2FjdGlvbiA9IGNhcHR1cmVUcmFuc2FjdGlvbjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8U3RhY2tJdGVtPn1cbiAgICAgKi9cbiAgICB0aGlzLnVuZG9TdGFjayA9IFtdO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxTdGFja0l0ZW0+fVxuICAgICAqL1xuICAgIHRoaXMucmVkb1N0YWNrID0gW107XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY2xpZW50IGlzIGN1cnJlbnRseSB1bmRvaW5nIChjYWxsaW5nIFVuZG9NYW5hZ2VyLnVuZG8pXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnVuZG9pbmcgPSBmYWxzZTtcbiAgICB0aGlzLnJlZG9pbmcgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudGx5IHBvcHBlZCBzdGFjayBpdGVtIGlmIFVuZG9NYW5hZ2VyLnVuZG9pbmcgb3IgVW5kb01hbmFnZXIucmVkb2luZ1xuICAgICAqXG4gICAgICogQHR5cGUge1N0YWNrSXRlbXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY3VyclN0YWNrSXRlbSA9IG51bGw7XG4gICAgdGhpcy5sYXN0Q2hhbmdlID0gMDtcbiAgICB0aGlzLmlnbm9yZVJlbW90ZU1hcENoYW5nZXMgPSBpZ25vcmVSZW1vdGVNYXBDaGFuZ2VzO1xuICAgIHRoaXMuY2FwdHVyZVRpbWVvdXQgPSBjYXB0dXJlVGltZW91dDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIHRoaXMuYWZ0ZXJUcmFuc2FjdGlvbkhhbmRsZXIgPSB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAvLyBPbmx5IHRyYWNrIGNlcnRhaW4gdHJhbnNhY3Rpb25zXG4gICAgICBpZiAoXG4gICAgICAgICF0aGlzLmNhcHR1cmVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikgfHxcbiAgICAgICAgIXRoaXMuc2NvcGUuc29tZSh0eXBlID0+IHRyYW5zYWN0aW9uLmNoYW5nZWRQYXJlbnRUeXBlcy5oYXMoLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHR5cGUpKSB8fCB0eXBlID09PSB0aGlzLmRvYykgfHxcbiAgICAgICAgKCF0aGlzLnRyYWNrZWRPcmlnaW5zLmhhcyh0cmFuc2FjdGlvbi5vcmlnaW4pICYmICghdHJhbnNhY3Rpb24ub3JpZ2luIHx8ICF0aGlzLnRyYWNrZWRPcmlnaW5zLmhhcyh0cmFuc2FjdGlvbi5vcmlnaW4uY29uc3RydWN0b3IpKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IHVuZG9pbmcgPSB0aGlzLnVuZG9pbmc7XG4gICAgICBjb25zdCByZWRvaW5nID0gdGhpcy5yZWRvaW5nO1xuICAgICAgY29uc3Qgc3RhY2sgPSB1bmRvaW5nID8gdGhpcy5yZWRvU3RhY2sgOiB0aGlzLnVuZG9TdGFjaztcbiAgICAgIGlmICh1bmRvaW5nKSB7XG4gICAgICAgIHRoaXMuc3RvcENhcHR1cmluZygpOyAvLyBuZXh0IHVuZG8gc2hvdWxkIG5vdCBiZSBhcHBlbmRlZCB0byBsYXN0IHN0YWNrIGl0ZW1cbiAgICAgIH0gZWxzZSBpZiAoIXJlZG9pbmcpIHtcbiAgICAgICAgLy8gbmVpdGhlciB1bmRvaW5nIG5vciByZWRvaW5nOiBkZWxldGUgcmVkb1N0YWNrXG4gICAgICAgIHRoaXMuY2xlYXIoZmFsc2UsIHRydWUpO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5zZXJ0aW9ucyA9IG5ldyBEZWxldGVTZXQoKTtcbiAgICAgIHRyYW5zYWN0aW9uLmFmdGVyU3RhdGUuZm9yRWFjaCgoZW5kQ2xvY2ssIGNsaWVudCkgPT4ge1xuICAgICAgICBjb25zdCBzdGFydENsb2NrID0gdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGNsaWVudCkgfHwgMDtcbiAgICAgICAgY29uc3QgbGVuID0gZW5kQ2xvY2sgLSBzdGFydENsb2NrO1xuICAgICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAgIGFkZFRvRGVsZXRlU2V0KGluc2VydGlvbnMsIGNsaWVudCwgc3RhcnRDbG9jaywgbGVuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCBub3cgPSB0aW1lLmdldFVuaXhUaW1lKCk7XG4gICAgICBsZXQgZGlkQWRkID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5sYXN0Q2hhbmdlID4gMCAmJiBub3cgLSB0aGlzLmxhc3RDaGFuZ2UgPCB0aGlzLmNhcHR1cmVUaW1lb3V0ICYmIHN0YWNrLmxlbmd0aCA+IDAgJiYgIXVuZG9pbmcgJiYgIXJlZG9pbmcpIHtcbiAgICAgICAgLy8gYXBwZW5kIGNoYW5nZSB0byBsYXN0IHN0YWNrIG9wXG4gICAgICAgIGNvbnN0IGxhc3RPcCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBsYXN0T3AuZGVsZXRpb25zID0gbWVyZ2VEZWxldGVTZXRzKFtsYXN0T3AuZGVsZXRpb25zLCB0cmFuc2FjdGlvbi5kZWxldGVTZXRdKTtcbiAgICAgICAgbGFzdE9wLmluc2VydGlvbnMgPSBtZXJnZURlbGV0ZVNldHMoW2xhc3RPcC5pbnNlcnRpb25zLCBpbnNlcnRpb25zXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgc3RhY2sgb3BcbiAgICAgICAgc3RhY2sucHVzaChuZXcgU3RhY2tJdGVtKHRyYW5zYWN0aW9uLmRlbGV0ZVNldCwgaW5zZXJ0aW9ucykpO1xuICAgICAgICBkaWRBZGQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCF1bmRvaW5nICYmICFyZWRvaW5nKSB7XG4gICAgICAgIHRoaXMubGFzdENoYW5nZSA9IG5vdztcbiAgICAgIH1cbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IGRlbGV0ZWQgc3RydWN0cyBhcmUgbm90IGdjJ2RcbiAgICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24uZGVsZXRlU2V0LCAvKiogQHBhcmFtIHtJdGVtfEdDfSBpdGVtICovIGl0ZW0gPT4ge1xuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEl0ZW0gJiYgdGhpcy5zY29wZS5zb21lKHR5cGUgPT4gdHlwZSA9PT0gdHJhbnNhY3Rpb24uZG9jIHx8IGlzUGFyZW50T2YoLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHR5cGUpLCBpdGVtKSkpIHtcbiAgICAgICAgICBrZWVwSXRlbShpdGVtLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtbU3RhY2tJdGVtRXZlbnQsIFVuZG9NYW5hZ2VyXX1cbiAgICAgICAqL1xuICAgICAgY29uc3QgY2hhbmdlRXZlbnQgPSBbeyBzdGFja0l0ZW06IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLCBvcmlnaW46IHRyYW5zYWN0aW9uLm9yaWdpbiwgdHlwZTogdW5kb2luZyA/ICdyZWRvJyA6ICd1bmRvJywgY2hhbmdlZFBhcmVudFR5cGVzOiB0cmFuc2FjdGlvbi5jaGFuZ2VkUGFyZW50VHlwZXMgfSwgdGhpc107XG4gICAgICBpZiAoZGlkQWRkKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnc3RhY2staXRlbS1hZGRlZCcsIGNoYW5nZUV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdCgnc3RhY2staXRlbS11cGRhdGVkJywgY2hhbmdlRXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5kb2Mub24oJ2FmdGVyVHJhbnNhY3Rpb24nLCB0aGlzLmFmdGVyVHJhbnNhY3Rpb25IYW5kbGVyKTtcbiAgICB0aGlzLmRvYy5vbignZGVzdHJveScsICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dGVuZCB0aGUgc2NvcGUuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8QWJzdHJhY3RUeXBlPGFueT4gfCBEb2M+IHwgQWJzdHJhY3RUeXBlPGFueT4gfCBEb2N9IHl0eXBlc1xuICAgKi9cbiAgYWRkVG9TY29wZSAoeXR5cGVzKSB7XG4gICAgY29uc3QgdG1wU2V0ID0gbmV3IFNldCh0aGlzLnNjb3BlKTtcbiAgICB5dHlwZXMgPSBhcnJheS5pc0FycmF5KHl0eXBlcykgPyB5dHlwZXMgOiBbeXR5cGVzXTtcbiAgICB5dHlwZXMuZm9yRWFjaCh5dHlwZSA9PiB7XG4gICAgICBpZiAoIXRtcFNldC5oYXMoeXR5cGUpKSB7XG4gICAgICAgIHRtcFNldC5hZGQoeXR5cGUpO1xuICAgICAgICBpZiAoeXR5cGUgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUgPyB5dHlwZS5kb2MgIT09IHRoaXMuZG9jIDogeXR5cGUgIT09IHRoaXMuZG9jKSBsb2dnaW5nLndhcm4oJ1t5anMjNTA5XSBOb3Qgc2FtZSBZLkRvYycpOyAvLyB1c2UgTXVsdGlEb2NVbmRvTWFuYWdlciBpbnN0ZWFkLiBhbHNvIHNlZSBodHRwczovL2dpdGh1Yi5jb20veWpzL3lqcy9pc3N1ZXMvNTA5XG4gICAgICAgIHRoaXMuc2NvcGUucHVzaCh5dHlwZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IG9yaWdpblxuICAgKi9cbiAgYWRkVHJhY2tlZE9yaWdpbiAob3JpZ2luKSB7XG4gICAgdGhpcy50cmFja2VkT3JpZ2lucy5hZGQob3JpZ2luKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gb3JpZ2luXG4gICAqL1xuICByZW1vdmVUcmFja2VkT3JpZ2luIChvcmlnaW4pIHtcbiAgICB0aGlzLnRyYWNrZWRPcmlnaW5zLmRlbGV0ZShvcmlnaW4pO1xuICB9XG5cbiAgY2xlYXIgKGNsZWFyVW5kb1N0YWNrID0gdHJ1ZSwgY2xlYXJSZWRvU3RhY2sgPSB0cnVlKSB7XG4gICAgaWYgKChjbGVhclVuZG9TdGFjayAmJiB0aGlzLmNhblVuZG8oKSkgfHwgKGNsZWFyUmVkb1N0YWNrICYmIHRoaXMuY2FuUmVkbygpKSkge1xuICAgICAgdGhpcy5kb2MudHJhbnNhY3QodHIgPT4ge1xuICAgICAgICBpZiAoY2xlYXJVbmRvU3RhY2spIHtcbiAgICAgICAgICB0aGlzLnVuZG9TdGFjay5mb3JFYWNoKGl0ZW0gPT4gY2xlYXJVbmRvTWFuYWdlclN0YWNrSXRlbSh0ciwgdGhpcywgaXRlbSkpO1xuICAgICAgICAgIHRoaXMudW5kb1N0YWNrID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsZWFyUmVkb1N0YWNrKSB7XG4gICAgICAgICAgdGhpcy5yZWRvU3RhY2suZm9yRWFjaChpdGVtID0+IGNsZWFyVW5kb01hbmFnZXJTdGFja0l0ZW0odHIsIHRoaXMsIGl0ZW0pKTtcbiAgICAgICAgICB0aGlzLnJlZG9TdGFjayA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnc3RhY2stY2xlYXJlZCcsIFt7IHVuZG9TdGFja0NsZWFyZWQ6IGNsZWFyVW5kb1N0YWNrLCByZWRvU3RhY2tDbGVhcmVkOiBjbGVhclJlZG9TdGFjayB9XSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVW5kb01hbmFnZXIgbWVyZ2VzIFVuZG8tU3RhY2tJdGVtIGlmIHRoZXkgYXJlIGNyZWF0ZWQgd2l0aGluIHRpbWUtZ2FwXG4gICAqIHNtYWxsZXIgdGhhbiBgb3B0aW9ucy5jYXB0dXJlVGltZW91dGAuIENhbGwgYHVtLnN0b3BDYXB0dXJpbmcoKWAgc28gdGhhdCB0aGUgbmV4dFxuICAgKiBTdGFja0l0ZW0gd29uJ3QgYmUgbWVyZ2VkLlxuICAgKlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgICAgLy8gd2l0aG91dCBzdG9wQ2FwdHVyaW5nXG4gICAqICAgICB5dGV4dC5pbnNlcnQoMCwgJ2EnKVxuICAgKiAgICAgeXRleHQuaW5zZXJ0KDEsICdiJylcbiAgICogICAgIHVtLnVuZG8oKVxuICAgKiAgICAgeXRleHQudG9TdHJpbmcoKSAvLyA9PiAnJyAobm90ZSB0aGF0ICdhYicgd2FzIHJlbW92ZWQpXG4gICAqICAgICAvLyB3aXRoIHN0b3BDYXB0dXJpbmdcbiAgICogICAgIHl0ZXh0Lmluc2VydCgwLCAnYScpXG4gICAqICAgICB1bS5zdG9wQ2FwdHVyaW5nKClcbiAgICogICAgIHl0ZXh0Lmluc2VydCgwLCAnYicpXG4gICAqICAgICB1bS51bmRvKClcbiAgICogICAgIHl0ZXh0LnRvU3RyaW5nKCkgLy8gPT4gJ2EnIChub3RlIHRoYXQgb25seSAnYicgd2FzIHJlbW92ZWQpXG4gICAqXG4gICAqL1xuICBzdG9wQ2FwdHVyaW5nICgpIHtcbiAgICB0aGlzLmxhc3RDaGFuZ2UgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFVuZG8gbGFzdCBjaGFuZ2VzIG9uIHR5cGUuXG4gICAqXG4gICAqIEByZXR1cm4ge1N0YWNrSXRlbT99IFJldHVybnMgU3RhY2tJdGVtIGlmIGEgY2hhbmdlIHdhcyBhcHBsaWVkXG4gICAqL1xuICB1bmRvICgpIHtcbiAgICB0aGlzLnVuZG9pbmcgPSB0cnVlO1xuICAgIGxldCByZXM7XG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IHBvcFN0YWNrSXRlbSh0aGlzLCB0aGlzLnVuZG9TdGFjaywgJ3VuZG8nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy51bmRvaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWRvIGxhc3QgdW5kbyBvcGVyYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge1N0YWNrSXRlbT99IFJldHVybnMgU3RhY2tJdGVtIGlmIGEgY2hhbmdlIHdhcyBhcHBsaWVkXG4gICAqL1xuICByZWRvICgpIHtcbiAgICB0aGlzLnJlZG9pbmcgPSB0cnVlO1xuICAgIGxldCByZXM7XG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IHBvcFN0YWNrSXRlbSh0aGlzLCB0aGlzLnJlZG9TdGFjaywgJ3JlZG8nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5yZWRvaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBBcmUgdW5kbyBzdGVwcyBhdmFpbGFibGU/XG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB1bmRvIGlzIHBvc3NpYmxlXG4gICAqL1xuICBjYW5VbmRvICgpIHtcbiAgICByZXR1cm4gdGhpcy51bmRvU3RhY2subGVuZ3RoID4gMFxuICB9XG5cbiAgLyoqXG4gICAqIEFyZSByZWRvIHN0ZXBzIGF2YWlsYWJsZT9cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlZG8gaXMgcG9zc2libGVcbiAgICovXG4gIGNhblJlZG8gKCkge1xuICAgIHJldHVybiB0aGlzLnJlZG9TdGFjay5sZW5ndGggPiAwXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLnRyYWNrZWRPcmlnaW5zLmRlbGV0ZSh0aGlzKTtcbiAgICB0aGlzLmRvYy5vZmYoJ2FmdGVyVHJhbnNhY3Rpb24nLCB0aGlzLmFmdGVyVHJhbnNhY3Rpb25IYW5kbGVyKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICovXG5mdW5jdGlvbiAqIGxhenlTdHJ1Y3RSZWFkZXJHZW5lcmF0b3IgKGRlY29kZXIpIHtcbiAgY29uc3QgbnVtT2ZTdGF0ZVVwZGF0ZXMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1PZlN0YXRlVXBkYXRlczsgaSsrKSB7XG4gICAgY29uc3QgbnVtYmVyT2ZTdHJ1Y3RzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgY29uc3QgY2xpZW50ID0gZGVjb2Rlci5yZWFkQ2xpZW50KCk7XG4gICAgbGV0IGNsb2NrID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlN0cnVjdHM7IGkrKykge1xuICAgICAgY29uc3QgaW5mbyA9IGRlY29kZXIucmVhZEluZm8oKTtcbiAgICAgIC8vIEB0b2RvIHVzZSBzd2l0Y2ggaW5zdGVhZCBvZiBpZnNcbiAgICAgIGlmIChpbmZvID09PSAxMCkge1xuICAgICAgICBjb25zdCBsZW4gPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICAgICAgeWllbGQgbmV3IFNraXAoY3JlYXRlSUQoY2xpZW50LCBjbG9jayksIGxlbik7XG4gICAgICAgIGNsb2NrICs9IGxlbjtcbiAgICAgIH0gZWxzZSBpZiAoKGJpbmFyeS5CSVRTNSAmIGluZm8pICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGNhbnRDb3B5UGFyZW50SW5mbyA9IChpbmZvICYgKGJpbmFyeS5CSVQ3IHwgYmluYXJ5LkJJVDgpKSA9PT0gMDtcbiAgICAgICAgLy8gSWYgcGFyZW50ID0gbnVsbCBhbmQgbmVpdGhlciBsZWZ0IG5vciByaWdodCBhcmUgZGVmaW5lZCwgdGhlbiB3ZSBrbm93IHRoYXQgYHBhcmVudGAgaXMgY2hpbGQgb2YgYHlgXG4gICAgICAgIC8vIGFuZCB3ZSByZWFkIHRoZSBuZXh0IHN0cmluZyBhcyBwYXJlbnRZS2V5LlxuICAgICAgICAvLyBJdCBpbmRpY2F0ZXMgaG93IHdlIHN0b3JlL3JldHJpZXZlIHBhcmVudCBmcm9tIGB5LnNoYXJlYFxuICAgICAgICAvLyBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICAgIGNvbnN0IHN0cnVjdCA9IG5ldyBJdGVtKFxuICAgICAgICAgIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLFxuICAgICAgICAgIG51bGwsIC8vIGxlZnRcbiAgICAgICAgICAoaW5mbyAmIGJpbmFyeS5CSVQ4KSA9PT0gYmluYXJ5LkJJVDggPyBkZWNvZGVyLnJlYWRMZWZ0SUQoKSA6IG51bGwsIC8vIG9yaWdpblxuICAgICAgICAgIG51bGwsIC8vIHJpZ2h0XG4gICAgICAgICAgKGluZm8gJiBiaW5hcnkuQklUNykgPT09IGJpbmFyeS5CSVQ3ID8gZGVjb2Rlci5yZWFkUmlnaHRJRCgpIDogbnVsbCwgLy8gcmlnaHQgb3JpZ2luXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSBGb3JjZSB3cml0aW5nIGEgc3RyaW5nIGhlcmUuXG4gICAgICAgICAgY2FudENvcHlQYXJlbnRJbmZvID8gKGRlY29kZXIucmVhZFBhcmVudEluZm8oKSA/IGRlY29kZXIucmVhZFN0cmluZygpIDogZGVjb2Rlci5yZWFkTGVmdElEKCkpIDogbnVsbCwgLy8gcGFyZW50XG4gICAgICAgICAgY2FudENvcHlQYXJlbnRJbmZvICYmIChpbmZvICYgYmluYXJ5LkJJVDYpID09PSBiaW5hcnkuQklUNiA/IGRlY29kZXIucmVhZFN0cmluZygpIDogbnVsbCwgLy8gcGFyZW50U3ViXG4gICAgICAgICAgcmVhZEl0ZW1Db250ZW50KGRlY29kZXIsIGluZm8pIC8vIGl0ZW0gY29udGVudFxuICAgICAgICApO1xuICAgICAgICB5aWVsZCBzdHJ1Y3Q7XG4gICAgICAgIGNsb2NrICs9IHN0cnVjdC5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBsZW4gPSBkZWNvZGVyLnJlYWRMZW4oKTtcbiAgICAgICAgeWllbGQgbmV3IEdDKGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLCBsZW4pO1xuICAgICAgICBjbG9jayArPSBsZW47XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIExhenlTdHJ1Y3RSZWFkZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBmaWx0ZXJTa2lwc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGRlY29kZXIsIGZpbHRlclNraXBzKSB7XG4gICAgdGhpcy5nZW4gPSBsYXp5U3RydWN0UmVhZGVyR2VuZXJhdG9yKGRlY29kZXIpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgSXRlbSB8IFNraXAgfCBHQ31cbiAgICAgKi9cbiAgICB0aGlzLmN1cnIgPSBudWxsO1xuICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuZmlsdGVyU2tpcHMgPSBmaWx0ZXJTa2lwcztcbiAgICB0aGlzLm5leHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJdGVtIHwgR0MgfCBTa2lwIHxudWxsfVxuICAgKi9cbiAgbmV4dCAoKSB7XG4gICAgLy8gaWdub3JlIFwiU2tpcFwiIHN0cnVjdHNcbiAgICBkbyB7XG4gICAgICB0aGlzLmN1cnIgPSB0aGlzLmdlbi5uZXh0KCkudmFsdWUgfHwgbnVsbDtcbiAgICB9IHdoaWxlICh0aGlzLmZpbHRlclNraXBzICYmIHRoaXMuY3VyciAhPT0gbnVsbCAmJiB0aGlzLmN1cnIuY29uc3RydWN0b3IgPT09IFNraXApXG4gICAgcmV0dXJuIHRoaXMuY3VyclxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqXG4gKi9cbmNvbnN0IGxvZ1VwZGF0ZSA9IHVwZGF0ZSA9PiBsb2dVcGRhdGVWMih1cGRhdGUsIFVwZGF0ZURlY29kZXJWMSk7XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMiB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjF9IFtZRGVjb2Rlcl1cbiAqXG4gKi9cbmNvbnN0IGxvZ1VwZGF0ZVYyID0gKHVwZGF0ZSwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIpID0+IHtcbiAgY29uc3Qgc3RydWN0cyA9IFtdO1xuICBjb25zdCB1cGRhdGVEZWNvZGVyID0gbmV3IFlEZWNvZGVyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKSk7XG4gIGNvbnN0IGxhenlEZWNvZGVyID0gbmV3IExhenlTdHJ1Y3RSZWFkZXIodXBkYXRlRGVjb2RlciwgZmFsc2UpO1xuICBmb3IgKGxldCBjdXJyID0gbGF6eURlY29kZXIuY3VycjsgY3VyciAhPT0gbnVsbDsgY3VyciA9IGxhenlEZWNvZGVyLm5leHQoKSkge1xuICAgIHN0cnVjdHMucHVzaChjdXJyKTtcbiAgfVxuICBsb2dnaW5nLnByaW50KCdTdHJ1Y3RzOiAnLCBzdHJ1Y3RzKTtcbiAgY29uc3QgZHMgPSByZWFkRGVsZXRlU2V0KHVwZGF0ZURlY29kZXIpO1xuICBsb2dnaW5nLnByaW50KCdEZWxldGVTZXQ6ICcsIGRzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqXG4gKi9cbmNvbnN0IGRlY29kZVVwZGF0ZSA9ICh1cGRhdGUpID0+IGRlY29kZVVwZGF0ZVYyKHVwZGF0ZSwgVXBkYXRlRGVjb2RlclYxKTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRGVjb2RlclYyIHwgdHlwZW9mIFVwZGF0ZURlY29kZXJWMX0gW1lEZWNvZGVyXVxuICpcbiAqL1xuY29uc3QgZGVjb2RlVXBkYXRlVjIgPSAodXBkYXRlLCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMikgPT4ge1xuICBjb25zdCBzdHJ1Y3RzID0gW107XG4gIGNvbnN0IHVwZGF0ZURlY29kZXIgPSBuZXcgWURlY29kZXIoZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpKTtcbiAgY29uc3QgbGF6eURlY29kZXIgPSBuZXcgTGF6eVN0cnVjdFJlYWRlcih1cGRhdGVEZWNvZGVyLCBmYWxzZSk7XG4gIGZvciAobGV0IGN1cnIgPSBsYXp5RGVjb2Rlci5jdXJyOyBjdXJyICE9PSBudWxsOyBjdXJyID0gbGF6eURlY29kZXIubmV4dCgpKSB7XG4gICAgc3RydWN0cy5wdXNoKGN1cnIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RydWN0cyxcbiAgICBkczogcmVhZERlbGV0ZVNldCh1cGRhdGVEZWNvZGVyKVxuICB9XG59O1xuXG5jbGFzcyBMYXp5U3RydWN0V3JpdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZW5jb2Rlcikge1xuICAgIHRoaXMuY3VyckNsaWVudCA9IDA7XG4gICAgdGhpcy5zdGFydENsb2NrID0gMDtcbiAgICB0aGlzLndyaXR0ZW4gPSAwO1xuICAgIHRoaXMuZW5jb2RlciA9IGVuY29kZXI7XG4gICAgLyoqXG4gICAgICogV2Ugd2FudCB0byB3cml0ZSBvcGVyYXRpb25zIGxhemlseSwgYnV0IGFsc28gd2UgbmVlZCB0byBrbm93IGJlZm9yZWhhbmQgaG93IG1hbnkgb3BlcmF0aW9ucyB3ZSB3YW50IHRvIHdyaXRlIGZvciBlYWNoIGNsaWVudC5cbiAgICAgKlxuICAgICAqIFRoaXMga2luZCBvZiBtZXRhLWluZm9ybWF0aW9uICgjY2xpZW50cywgI3N0cnVjdHMtcGVyLWNsaWVudC13cml0dGVuKSBpcyB3cml0dGVuIHRvIHRoZSByZXN0RW5jb2Rlci5cbiAgICAgKlxuICAgICAqIFdlIGZyYWdtZW50IHRoZSByZXN0RW5jb2RlciBhbmQgc3RvcmUgYSBzbGljZSBvZiBpdCBwZXItY2xpZW50IHVudGlsIHdlIGtub3cgaG93IG1hbnkgY2xpZW50cyB0aGVyZSBhcmUuXG4gICAgICogV2hlbiB3ZSBmbHVzaCAodG9VaW50OEFycmF5KSB3ZSB3cml0ZSB0aGUgcmVzdEVuY29kZXIgdXNpbmcgdGhlIGZyYWdtZW50cyBhbmQgdGhlIG1ldGEtaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7QXJyYXk8eyB3cml0dGVuOiBudW1iZXIsIHJlc3RFbmNvZGVyOiBVaW50OEFycmF5IH0+fVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50U3RydWN0cyA9IFtdO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxVaW50OEFycmF5Pn0gdXBkYXRlc1xuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgbWVyZ2VVcGRhdGVzID0gdXBkYXRlcyA9PiBtZXJnZVVwZGF0ZXNWMih1cGRhdGVzLCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMSk7XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7dHlwZW9mIERTRW5jb2RlclYxIHwgdHlwZW9mIERTRW5jb2RlclYyfSBZRW5jb2RlclxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRGVjb2RlclYxIHwgdHlwZW9mIFVwZGF0ZURlY29kZXJWMn0gWURlY29kZXJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGVuY29kZVN0YXRlVmVjdG9yRnJvbVVwZGF0ZVYyID0gKHVwZGF0ZSwgWUVuY29kZXIgPSBEU0VuY29kZXJWMiwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIpID0+IHtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBZRW5jb2RlcigpO1xuICBjb25zdCB1cGRhdGVEZWNvZGVyID0gbmV3IExhenlTdHJ1Y3RSZWFkZXIobmV3IFlEZWNvZGVyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKSksIGZhbHNlKTtcbiAgbGV0IGN1cnIgPSB1cGRhdGVEZWNvZGVyLmN1cnI7XG4gIGlmIChjdXJyICE9PSBudWxsKSB7XG4gICAgbGV0IHNpemUgPSAwO1xuICAgIGxldCBjdXJyQ2xpZW50ID0gY3Vyci5pZC5jbGllbnQ7XG4gICAgbGV0IHN0b3BDb3VudGluZyA9IGN1cnIuaWQuY2xvY2sgIT09IDA7IC8vIG11c3Qgc3RhcnQgYXQgMFxuICAgIGxldCBjdXJyQ2xvY2sgPSBzdG9wQ291bnRpbmcgPyAwIDogY3Vyci5pZC5jbG9jayArIGN1cnIubGVuZ3RoO1xuICAgIGZvciAoOyBjdXJyICE9PSBudWxsOyBjdXJyID0gdXBkYXRlRGVjb2Rlci5uZXh0KCkpIHtcbiAgICAgIGlmIChjdXJyQ2xpZW50ICE9PSBjdXJyLmlkLmNsaWVudCkge1xuICAgICAgICBpZiAoY3VyckNsb2NrICE9PSAwKSB7XG4gICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIC8vIFdlIGZvdW5kIGEgbmV3IGNsaWVudFxuICAgICAgICAgIC8vIHdyaXRlIHdoYXQgd2UgaGF2ZSB0byB0aGUgZW5jb2RlclxuICAgICAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjdXJyQ2xpZW50KTtcbiAgICAgICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY3VyckNsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyQ2xpZW50ID0gY3Vyci5pZC5jbGllbnQ7XG4gICAgICAgIGN1cnJDbG9jayA9IDA7XG4gICAgICAgIHN0b3BDb3VudGluZyA9IGN1cnIuaWQuY2xvY2sgIT09IDA7XG4gICAgICB9XG4gICAgICAvLyB3ZSBpZ25vcmUgc2tpcHNcbiAgICAgIGlmIChjdXJyLmNvbnN0cnVjdG9yID09PSBTa2lwKSB7XG4gICAgICAgIHN0b3BDb3VudGluZyA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXN0b3BDb3VudGluZykge1xuICAgICAgICBjdXJyQ2xvY2sgPSBjdXJyLmlkLmNsb2NrICsgY3Vyci5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHdyaXRlIHdoYXQgd2UgaGF2ZVxuICAgIGlmIChjdXJyQ2xvY2sgIT09IDApIHtcbiAgICAgIHNpemUrKztcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjdXJyQ2xpZW50KTtcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBjdXJyQ2xvY2spO1xuICAgIH1cbiAgICAvLyBwcmVwZW5kIHRoZSBzaXplIG9mIHRoZSBzdGF0ZSB2ZWN0b3JcbiAgICBjb25zdCBlbmMgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKCk7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuYywgc2l6ZSk7XG4gICAgZW5jb2Rpbmcud3JpdGVCaW5hcnlFbmNvZGVyKGVuYywgZW5jb2Rlci5yZXN0RW5jb2Rlcik7XG4gICAgZW5jb2Rlci5yZXN0RW5jb2RlciA9IGVuYztcbiAgICByZXR1cm4gZW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxuICB9IGVsc2Uge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCAwKTtcbiAgICByZXR1cm4gZW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBlbmNvZGVTdGF0ZVZlY3RvckZyb21VcGRhdGUgPSB1cGRhdGUgPT4gZW5jb2RlU3RhdGVWZWN0b3JGcm9tVXBkYXRlVjIodXBkYXRlLCBEU0VuY29kZXJWMSwgVXBkYXRlRGVjb2RlclYxKTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRGVjb2RlclYxIHwgdHlwZW9mIFVwZGF0ZURlY29kZXJWMn0gWURlY29kZXJcbiAqIEByZXR1cm4ge3sgZnJvbTogTWFwPG51bWJlcixudW1iZXI+LCB0bzogTWFwPG51bWJlcixudW1iZXI+IH19XG4gKi9cbmNvbnN0IHBhcnNlVXBkYXRlTWV0YVYyID0gKHVwZGF0ZSwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtNYXA8bnVtYmVyLCBudW1iZXI+fVxuICAgKi9cbiAgY29uc3QgZnJvbSA9IG5ldyBNYXAoKTtcbiAgLyoqXG4gICAqIEB0eXBlIHtNYXA8bnVtYmVyLCBudW1iZXI+fVxuICAgKi9cbiAgY29uc3QgdG8gPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHVwZGF0ZURlY29kZXIgPSBuZXcgTGF6eVN0cnVjdFJlYWRlcihuZXcgWURlY29kZXIoZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpKSwgZmFsc2UpO1xuICBsZXQgY3VyciA9IHVwZGF0ZURlY29kZXIuY3VycjtcbiAgaWYgKGN1cnIgIT09IG51bGwpIHtcbiAgICBsZXQgY3VyckNsaWVudCA9IGN1cnIuaWQuY2xpZW50O1xuICAgIGxldCBjdXJyQ2xvY2sgPSBjdXJyLmlkLmNsb2NrO1xuICAgIC8vIHdyaXRlIHRoZSBiZWdpbm5pbmcgdG8gYGZyb21gXG4gICAgZnJvbS5zZXQoY3VyckNsaWVudCwgY3VyckNsb2NrKTtcbiAgICBmb3IgKDsgY3VyciAhPT0gbnVsbDsgY3VyciA9IHVwZGF0ZURlY29kZXIubmV4dCgpKSB7XG4gICAgICBpZiAoY3VyckNsaWVudCAhPT0gY3Vyci5pZC5jbGllbnQpIHtcbiAgICAgICAgLy8gV2UgZm91bmQgYSBuZXcgY2xpZW50XG4gICAgICAgIC8vIHdyaXRlIHRoZSBlbmQgdG8gYHRvYFxuICAgICAgICB0by5zZXQoY3VyckNsaWVudCwgY3VyckNsb2NrKTtcbiAgICAgICAgLy8gd3JpdGUgdGhlIGJlZ2lubmluZyB0byBgZnJvbWBcbiAgICAgICAgZnJvbS5zZXQoY3Vyci5pZC5jbGllbnQsIGN1cnIuaWQuY2xvY2spO1xuICAgICAgICAvLyB1cGRhdGUgY3VyckNsaWVudFxuICAgICAgICBjdXJyQ2xpZW50ID0gY3Vyci5pZC5jbGllbnQ7XG4gICAgICB9XG4gICAgICBjdXJyQ2xvY2sgPSBjdXJyLmlkLmNsb2NrICsgY3Vyci5sZW5ndGg7XG4gICAgfVxuICAgIC8vIHdyaXRlIHRoZSBlbmQgdG8gYHRvYFxuICAgIHRvLnNldChjdXJyQ2xpZW50LCBjdXJyQ2xvY2spO1xuICB9XG4gIHJldHVybiB7IGZyb20sIHRvIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEByZXR1cm4ge3sgZnJvbTogTWFwPG51bWJlcixudW1iZXI+LCB0bzogTWFwPG51bWJlcixudW1iZXI+IH19XG4gKi9cbmNvbnN0IHBhcnNlVXBkYXRlTWV0YSA9IHVwZGF0ZSA9PiBwYXJzZVVwZGF0ZU1ldGFWMih1cGRhdGUsIFVwZGF0ZURlY29kZXJWMSk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgaW50ZW5kZWQgdG8gc2xpY2UgYW55IGtpbmQgb2Ygc3RydWN0IGFuZCByZXRyaWV2ZSB0aGUgcmlnaHQgcGFydC5cbiAqIEl0IGRvZXMgbm90IGhhbmRsZSBzaWRlLWVmZmVjdHMsIHNvIGl0IHNob3VsZCBvbmx5IGJlIHVzZWQgYnkgdGhlIGxhenktZW5jb2Rlci5cbiAqXG4gKiBAcGFyYW0ge0l0ZW0gfCBHQyB8IFNraXB9IGxlZnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaWZmXG4gKiBAcmV0dXJuIHtJdGVtIHwgR0N9XG4gKi9cbmNvbnN0IHNsaWNlU3RydWN0ID0gKGxlZnQsIGRpZmYpID0+IHtcbiAgaWYgKGxlZnQuY29uc3RydWN0b3IgPT09IEdDKSB7XG4gICAgY29uc3QgeyBjbGllbnQsIGNsb2NrIH0gPSBsZWZ0LmlkO1xuICAgIHJldHVybiBuZXcgR0MoY3JlYXRlSUQoY2xpZW50LCBjbG9jayArIGRpZmYpLCBsZWZ0Lmxlbmd0aCAtIGRpZmYpXG4gIH0gZWxzZSBpZiAobGVmdC5jb25zdHJ1Y3RvciA9PT0gU2tpcCkge1xuICAgIGNvbnN0IHsgY2xpZW50LCBjbG9jayB9ID0gbGVmdC5pZDtcbiAgICByZXR1cm4gbmV3IFNraXAoY3JlYXRlSUQoY2xpZW50LCBjbG9jayArIGRpZmYpLCBsZWZ0Lmxlbmd0aCAtIGRpZmYpXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGVmdEl0ZW0gPSAvKiogQHR5cGUge0l0ZW19ICovIChsZWZ0KTtcbiAgICBjb25zdCB7IGNsaWVudCwgY2xvY2sgfSA9IGxlZnRJdGVtLmlkO1xuICAgIHJldHVybiBuZXcgSXRlbShcbiAgICAgIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2sgKyBkaWZmKSxcbiAgICAgIG51bGwsXG4gICAgICBjcmVhdGVJRChjbGllbnQsIGNsb2NrICsgZGlmZiAtIDEpLFxuICAgICAgbnVsbCxcbiAgICAgIGxlZnRJdGVtLnJpZ2h0T3JpZ2luLFxuICAgICAgbGVmdEl0ZW0ucGFyZW50LFxuICAgICAgbGVmdEl0ZW0ucGFyZW50U3ViLFxuICAgICAgbGVmdEl0ZW0uY29udGVudC5zcGxpY2UoZGlmZilcbiAgICApXG4gIH1cbn07XG5cbi8qKlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd29ya3Mgc2ltaWxhcmx5IHRvIGByZWFkVXBkYXRlVjJgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VWludDhBcnJheT59IHVwZGF0ZXNcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjJ9IFtZRGVjb2Rlcl1cbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZUVuY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVFbmNvZGVyVjJ9IFtZRW5jb2Rlcl1cbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IG1lcmdlVXBkYXRlc1YyID0gKHVwZGF0ZXMsIFlEZWNvZGVyID0gVXBkYXRlRGVjb2RlclYyLCBZRW5jb2RlciA9IFVwZGF0ZUVuY29kZXJWMikgPT4ge1xuICBpZiAodXBkYXRlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdXBkYXRlc1swXVxuICB9XG4gIGNvbnN0IHVwZGF0ZURlY29kZXJzID0gdXBkYXRlcy5tYXAodXBkYXRlID0+IG5ldyBZRGVjb2RlcihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSkpKTtcbiAgbGV0IGxhenlTdHJ1Y3REZWNvZGVycyA9IHVwZGF0ZURlY29kZXJzLm1hcChkZWNvZGVyID0+IG5ldyBMYXp5U3RydWN0UmVhZGVyKGRlY29kZXIsIHRydWUpKTtcblxuICAvKipcbiAgICogQHRvZG8gd2UgZG9uJ3QgbmVlZCBvZmZzZXQgYmVjYXVzZSB3ZSBhbHdheXMgc2xpY2UgYmVmb3JlXG4gICAqIEB0eXBlIHtudWxsIHwgeyBzdHJ1Y3Q6IEl0ZW0gfCBHQyB8IFNraXAsIG9mZnNldDogbnVtYmVyIH19XG4gICAqL1xuICBsZXQgY3VycldyaXRlID0gbnVsbDtcblxuICBjb25zdCB1cGRhdGVFbmNvZGVyID0gbmV3IFlFbmNvZGVyKCk7XG4gIC8vIHdyaXRlIHN0cnVjdHMgbGF6aWx5XG4gIGNvbnN0IGxhenlTdHJ1Y3RFbmNvZGVyID0gbmV3IExhenlTdHJ1Y3RXcml0ZXIodXBkYXRlRW5jb2Rlcik7XG5cbiAgLy8gTm90ZTogV2UgbmVlZCB0byBlbnN1cmUgdGhhdCBhbGwgbGF6eVN0cnVjdERlY29kZXJzIGFyZSBmdWxseSBjb25zdW1lZFxuICAvLyBOb3RlOiBTaG91bGQgbWVyZ2UgZG9jdW1lbnQgdXBkYXRlcyB3aGVuZXZlciBwb3NzaWJsZSAtIGV2ZW4gZnJvbSBkaWZmZXJlbnQgdXBkYXRlc1xuICAvLyBOb3RlOiBTaG91bGQgaGFuZGxlIHRoYXQgc29tZSBvcGVyYXRpb25zIGNhbm5vdCBiZSBhcHBsaWVkIHlldCAoKVxuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gV3JpdGUgaGlnaGVyIGNsaWVudHMgZmlyc3Qg4oeSIHNvcnQgYnkgY2xpZW50SUQgJiBjbG9jayBhbmQgcmVtb3ZlIGRlY29kZXJzIHdpdGhvdXQgY29udGVudFxuICAgIGxhenlTdHJ1Y3REZWNvZGVycyA9IGxhenlTdHJ1Y3REZWNvZGVycy5maWx0ZXIoZGVjID0+IGRlYy5jdXJyICE9PSBudWxsKTtcbiAgICBsYXp5U3RydWN0RGVjb2RlcnMuc29ydChcbiAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oYW55LGFueSk6bnVtYmVyfSAqLyAoZGVjMSwgZGVjMikgPT4ge1xuICAgICAgICBpZiAoZGVjMS5jdXJyLmlkLmNsaWVudCA9PT0gZGVjMi5jdXJyLmlkLmNsaWVudCkge1xuICAgICAgICAgIGNvbnN0IGNsb2NrRGlmZiA9IGRlYzEuY3Vyci5pZC5jbG9jayAtIGRlYzIuY3Vyci5pZC5jbG9jaztcbiAgICAgICAgICBpZiAoY2xvY2tEaWZmID09PSAwKSB7XG4gICAgICAgICAgICAvLyBAdG9kbyByZW1vdmUgcmVmZXJlbmNlcyB0byBza2lwIHNpbmNlIHRoZSBzdHJ1Y3REZWNvZGVycyBtdXN0IGZpbHRlciBTa2lwcy5cbiAgICAgICAgICAgIHJldHVybiBkZWMxLmN1cnIuY29uc3RydWN0b3IgPT09IGRlYzIuY3Vyci5jb25zdHJ1Y3RvclxuICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgOiBkZWMxLmN1cnIuY29uc3RydWN0b3IgPT09IFNraXAgPyAxIDogLTEgLy8gd2UgYXJlIGZpbHRlcmluZyBza2lwcyBhbnl3YXkuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjbG9ja0RpZmZcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlYzIuY3Vyci5pZC5jbGllbnQgLSBkZWMxLmN1cnIuaWQuY2xpZW50XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIGlmIChsYXp5U3RydWN0RGVjb2RlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjb25zdCBjdXJyRGVjb2RlciA9IGxhenlTdHJ1Y3REZWNvZGVyc1swXTtcbiAgICAvLyB3cml0ZSBmcm9tIGN1cnJEZWNvZGVyIHVudGlsIHRoZSBuZXh0IG9wZXJhdGlvbiBpcyBmcm9tIGFub3RoZXIgY2xpZW50IG9yIGlmIGZpbGxlci1zdHJ1Y3RcbiAgICAvLyB0aGVuIHdlIG5lZWQgdG8gcmVvcmRlciB0aGUgZGVjb2RlcnMgYW5kIGZpbmQgdGhlIG5leHQgb3BlcmF0aW9uIHRvIHdyaXRlXG4gICAgY29uc3QgZmlyc3RDbGllbnQgPSAvKiogQHR5cGUge0l0ZW0gfCBHQ30gKi8gKGN1cnJEZWNvZGVyLmN1cnIpLmlkLmNsaWVudDtcblxuICAgIGlmIChjdXJyV3JpdGUgIT09IG51bGwpIHtcbiAgICAgIGxldCBjdXJyID0gLyoqIEB0eXBlIHtJdGVtIHwgR0MgfCBudWxsfSAqLyAoY3VyckRlY29kZXIuY3Vycik7XG4gICAgICBsZXQgaXRlcmF0ZWQgPSBmYWxzZTtcblxuICAgICAgLy8gaXRlcmF0ZSB1bnRpbCB3ZSBmaW5kIHNvbWV0aGluZyB0aGF0IHdlIGhhdmVuJ3Qgd3JpdHRlbiBhbHJlYWR5XG4gICAgICAvLyByZW1lbWJlcjogZmlyc3QgdGhlIGhpZ2ggY2xpZW50LWlkcyBhcmUgd3JpdHRlblxuICAgICAgd2hpbGUgKGN1cnIgIT09IG51bGwgJiYgY3Vyci5pZC5jbG9jayArIGN1cnIubGVuZ3RoIDw9IGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2sgKyBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCAmJiBjdXJyLmlkLmNsaWVudCA+PSBjdXJyV3JpdGUuc3RydWN0LmlkLmNsaWVudCkge1xuICAgICAgICBjdXJyID0gY3VyckRlY29kZXIubmV4dCgpO1xuICAgICAgICBpdGVyYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIGN1cnIgPT09IG51bGwgfHwgLy8gY3VycmVudCBkZWNvZGVyIGlzIGVtcHR5XG4gICAgICAgIGN1cnIuaWQuY2xpZW50ICE9PSBmaXJzdENsaWVudCB8fCAvLyBjaGVjayB3aGV0aGVyIHRoZXJlIGlzIGFub3RoZXIgZGVjb2RlciB0aGF0IGhhcyBoYXMgdXBkYXRlcyBmcm9tIGBmaXJzdENsaWVudGBcbiAgICAgICAgKGl0ZXJhdGVkICYmIGN1cnIuaWQuY2xvY2sgPiBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrICsgY3VycldyaXRlLnN0cnVjdC5sZW5ndGgpIC8vIHRoZSBhYm92ZSB3aGlsZSBsb29wIHdhcyB1c2VkIGFuZCB3ZSBhcmUgcG90ZW50aWFsbHkgbWlzc2luZyB1cGRhdGVzXG4gICAgICApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKGZpcnN0Q2xpZW50ICE9PSBjdXJyV3JpdGUuc3RydWN0LmlkLmNsaWVudCkge1xuICAgICAgICB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlcihsYXp5U3RydWN0RW5jb2RlciwgY3VycldyaXRlLnN0cnVjdCwgY3VycldyaXRlLm9mZnNldCk7XG4gICAgICAgIGN1cnJXcml0ZSA9IHsgc3RydWN0OiBjdXJyLCBvZmZzZXQ6IDAgfTtcbiAgICAgICAgY3VyckRlY29kZXIubmV4dCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2sgKyBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCA8IGN1cnIuaWQuY2xvY2spIHtcbiAgICAgICAgICAvLyBAdG9kbyB3cml0ZSBjdXJyU3RydWN0ICYgc2V0IGN1cnJTdHJ1Y3QgPSBTa2lwKGNsb2NrID0gY3VyclN0cnVjdC5pZC5jbG9jayArIGN1cnJTdHJ1Y3QubGVuZ3RoLCBsZW5ndGggPSBjdXJyLmlkLmNsb2NrIC0gc2VsZi5jbG9jaylcbiAgICAgICAgICBpZiAoY3VycldyaXRlLnN0cnVjdC5jb25zdHJ1Y3RvciA9PT0gU2tpcCkge1xuICAgICAgICAgICAgLy8gZXh0ZW5kIGV4aXN0aW5nIHNraXBcbiAgICAgICAgICAgIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoID0gY3Vyci5pZC5jbG9jayArIGN1cnIubGVuZ3RoIC0gY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVN0cnVjdEVuY29kZXIsIGN1cnJXcml0ZS5zdHJ1Y3QsIGN1cnJXcml0ZS5vZmZzZXQpO1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGN1cnIuaWQuY2xvY2sgLSBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrIC0gY3VycldyaXRlLnN0cnVjdC5sZW5ndGg7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlIHtTa2lwfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBuZXcgU2tpcChjcmVhdGVJRChmaXJzdENsaWVudCwgY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoKSwgZGlmZik7XG4gICAgICAgICAgICBjdXJyV3JpdGUgPSB7IHN0cnVjdCwgb2Zmc2V0OiAwIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBpZiAoY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoID49IGN1cnIuaWQuY2xvY2spIHtcbiAgICAgICAgICBjb25zdCBkaWZmID0gY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoIC0gY3Vyci5pZC5jbG9jaztcbiAgICAgICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgICAgIGlmIChjdXJyV3JpdGUuc3RydWN0LmNvbnN0cnVjdG9yID09PSBTa2lwKSB7XG4gICAgICAgICAgICAgIC8vIHByZWZlciB0byBzbGljZSBTa2lwIGJlY2F1c2UgdGhlIG90aGVyIHN0cnVjdCBtaWdodCBjb250YWluIG1vcmUgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgY3VycldyaXRlLnN0cnVjdC5sZW5ndGggLT0gZGlmZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnIgPSBzbGljZVN0cnVjdChjdXJyLCBkaWZmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjdXJyV3JpdGUuc3RydWN0Lm1lcmdlV2l0aCgvKiogQHR5cGUge2FueX0gKi8gKGN1cnIpKSkge1xuICAgICAgICAgICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVN0cnVjdEVuY29kZXIsIGN1cnJXcml0ZS5zdHJ1Y3QsIGN1cnJXcml0ZS5vZmZzZXQpO1xuICAgICAgICAgICAgY3VycldyaXRlID0geyBzdHJ1Y3Q6IGN1cnIsIG9mZnNldDogMCB9O1xuICAgICAgICAgICAgY3VyckRlY29kZXIubmV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyV3JpdGUgPSB7IHN0cnVjdDogLyoqIEB0eXBlIHtJdGVtIHwgR0N9ICovIChjdXJyRGVjb2Rlci5jdXJyKSwgb2Zmc2V0OiAwIH07XG4gICAgICBjdXJyRGVjb2Rlci5uZXh0KCk7XG4gICAgfVxuICAgIGZvciAoXG4gICAgICBsZXQgbmV4dCA9IGN1cnJEZWNvZGVyLmN1cnI7XG4gICAgICBuZXh0ICE9PSBudWxsICYmIG5leHQuaWQuY2xpZW50ID09PSBmaXJzdENsaWVudCAmJiBuZXh0LmlkLmNsb2NrID09PSBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrICsgY3VycldyaXRlLnN0cnVjdC5sZW5ndGggJiYgbmV4dC5jb25zdHJ1Y3RvciAhPT0gU2tpcDtcbiAgICAgIG5leHQgPSBjdXJyRGVjb2Rlci5uZXh0KClcbiAgICApIHtcbiAgICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RFbmNvZGVyLCBjdXJyV3JpdGUuc3RydWN0LCBjdXJyV3JpdGUub2Zmc2V0KTtcbiAgICAgIGN1cnJXcml0ZSA9IHsgc3RydWN0OiBuZXh0LCBvZmZzZXQ6IDAgfTtcbiAgICB9XG4gIH1cbiAgaWYgKGN1cnJXcml0ZSAhPT0gbnVsbCkge1xuICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RFbmNvZGVyLCBjdXJyV3JpdGUuc3RydWN0LCBjdXJyV3JpdGUub2Zmc2V0KTtcbiAgICBjdXJyV3JpdGUgPSBudWxsO1xuICB9XG4gIGZpbmlzaExhenlTdHJ1Y3RXcml0aW5nKGxhenlTdHJ1Y3RFbmNvZGVyKTtcblxuICBjb25zdCBkc3MgPSB1cGRhdGVEZWNvZGVycy5tYXAoZGVjb2RlciA9PiByZWFkRGVsZXRlU2V0KGRlY29kZXIpKTtcbiAgY29uc3QgZHMgPSBtZXJnZURlbGV0ZVNldHMoZHNzKTtcbiAgd3JpdGVEZWxldGVTZXQodXBkYXRlRW5jb2RlciwgZHMpO1xuICByZXR1cm4gdXBkYXRlRW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBzdlxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRGVjb2RlclYxIHwgdHlwZW9mIFVwZGF0ZURlY29kZXJWMn0gW1lEZWNvZGVyXVxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRW5jb2RlclYxIHwgdHlwZW9mIFVwZGF0ZUVuY29kZXJWMn0gW1lFbmNvZGVyXVxuICovXG5jb25zdCBkaWZmVXBkYXRlVjIgPSAodXBkYXRlLCBzdiwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIsIFlFbmNvZGVyID0gVXBkYXRlRW5jb2RlclYyKSA9PiB7XG4gIGNvbnN0IHN0YXRlID0gZGVjb2RlU3RhdGVWZWN0b3Ioc3YpO1xuICBjb25zdCBlbmNvZGVyID0gbmV3IFlFbmNvZGVyKCk7XG4gIGNvbnN0IGxhenlTdHJ1Y3RXcml0ZXIgPSBuZXcgTGF6eVN0cnVjdFdyaXRlcihlbmNvZGVyKTtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBZRGVjb2RlcihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSkpO1xuICBjb25zdCByZWFkZXIgPSBuZXcgTGF6eVN0cnVjdFJlYWRlcihkZWNvZGVyLCBmYWxzZSk7XG4gIHdoaWxlIChyZWFkZXIuY3Vycikge1xuICAgIGNvbnN0IGN1cnIgPSByZWFkZXIuY3VycjtcbiAgICBjb25zdCBjdXJyQ2xpZW50ID0gY3Vyci5pZC5jbGllbnQ7XG4gICAgY29uc3Qgc3ZDbG9jayA9IHN0YXRlLmdldChjdXJyQ2xpZW50KSB8fCAwO1xuICAgIGlmIChyZWFkZXIuY3Vyci5jb25zdHJ1Y3RvciA9PT0gU2tpcCkge1xuICAgICAgLy8gdGhlIGZpcnN0IHdyaXR0ZW4gc3RydWN0IHNob3VsZG4ndCBiZSBhIHNraXBcbiAgICAgIHJlYWRlci5uZXh0KCk7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoY3Vyci5pZC5jbG9jayArIGN1cnIubGVuZ3RoID4gc3ZDbG9jaykge1xuICAgICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVN0cnVjdFdyaXRlciwgY3VyciwgbWF0aC5tYXgoc3ZDbG9jayAtIGN1cnIuaWQuY2xvY2ssIDApKTtcbiAgICAgIHJlYWRlci5uZXh0KCk7XG4gICAgICB3aGlsZSAocmVhZGVyLmN1cnIgJiYgcmVhZGVyLmN1cnIuaWQuY2xpZW50ID09PSBjdXJyQ2xpZW50KSB7XG4gICAgICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RXcml0ZXIsIHJlYWRlci5jdXJyLCAwKTtcbiAgICAgICAgcmVhZGVyLm5leHQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVhZCB1bnRpbCBzb21ldGhpbmcgbmV3IGNvbWVzIHVwXG4gICAgICB3aGlsZSAocmVhZGVyLmN1cnIgJiYgcmVhZGVyLmN1cnIuaWQuY2xpZW50ID09PSBjdXJyQ2xpZW50ICYmIHJlYWRlci5jdXJyLmlkLmNsb2NrICsgcmVhZGVyLmN1cnIubGVuZ3RoIDw9IHN2Q2xvY2spIHtcbiAgICAgICAgcmVhZGVyLm5leHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmluaXNoTGF6eVN0cnVjdFdyaXRpbmcobGF6eVN0cnVjdFdyaXRlcik7XG4gIC8vIHdyaXRlIGRzXG4gIGNvbnN0IGRzID0gcmVhZERlbGV0ZVNldChkZWNvZGVyKTtcbiAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgZHMpO1xuICByZXR1cm4gZW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBzdlxuICovXG5jb25zdCBkaWZmVXBkYXRlID0gKHVwZGF0ZSwgc3YpID0+IGRpZmZVcGRhdGVWMih1cGRhdGUsIHN2LCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMSk7XG5cbi8qKlxuICogQHBhcmFtIHtMYXp5U3RydWN0V3JpdGVyfSBsYXp5V3JpdGVyXG4gKi9cbmNvbnN0IGZsdXNoTGF6eVN0cnVjdFdyaXRlciA9IGxhenlXcml0ZXIgPT4ge1xuICBpZiAobGF6eVdyaXRlci53cml0dGVuID4gMCkge1xuICAgIGxhenlXcml0ZXIuY2xpZW50U3RydWN0cy5wdXNoKHsgd3JpdHRlbjogbGF6eVdyaXRlci53cml0dGVuLCByZXN0RW5jb2RlcjogZW5jb2RpbmcudG9VaW50OEFycmF5KGxhenlXcml0ZXIuZW5jb2Rlci5yZXN0RW5jb2RlcikgfSk7XG4gICAgbGF6eVdyaXRlci5lbmNvZGVyLnJlc3RFbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpO1xuICAgIGxhenlXcml0ZXIud3JpdHRlbiA9IDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtMYXp5U3RydWN0V3JpdGVyfSBsYXp5V3JpdGVyXG4gKiBAcGFyYW0ge0l0ZW0gfCBHQ30gc3RydWN0XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKi9cbmNvbnN0IHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyID0gKGxhenlXcml0ZXIsIHN0cnVjdCwgb2Zmc2V0KSA9PiB7XG4gIC8vIGZsdXNoIGN1cnIgaWYgd2Ugc3RhcnQgYW5vdGhlciBjbGllbnRcbiAgaWYgKGxhenlXcml0ZXIud3JpdHRlbiA+IDAgJiYgbGF6eVdyaXRlci5jdXJyQ2xpZW50ICE9PSBzdHJ1Y3QuaWQuY2xpZW50KSB7XG4gICAgZmx1c2hMYXp5U3RydWN0V3JpdGVyKGxhenlXcml0ZXIpO1xuICB9XG4gIGlmIChsYXp5V3JpdGVyLndyaXR0ZW4gPT09IDApIHtcbiAgICBsYXp5V3JpdGVyLmN1cnJDbGllbnQgPSBzdHJ1Y3QuaWQuY2xpZW50O1xuICAgIC8vIHdyaXRlIG5leHQgY2xpZW50XG4gICAgbGF6eVdyaXRlci5lbmNvZGVyLndyaXRlQ2xpZW50KHN0cnVjdC5pZC5jbGllbnQpO1xuICAgIC8vIHdyaXRlIHN0YXJ0Q2xvY2tcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQobGF6eVdyaXRlci5lbmNvZGVyLnJlc3RFbmNvZGVyLCBzdHJ1Y3QuaWQuY2xvY2sgKyBvZmZzZXQpO1xuICB9XG4gIHN0cnVjdC53cml0ZShsYXp5V3JpdGVyLmVuY29kZXIsIG9mZnNldCk7XG4gIGxhenlXcml0ZXIud3JpdHRlbisrO1xufTtcbi8qKlxuICogQ2FsbCB0aGlzIGZ1bmN0aW9uIHdoZW4gd2UgY29sbGVjdGVkIGFsbCBwYXJ0cyBhbmQgd2FudCB0b1xuICogcHV0IGFsbCB0aGUgcGFydHMgdG9nZXRoZXIuIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QsXG4gKiB5b3UgY2FuIGNvbnRpbnVlIHVzaW5nIHRoZSBVcGRhdGVFbmNvZGVyLlxuICpcbiAqIEBwYXJhbSB7TGF6eVN0cnVjdFdyaXRlcn0gbGF6eVdyaXRlclxuICovXG5jb25zdCBmaW5pc2hMYXp5U3RydWN0V3JpdGluZyA9IChsYXp5V3JpdGVyKSA9PiB7XG4gIGZsdXNoTGF6eVN0cnVjdFdyaXRlcihsYXp5V3JpdGVyKTtcblxuICAvLyB0aGlzIGlzIGEgZnJlc2ggZW5jb2RlciBiZWNhdXNlIHdlIGNhbGxlZCBmbHVzaEN1cnJcbiAgY29uc3QgcmVzdEVuY29kZXIgPSBsYXp5V3JpdGVyLmVuY29kZXIucmVzdEVuY29kZXI7XG5cbiAgLyoqXG4gICAqIE5vdyB3ZSBwdXQgYWxsIHRoZSBmcmFnbWVudHMgdG9nZXRoZXIuXG4gICAqIFRoaXMgd29ya3Mgc2ltaWxhcmx5IHRvIGB3cml0ZUNsaWVudHNTdHJ1Y3RzYFxuICAgKi9cblxuICAvLyB3cml0ZSAjIHN0YXRlcyB0aGF0IHdlcmUgdXBkYXRlZCAtIGkuZS4gdGhlIGNsaWVudHNcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHJlc3RFbmNvZGVyLCBsYXp5V3JpdGVyLmNsaWVudFN0cnVjdHMubGVuZ3RoKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxhenlXcml0ZXIuY2xpZW50U3RydWN0cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBhcnRTdHJ1Y3RzID0gbGF6eVdyaXRlci5jbGllbnRTdHJ1Y3RzW2ldO1xuICAgIC8qKlxuICAgICAqIFdvcmtzIHNpbWlsYXJseSB0byBgd3JpdGVTdHJ1Y3RzYFxuICAgICAqL1xuICAgIC8vIHdyaXRlICMgZW5jb2RlZCBzdHJ1Y3RzXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHJlc3RFbmNvZGVyLCBwYXJ0U3RydWN0cy53cml0dGVuKTtcbiAgICAvLyB3cml0ZSB0aGUgcmVzdCBvZiB0aGUgZnJhZ21lbnRcbiAgICBlbmNvZGluZy53cml0ZVVpbnQ4QXJyYXkocmVzdEVuY29kZXIsIHBhcnRTdHJ1Y3RzLnJlc3RFbmNvZGVyKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHtmdW5jdGlvbihJdGVtfEdDfFNraXApOkl0ZW18R0N8U2tpcH0gYmxvY2tUcmFuc2Zvcm1lclxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRGVjb2RlclYyIHwgdHlwZW9mIFVwZGF0ZURlY29kZXJWMX0gWURlY29kZXJcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZUVuY29kZXJWMiB8IHR5cGVvZiBVcGRhdGVFbmNvZGVyVjEgfSBZRW5jb2RlclxuICovXG5jb25zdCBjb252ZXJ0VXBkYXRlRm9ybWF0ID0gKHVwZGF0ZSwgYmxvY2tUcmFuc2Zvcm1lciwgWURlY29kZXIsIFlFbmNvZGVyKSA9PiB7XG4gIGNvbnN0IHVwZGF0ZURlY29kZXIgPSBuZXcgWURlY29kZXIoZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpKTtcbiAgY29uc3QgbGF6eURlY29kZXIgPSBuZXcgTGF6eVN0cnVjdFJlYWRlcih1cGRhdGVEZWNvZGVyLCBmYWxzZSk7XG4gIGNvbnN0IHVwZGF0ZUVuY29kZXIgPSBuZXcgWUVuY29kZXIoKTtcbiAgY29uc3QgbGF6eVdyaXRlciA9IG5ldyBMYXp5U3RydWN0V3JpdGVyKHVwZGF0ZUVuY29kZXIpO1xuICBmb3IgKGxldCBjdXJyID0gbGF6eURlY29kZXIuY3VycjsgY3VyciAhPT0gbnVsbDsgY3VyciA9IGxhenlEZWNvZGVyLm5leHQoKSkge1xuICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlXcml0ZXIsIGJsb2NrVHJhbnNmb3JtZXIoY3VyciksIDApO1xuICB9XG4gIGZpbmlzaExhenlTdHJ1Y3RXcml0aW5nKGxhenlXcml0ZXIpO1xuICBjb25zdCBkcyA9IHJlYWREZWxldGVTZXQodXBkYXRlRGVjb2Rlcik7XG4gIHdyaXRlRGVsZXRlU2V0KHVwZGF0ZUVuY29kZXIsIGRzKTtcbiAgcmV0dXJuIHVwZGF0ZUVuY29kZXIudG9VaW50OEFycmF5KClcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gT2JmdXNjYXRvck9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW09iZnVzY2F0b3JPcHRpb25zLmZvcm1hdHRpbmc9dHJ1ZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW09iZnVzY2F0b3JPcHRpb25zLnN1YmRvY3M9dHJ1ZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW09iZnVzY2F0b3JPcHRpb25zLnl4bWw9dHJ1ZV0gV2hldGhlciB0byBvYmZ1c2NhdGUgbm9kZU5hbWUgLyBob29rTmFtZVxuICovXG5cbi8qKlxuICogQHBhcmFtIHtPYmZ1c2NhdG9yT3B0aW9uc30gb2JmdXNjYXRvclxuICovXG5jb25zdCBjcmVhdGVPYmZ1c2NhdG9yID0gKHsgZm9ybWF0dGluZyA9IHRydWUsIHN1YmRvY3MgPSB0cnVlLCB5eG1sID0gdHJ1ZSB9ID0ge30pID0+IHtcbiAgbGV0IGkgPSAwO1xuICBjb25zdCBtYXBLZXlDYWNoZSA9IG1hcC5jcmVhdGUoKTtcbiAgY29uc3Qgbm9kZU5hbWVDYWNoZSA9IG1hcC5jcmVhdGUoKTtcbiAgY29uc3QgZm9ybWF0dGluZ0tleUNhY2hlID0gbWFwLmNyZWF0ZSgpO1xuICBjb25zdCBmb3JtYXR0aW5nVmFsdWVDYWNoZSA9IG1hcC5jcmVhdGUoKTtcbiAgZm9ybWF0dGluZ1ZhbHVlQ2FjaGUuc2V0KG51bGwsIG51bGwpOyAvLyBlbmQgb2YgYSBmb3JtYXR0aW5nIHJhbmdlIHNob3VsZCBhbHdheXMgYmUgdGhlIGVuZCBvZiBhIGZvcm1hdHRpbmcgcmFuZ2VcbiAgLyoqXG4gICAqIEBwYXJhbSB7SXRlbXxHQ3xTa2lwfSBibG9ja1xuICAgKiBAcmV0dXJuIHtJdGVtfEdDfFNraXB9XG4gICAqL1xuICByZXR1cm4gYmxvY2sgPT4ge1xuICAgIHN3aXRjaCAoYmxvY2suY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgR0M6XG4gICAgICBjYXNlIFNraXA6XG4gICAgICAgIHJldHVybiBibG9ja1xuICAgICAgY2FzZSBJdGVtOiB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSAvKiogQHR5cGUge0l0ZW19ICovIChibG9jayk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBpdGVtLmNvbnRlbnQ7XG4gICAgICAgIHN3aXRjaCAoY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgIGNhc2UgQ29udGVudERlbGV0ZWQ6XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGNhc2UgQ29udGVudFR5cGU6IHtcbiAgICAgICAgICAgIGlmICh5eG1sKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSAvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAoY29udGVudCkudHlwZTtcbiAgICAgICAgICAgICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBZWG1sRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHR5cGUubm9kZU5hbWUgPSBtYXAuc2V0SWZVbmRlZmluZWQobm9kZU5hbWVDYWNoZSwgdHlwZS5ub2RlTmFtZSwgKCkgPT4gJ25vZGUtJyArIGkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0eXBlIGluc3RhbmNlb2YgWVhtbEhvb2spIHtcbiAgICAgICAgICAgICAgICB0eXBlLmhvb2tOYW1lID0gbWFwLnNldElmVW5kZWZpbmVkKG5vZGVOYW1lQ2FjaGUsIHR5cGUuaG9va05hbWUsICgpID0+ICdob29rLScgKyBpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBDb250ZW50QW55OiB7XG4gICAgICAgICAgICBjb25zdCBjID0gLyoqIEB0eXBlIHtDb250ZW50QW55fSAqLyAoY29udGVudCk7XG4gICAgICAgICAgICBjLmFyciA9IGMuYXJyLm1hcCgoKSA9PiBpKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgQ29udGVudEJpbmFyeToge1xuICAgICAgICAgICAgY29uc3QgYyA9IC8qKiBAdHlwZSB7Q29udGVudEJpbmFyeX0gKi8gKGNvbnRlbnQpO1xuICAgICAgICAgICAgYy5jb250ZW50ID0gbmV3IFVpbnQ4QXJyYXkoW2ldKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgQ29udGVudERvYzoge1xuICAgICAgICAgICAgY29uc3QgYyA9IC8qKiBAdHlwZSB7Q29udGVudERvY30gKi8gKGNvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKHN1YmRvY3MpIHtcbiAgICAgICAgICAgICAgYy5vcHRzID0ge307XG4gICAgICAgICAgICAgIGMuZG9jLmd1aWQgPSBpICsgJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIENvbnRlbnRFbWJlZDoge1xuICAgICAgICAgICAgY29uc3QgYyA9IC8qKiBAdHlwZSB7Q29udGVudEVtYmVkfSAqLyAoY29udGVudCk7XG4gICAgICAgICAgICBjLmVtYmVkID0ge307XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6IHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjb250ZW50KTtcbiAgICAgICAgICAgIGlmIChmb3JtYXR0aW5nKSB7XG4gICAgICAgICAgICAgIGMua2V5ID0gbWFwLnNldElmVW5kZWZpbmVkKGZvcm1hdHRpbmdLZXlDYWNoZSwgYy5rZXksICgpID0+IGkgKyAnJyk7XG4gICAgICAgICAgICAgIGMudmFsdWUgPSBtYXAuc2V0SWZVbmRlZmluZWQoZm9ybWF0dGluZ1ZhbHVlQ2FjaGUsIGMudmFsdWUsICgpID0+ICh7IGkgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBDb250ZW50SlNPTjoge1xuICAgICAgICAgICAgY29uc3QgYyA9IC8qKiBAdHlwZSB7Q29udGVudEpTT059ICovIChjb250ZW50KTtcbiAgICAgICAgICAgIGMuYXJyID0gYy5hcnIubWFwKCgpID0+IGkpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBDb250ZW50U3RyaW5nOiB7XG4gICAgICAgICAgICBjb25zdCBjID0gLyoqIEB0eXBlIHtDb250ZW50U3RyaW5nfSAqLyAoY29udGVudCk7XG4gICAgICAgICAgICBjLnN0ciA9IHN0cmluZy5yZXBlYXQoKGkgJSAxMCkgKyAnJywgYy5zdHIubGVuZ3RoKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyB1bmtub3duIGNvbnRlbnQgdHlwZVxuICAgICAgICAgICAgZXJyb3IudW5leHBlY3RlZENhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS5wYXJlbnRTdWIpIHtcbiAgICAgICAgICBpdGVtLnBhcmVudFN1YiA9IG1hcC5zZXRJZlVuZGVmaW5lZChtYXBLZXlDYWNoZSwgaXRlbS5wYXJlbnRTdWIsICgpID0+IGkgKyAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgICAgICByZXR1cm4gYmxvY2tcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIHVua25vd24gYmxvY2stdHlwZVxuICAgICAgICBlcnJvci51bmV4cGVjdGVkQ2FzZSgpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIG9iZnVzY2F0ZXMgdGhlIGNvbnRlbnQgb2YgYSBZanMgdXBkYXRlLiBUaGlzIGlzIHVzZWZ1bCB0byBzaGFyZVxuICogYnVnZ3kgWWpzIGRvY3VtZW50cyB3aGlsZSBzaWduaWZpY2FudGx5IGxpbWl0aW5nIHRoZSBwb3NzaWJpbGl0eSB0aGF0IGFcbiAqIGRldmVsb3BlciBjYW4gb24gdGhlIHVzZXIuIE5vdGUgdGhhdCBpdCBtaWdodCBzdGlsbCBiZSBwb3NzaWJsZSB0byBkZWR1Y2VcbiAqIHNvbWUgaW5mb3JtYXRpb24gYnkgYW5hbHl6aW5nIHRoZSBcInN0cnVjdHVyZVwiIG9mIHRoZSBkb2N1bWVudCBvciBieSBhbmFseXppbmdcbiAqIHRoZSB0eXBpbmcgYmVoYXZpb3IgdXNpbmcgdGhlIENSRFQtcmVsYXRlZCBtZXRhZGF0YSB0aGF0IGlzIHN0aWxsIGtlcHQgZnVsbHlcbiAqIGludGFjdC5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHtPYmZ1c2NhdG9yT3B0aW9uc30gW29wdHNdXG4gKi9cbmNvbnN0IG9iZnVzY2F0ZVVwZGF0ZSA9ICh1cGRhdGUsIG9wdHMpID0+IGNvbnZlcnRVcGRhdGVGb3JtYXQodXBkYXRlLCBjcmVhdGVPYmZ1c2NhdG9yKG9wdHMpLCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMSk7XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7T2JmdXNjYXRvck9wdGlvbnN9IFtvcHRzXVxuICovXG5jb25zdCBvYmZ1c2NhdGVVcGRhdGVWMiA9ICh1cGRhdGUsIG9wdHMpID0+IGNvbnZlcnRVcGRhdGVGb3JtYXQodXBkYXRlLCBjcmVhdGVPYmZ1c2NhdG9yKG9wdHMpLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMik7XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqL1xuY29uc3QgY29udmVydFVwZGF0ZUZvcm1hdFYxVG9WMiA9IHVwZGF0ZSA9PiBjb252ZXJ0VXBkYXRlRm9ybWF0KHVwZGF0ZSwgZi5pZCwgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVFbmNvZGVyVjIpO1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKi9cbmNvbnN0IGNvbnZlcnRVcGRhdGVGb3JtYXRWMlRvVjEgPSB1cGRhdGUgPT4gY29udmVydFVwZGF0ZUZvcm1hdCh1cGRhdGUsIGYuaWQsIFVwZGF0ZURlY29kZXJWMiwgVXBkYXRlRW5jb2RlclYxKTtcblxuY29uc3QgZXJyb3JDb21wdXRlQ2hhbmdlcyA9ICdZb3UgbXVzdCBub3QgY29tcHV0ZSBjaGFuZ2VzIGFmdGVyIHRoZSBldmVudC1oYW5kbGVyIGZpcmVkLic7XG5cbi8qKlxuICogQHRlbXBsYXRlIHtBYnN0cmFjdFR5cGU8YW55Pn0gVFxuICogWUV2ZW50IGRlc2NyaWJlcyB0aGUgY2hhbmdlcyBvbiBhIFlUeXBlLlxuICovXG5jbGFzcyBZRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtUfSB0YXJnZXQgVGhlIGNoYW5nZWQgdHlwZS5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yICh0YXJnZXQsIHRyYW5zYWN0aW9uKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb24gd2hpY2ggdGhpcyBldmVudCB3YXMgY3JlYXRlZCBvbi5cbiAgICAgKiBAdHlwZSB7VH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCB0YXJnZXQgb24gd2hpY2ggdGhlIG9ic2VydmUgY2FsbGJhY2sgaXMgY2FsbGVkLlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgLyoqXG4gICAgICogVGhlIHRyYW5zYWN0aW9uIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge1RyYW5zYWN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fY2hhbmdlcyA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bGwgfCBNYXA8c3RyaW5nLCB7IGFjdGlvbjogJ2FkZCcgfCAndXBkYXRlJyB8ICdkZWxldGUnLCBvbGRWYWx1ZTogYW55LCBuZXdWYWx1ZTogYW55IH0+fVxuICAgICAqL1xuICAgIHRoaXMuX2tleXMgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgQXJyYXk8eyBpbnNlcnQ/OiBzdHJpbmcgfCBBcnJheTxhbnk+IHwgb2JqZWN0IHwgQWJzdHJhY3RUeXBlPGFueT4sIHJldGFpbj86IG51bWJlciwgZGVsZXRlPzogbnVtYmVyLCBhdHRyaWJ1dGVzPzogT2JqZWN0PHN0cmluZywgYW55PiB9Pn1cbiAgICAgKi9cbiAgICB0aGlzLl9kZWx0YSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PHN0cmluZ3xudW1iZXI+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fcGF0aCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHBhdGggZnJvbSBgeWAgdG8gdGhlIGNoYW5nZWQgdHlwZS5cbiAgICpcbiAgICogQHRvZG8gdjE0IHNob3VsZCBzdGFuZGFyZGl6ZSBvbiBwYXRoOiBBcnJheTx7cGFyZW50LCBpbmRleH0+IGJlY2F1c2UgdGhhdCBpcyBlYXNpZXIgdG8gd29yayB3aXRoLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIHByb3BlcnR5IGhvbGRzOlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIGxldCB0eXBlID0geVxuICAgKiAgIGV2ZW50LnBhdGguZm9yRWFjaChkaXIgPT4ge1xuICAgKiAgICAgdHlwZSA9IHR5cGUuZ2V0KGRpcilcbiAgICogICB9KVxuICAgKiAgIHR5cGUgPT09IGV2ZW50LnRhcmdldCAvLyA9PiB0cnVlXG4gICAqL1xuICBnZXQgcGF0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhdGggfHwgKHRoaXMuX3BhdGggPSBnZXRQYXRoVG8odGhpcy5jdXJyZW50VGFyZ2V0LCB0aGlzLnRhcmdldCkpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBzdHJ1Y3QgaXMgZGVsZXRlZCBieSB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBJbiBjb250cmFzdCB0byBjaGFuZ2UuZGVsZXRlZCwgdGhpcyBtZXRob2QgYWxzbyByZXR1cm5zIHRydWUgaWYgdGhlIHN0cnVjdCB3YXMgYWRkZWQgYW5kIHRoZW4gZGVsZXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtBYnN0cmFjdFN0cnVjdH0gc3RydWN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBkZWxldGVzIChzdHJ1Y3QpIHtcbiAgICByZXR1cm4gaXNEZWxldGVkKHRoaXMudHJhbnNhY3Rpb24uZGVsZXRlU2V0LCBzdHJ1Y3QuaWQpXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge01hcDxzdHJpbmcsIHsgYWN0aW9uOiAnYWRkJyB8ICd1cGRhdGUnIHwgJ2RlbGV0ZScsIG9sZFZhbHVlOiBhbnksIG5ld1ZhbHVlOiBhbnkgfT59XG4gICAqL1xuICBnZXQga2V5cyAoKSB7XG4gICAgaWYgKHRoaXMuX2tleXMgPT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmRvYy5fdHJhbnNhY3Rpb25DbGVhbnVwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgZXJyb3IuY3JlYXRlKGVycm9yQ29tcHV0ZUNoYW5nZXMpXG4gICAgICB9XG4gICAgICBjb25zdCBrZXlzID0gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgICBjb25zdCBjaGFuZ2VkID0gLyoqIEB0eXBlIFNldDxzdHJpbmd8bnVsbD4gKi8gKHRoaXMudHJhbnNhY3Rpb24uY2hhbmdlZC5nZXQodGFyZ2V0KSk7XG4gICAgICBjaGFuZ2VkLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGl0ZW0gPSAvKiogQHR5cGUge0l0ZW19ICovICh0YXJnZXQuX21hcC5nZXQoa2V5KSk7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQHR5cGUgeydkZWxldGUnIHwgJ2FkZCcgfCAndXBkYXRlJ31cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBsZXQgYWN0aW9uO1xuICAgICAgICAgIGxldCBvbGRWYWx1ZTtcbiAgICAgICAgICBpZiAodGhpcy5hZGRzKGl0ZW0pKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IGl0ZW0ubGVmdDtcbiAgICAgICAgICAgIHdoaWxlIChwcmV2ICE9PSBudWxsICYmIHRoaXMuYWRkcyhwcmV2KSkge1xuICAgICAgICAgICAgICBwcmV2ID0gcHJldi5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICBpZiAocHJldiAhPT0gbnVsbCAmJiB0aGlzLmRlbGV0ZXMocHJldikpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSAnZGVsZXRlJztcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IGFycmF5Lmxhc3QocHJldi5jb250ZW50LmdldENvbnRlbnQoKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChwcmV2ICE9PSBudWxsICYmIHRoaXMuZGVsZXRlcyhwcmV2KSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbiA9ICd1cGRhdGUnO1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gYXJyYXkubGFzdChwcmV2LmNvbnRlbnQuZ2V0Q29udGVudCgpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24gPSAnYWRkJztcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxldGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgIGFjdGlvbiA9ICdkZWxldGUnO1xuICAgICAgICAgICAgICBvbGRWYWx1ZSA9IGFycmF5Lmxhc3QoLyoqIEB0eXBlIHtJdGVtfSAqLyBpdGVtLmNvbnRlbnQuZ2V0Q29udGVudCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiAvLyBub3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAga2V5cy5zZXQoa2V5LCB7IGFjdGlvbiwgb2xkVmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5fa2V5cyA9IGtleXM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9rZXlzXG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhIGNvbXB1dGVkIHByb3BlcnR5LiBOb3RlIHRoYXQgdGhpcyBjYW4gb25seSBiZSBzYWZlbHkgY29tcHV0ZWQgZHVyaW5nIHRoZVxuICAgKiBldmVudCBjYWxsLiBDb21wdXRpbmcgdGhpcyBwcm9wZXJ0eSBhZnRlciBvdGhlciBjaGFuZ2VzIGhhcHBlbmVkIG1pZ2h0IHJlc3VsdCBpblxuICAgKiB1bmV4cGVjdGVkIGJlaGF2aW9yIChpbmNvcnJlY3QgY29tcHV0YXRpb24gb2YgZGVsdGFzKS4gQSBzYWZlIHdheSB0byBjb2xsZWN0IGNoYW5nZXNcbiAgICogaXMgdG8gc3RvcmUgdGhlIGBjaGFuZ2VzYCBvciB0aGUgYGRlbHRhYCBvYmplY3QuIEF2b2lkIHN0b3JpbmcgdGhlIGB0cmFuc2FjdGlvbmAgb2JqZWN0LlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8e2luc2VydD86IHN0cmluZyB8IEFycmF5PGFueT4gfCBvYmplY3QgfCBBYnN0cmFjdFR5cGU8YW55PiwgcmV0YWluPzogbnVtYmVyLCBkZWxldGU/OiBudW1iZXIsIGF0dHJpYnV0ZXM/OiBPYmplY3Q8c3RyaW5nLCBhbnk+fT59XG4gICAqL1xuICBnZXQgZGVsdGEgKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5nZXMuZGVsdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHN0cnVjdCBpcyBhZGRlZCBieSB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBJbiBjb250cmFzdCB0byBjaGFuZ2UuZGVsZXRlZCwgdGhpcyBtZXRob2QgYWxzbyByZXR1cm5zIHRydWUgaWYgdGhlIHN0cnVjdCB3YXMgYWRkZWQgYW5kIHRoZW4gZGVsZXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtBYnN0cmFjdFN0cnVjdH0gc3RydWN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhZGRzIChzdHJ1Y3QpIHtcbiAgICByZXR1cm4gc3RydWN0LmlkLmNsb2NrID49ICh0aGlzLnRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChzdHJ1Y3QuaWQuY2xpZW50KSB8fCAwKVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBjb21wdXRlZCBwcm9wZXJ0eS4gTm90ZSB0aGF0IHRoaXMgY2FuIG9ubHkgYmUgc2FmZWx5IGNvbXB1dGVkIGR1cmluZyB0aGVcbiAgICogZXZlbnQgY2FsbC4gQ29tcHV0aW5nIHRoaXMgcHJvcGVydHkgYWZ0ZXIgb3RoZXIgY2hhbmdlcyBoYXBwZW5lZCBtaWdodCByZXN1bHQgaW5cbiAgICogdW5leHBlY3RlZCBiZWhhdmlvciAoaW5jb3JyZWN0IGNvbXB1dGF0aW9uIG9mIGRlbHRhcykuIEEgc2FmZSB3YXkgdG8gY29sbGVjdCBjaGFuZ2VzXG4gICAqIGlzIHRvIHN0b3JlIHRoZSBgY2hhbmdlc2Agb3IgdGhlIGBkZWx0YWAgb2JqZWN0LiBBdm9pZCBzdG9yaW5nIHRoZSBgdHJhbnNhY3Rpb25gIG9iamVjdC5cbiAgICpcbiAgICogQHR5cGUge3thZGRlZDpTZXQ8SXRlbT4sZGVsZXRlZDpTZXQ8SXRlbT4sa2V5czpNYXA8c3RyaW5nLHthY3Rpb246J2FkZCd8J3VwZGF0ZSd8J2RlbGV0ZScsb2xkVmFsdWU6YW55fT4sZGVsdGE6QXJyYXk8e2luc2VydD86QXJyYXk8YW55PnxzdHJpbmcsIGRlbGV0ZT86bnVtYmVyLCByZXRhaW4/Om51bWJlcn0+fX1cbiAgICovXG4gIGdldCBjaGFuZ2VzICgpIHtcbiAgICBsZXQgY2hhbmdlcyA9IHRoaXMuX2NoYW5nZXM7XG4gICAgaWYgKGNoYW5nZXMgPT09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmRvYy5fdHJhbnNhY3Rpb25DbGVhbnVwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgZXJyb3IuY3JlYXRlKGVycm9yQ29tcHV0ZUNoYW5nZXMpXG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgIGNvbnN0IGFkZGVkID0gc2V0LmNyZWF0ZSgpO1xuICAgICAgY29uc3QgZGVsZXRlZCA9IHNldC5jcmVhdGUoKTtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0FycmF5PHtpbnNlcnQ6QXJyYXk8YW55Pn18e2RlbGV0ZTpudW1iZXJ9fHtyZXRhaW46bnVtYmVyfT59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGRlbHRhID0gW107XG4gICAgICBjaGFuZ2VzID0ge1xuICAgICAgICBhZGRlZCxcbiAgICAgICAgZGVsZXRlZCxcbiAgICAgICAgZGVsdGEsXG4gICAgICAgIGtleXM6IHRoaXMua2V5c1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGNoYW5nZWQgPSAvKiogQHR5cGUgU2V0PHN0cmluZ3xudWxsPiAqLyAodGhpcy50cmFuc2FjdGlvbi5jaGFuZ2VkLmdldCh0YXJnZXQpKTtcbiAgICAgIGlmIChjaGFuZ2VkLmhhcyhudWxsKSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2FueX1cbiAgICAgICAgICovXG4gICAgICAgIGxldCBsYXN0T3AgPSBudWxsO1xuICAgICAgICBjb25zdCBwYWNrT3AgPSAoKSA9PiB7XG4gICAgICAgICAgaWYgKGxhc3RPcCkge1xuICAgICAgICAgICAgZGVsdGEucHVzaChsYXN0T3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQgaXRlbSA9IHRhcmdldC5fc3RhcnQ7IGl0ZW0gIT09IG51bGw7IGl0ZW0gPSBpdGVtLnJpZ2h0KSB7XG4gICAgICAgICAgaWYgKGl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSAmJiAhdGhpcy5hZGRzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0T3AgPT09IG51bGwgfHwgbGFzdE9wLmRlbGV0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFja09wKCk7XG4gICAgICAgICAgICAgICAgbGFzdE9wID0geyBkZWxldGU6IDAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsYXN0T3AuZGVsZXRlICs9IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgICAgICBkZWxldGVkLmFkZChpdGVtKTtcbiAgICAgICAgICAgIH0gLy8gZWxzZSBub3BcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWRkcyhpdGVtKSkge1xuICAgICAgICAgICAgICBpZiAobGFzdE9wID09PSBudWxsIHx8IGxhc3RPcC5pbnNlcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhY2tPcCgpO1xuICAgICAgICAgICAgICAgIGxhc3RPcCA9IHsgaW5zZXJ0OiBbXSB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxhc3RPcC5pbnNlcnQgPSBsYXN0T3AuaW5zZXJ0LmNvbmNhdChpdGVtLmNvbnRlbnQuZ2V0Q29udGVudCgpKTtcbiAgICAgICAgICAgICAgYWRkZWQuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RPcCA9PT0gbnVsbCB8fCBsYXN0T3AucmV0YWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYWNrT3AoKTtcbiAgICAgICAgICAgICAgICBsYXN0T3AgPSB7IHJldGFpbjogMCB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxhc3RPcC5yZXRhaW4gKz0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0T3AgIT09IG51bGwgJiYgbGFzdE9wLnJldGFpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGFja09wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2NoYW5nZXMgPSBjaGFuZ2VzO1xuICAgIH1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovIChjaGFuZ2VzKVxuICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgcGF0aCBmcm9tIHRoaXMgdHlwZSB0byB0aGUgc3BlY2lmaWVkIHRhcmdldC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAvLyBgY2hpbGRgIHNob3VsZCBiZSBhY2Nlc3NpYmxlIHZpYSBgdHlwZS5nZXQocGF0aFswXSkuZ2V0KHBhdGhbMV0pLi5gXG4gKiAgIGNvbnN0IHBhdGggPSB0eXBlLmdldFBhdGhUbyhjaGlsZClcbiAqICAgLy8gYXNzdW1pbmcgYHR5cGUgaW5zdGFuY2VvZiBZQXJyYXlgXG4gKiAgIGNvbnNvbGUubG9nKHBhdGgpIC8vIG1pZ2h0IGxvb2sgbGlrZSA9PiBbMiwgJ2tleTEnXVxuICogICBjaGlsZCA9PT0gdHlwZS5nZXQocGF0aFswXSkuZ2V0KHBhdGhbMV0pXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBjaGlsZCB0YXJnZXRcbiAqIEByZXR1cm4ge0FycmF5PHN0cmluZ3xudW1iZXI+fSBQYXRoIHRvIHRoZSB0YXJnZXRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGdldFBhdGhUbyA9IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gIGNvbnN0IHBhdGggPSBbXTtcbiAgd2hpbGUgKGNoaWxkLl9pdGVtICE9PSBudWxsICYmIGNoaWxkICE9PSBwYXJlbnQpIHtcbiAgICBpZiAoY2hpbGQuX2l0ZW0ucGFyZW50U3ViICE9PSBudWxsKSB7XG4gICAgICAvLyBwYXJlbnQgaXMgbWFwLWlzaFxuICAgICAgcGF0aC51bnNoaWZ0KGNoaWxkLl9pdGVtLnBhcmVudFN1Yik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHBhcmVudCBpcyBhcnJheS1pc2hcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIGxldCBjID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGNoaWxkLl9pdGVtLnBhcmVudCkuX3N0YXJ0O1xuICAgICAgd2hpbGUgKGMgIT09IGNoaWxkLl9pdGVtICYmIGMgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFjLmRlbGV0ZWQgJiYgYy5jb3VudGFibGUpIHtcbiAgICAgICAgICBpICs9IGMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGMgPSBjLnJpZ2h0O1xuICAgICAgfVxuICAgICAgcGF0aC51bnNoaWZ0KGkpO1xuICAgIH1cbiAgICBjaGlsZCA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChjaGlsZC5faXRlbS5wYXJlbnQpO1xuICB9XG4gIHJldHVybiBwYXRoXG59O1xuXG4vKipcbiAqIGh0dHBzOi8vZG9jcy55anMuZGV2L2dldHRpbmctc3RhcnRlZC93b3JraW5nLXdpdGgtc2hhcmVkLXR5cGVzI2NhdmVhdHNcbiAqL1xuY29uc3Qgd2FyblByZW1hdHVyZUFjY2VzcyA9ICgpID0+IHsgbG9nZ2luZy53YXJuKCdJbnZhbGlkIGFjY2VzczogQWRkIFlqcyB0eXBlIHRvIGEgZG9jdW1lbnQgYmVmb3JlIHJlYWRpbmcgZGF0YS4nKTsgfTtcblxuY29uc3QgbWF4U2VhcmNoTWFya2VyID0gODA7XG5cbi8qKlxuICogQSB1bmlxdWUgdGltZXN0YW1wIHRoYXQgaWRlbnRpZmllcyBlYWNoIG1hcmtlci5cbiAqXG4gKiBUaW1lIGlzIHJlbGF0aXZlLC4uIHRoaXMgaXMgbW9yZSBsaWtlIGFuIGV2ZXItaW5jcmVhc2luZyBjbG9jay5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5sZXQgZ2xvYmFsU2VhcmNoTWFya2VyVGltZXN0YW1wID0gMDtcblxuY2xhc3MgQXJyYXlTZWFyY2hNYXJrZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtJdGVtfSBwXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKi9cbiAgY29uc3RydWN0b3IgKHAsIGluZGV4KSB7XG4gICAgcC5tYXJrZXIgPSB0cnVlO1xuICAgIHRoaXMucCA9IHA7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMudGltZXN0YW1wID0gZ2xvYmFsU2VhcmNoTWFya2VyVGltZXN0YW1wKys7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5U2VhcmNoTWFya2VyfSBtYXJrZXJcbiAqL1xuY29uc3QgcmVmcmVzaE1hcmtlclRpbWVzdGFtcCA9IG1hcmtlciA9PiB7IG1hcmtlci50aW1lc3RhbXAgPSBnbG9iYWxTZWFyY2hNYXJrZXJUaW1lc3RhbXArKzsgfTtcblxuLyoqXG4gKiBUaGlzIGlzIHJhdGhlciBjb21wbGV4IHNvIHRoaXMgZnVuY3Rpb24gaXMgdGhlIG9ubHkgdGhpbmcgdGhhdCBzaG91bGQgb3ZlcndyaXRlIGEgbWFya2VyXG4gKlxuICogQHBhcmFtIHtBcnJheVNlYXJjaE1hcmtlcn0gbWFya2VyXG4gKiBAcGFyYW0ge0l0ZW19IHBcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICovXG5jb25zdCBvdmVyd3JpdGVNYXJrZXIgPSAobWFya2VyLCBwLCBpbmRleCkgPT4ge1xuICBtYXJrZXIucC5tYXJrZXIgPSBmYWxzZTtcbiAgbWFya2VyLnAgPSBwO1xuICBwLm1hcmtlciA9IHRydWU7XG4gIG1hcmtlci5pbmRleCA9IGluZGV4O1xuICBtYXJrZXIudGltZXN0YW1wID0gZ2xvYmFsU2VhcmNoTWFya2VyVGltZXN0YW1wKys7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXlTZWFyY2hNYXJrZXI+fSBzZWFyY2hNYXJrZXJcbiAqIEBwYXJhbSB7SXRlbX0gcFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKi9cbmNvbnN0IG1hcmtQb3NpdGlvbiA9IChzZWFyY2hNYXJrZXIsIHAsIGluZGV4KSA9PiB7XG4gIGlmIChzZWFyY2hNYXJrZXIubGVuZ3RoID49IG1heFNlYXJjaE1hcmtlcikge1xuICAgIC8vIG92ZXJyaWRlIG9sZGVzdCBtYXJrZXIgKHdlIGRvbid0IHdhbnQgdG8gY3JlYXRlIG1vcmUgb2JqZWN0cylcbiAgICBjb25zdCBtYXJrZXIgPSBzZWFyY2hNYXJrZXIucmVkdWNlKChhLCBiKSA9PiBhLnRpbWVzdGFtcCA8IGIudGltZXN0YW1wID8gYSA6IGIpO1xuICAgIG92ZXJ3cml0ZU1hcmtlcihtYXJrZXIsIHAsIGluZGV4KTtcbiAgICByZXR1cm4gbWFya2VyXG4gIH0gZWxzZSB7XG4gICAgLy8gY3JlYXRlIG5ldyBtYXJrZXJcbiAgICBjb25zdCBwbSA9IG5ldyBBcnJheVNlYXJjaE1hcmtlcihwLCBpbmRleCk7XG4gICAgc2VhcmNoTWFya2VyLnB1c2gocG0pO1xuICAgIHJldHVybiBwbVxuICB9XG59O1xuXG4vKipcbiAqIFNlYXJjaCBtYXJrZXIgaGVscCB1cyB0byBmaW5kIHBvc2l0aW9ucyBpbiB0aGUgYXNzb2NpYXRpdmUgYXJyYXkgZmFzdGVyLlxuICpcbiAqIFRoZXkgc3BlZWQgdXAgdGhlIHByb2Nlc3Mgb2YgZmluZGluZyBhIHBvc2l0aW9uIHdpdGhvdXQgbXVjaCBib29ra2VlcGluZy5cbiAqXG4gKiBBIG1heGltdW0gb2YgYG1heFNlYXJjaE1hcmtlcmAgb2JqZWN0cyBhcmUgY3JlYXRlZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFsd2F5cyByZXR1cm5zIGEgcmVmcmVzaGVkIG1hcmtlciAodXBkYXRlZCB0aW1lc3RhbXApXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0geWFycmF5XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqL1xuY29uc3QgZmluZE1hcmtlciA9ICh5YXJyYXksIGluZGV4KSA9PiB7XG4gIGlmICh5YXJyYXkuX3N0YXJ0ID09PSBudWxsIHx8IGluZGV4ID09PSAwIHx8IHlhcnJheS5fc2VhcmNoTWFya2VyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBjb25zdCBtYXJrZXIgPSB5YXJyYXkuX3NlYXJjaE1hcmtlci5sZW5ndGggPT09IDAgPyBudWxsIDogeWFycmF5Ll9zZWFyY2hNYXJrZXIucmVkdWNlKChhLCBiKSA9PiBtYXRoLmFicyhpbmRleCAtIGEuaW5kZXgpIDwgbWF0aC5hYnMoaW5kZXggLSBiLmluZGV4KSA/IGEgOiBiKTtcbiAgbGV0IHAgPSB5YXJyYXkuX3N0YXJ0O1xuICBsZXQgcGluZGV4ID0gMDtcbiAgaWYgKG1hcmtlciAhPT0gbnVsbCkge1xuICAgIHAgPSBtYXJrZXIucDtcbiAgICBwaW5kZXggPSBtYXJrZXIuaW5kZXg7XG4gICAgcmVmcmVzaE1hcmtlclRpbWVzdGFtcChtYXJrZXIpOyAvLyB3ZSB1c2VkIGl0LCB3ZSBtaWdodCBuZWVkIHRvIHVzZSBpdCBhZ2FpblxuICB9XG4gIC8vIGl0ZXJhdGUgdG8gcmlnaHQgaWYgcG9zc2libGVcbiAgd2hpbGUgKHAucmlnaHQgIT09IG51bGwgJiYgcGluZGV4IDwgaW5kZXgpIHtcbiAgICBpZiAoIXAuZGVsZXRlZCAmJiBwLmNvdW50YWJsZSkge1xuICAgICAgaWYgKGluZGV4IDwgcGluZGV4ICsgcC5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHBpbmRleCArPSBwLmxlbmd0aDtcbiAgICB9XG4gICAgcCA9IHAucmlnaHQ7XG4gIH1cbiAgLy8gaXRlcmF0ZSB0byBsZWZ0IGlmIG5lY2Vzc2FyeSAobWlnaHQgYmUgdGhhdCBwaW5kZXggPiBpbmRleClcbiAgd2hpbGUgKHAubGVmdCAhPT0gbnVsbCAmJiBwaW5kZXggPiBpbmRleCkge1xuICAgIHAgPSBwLmxlZnQ7XG4gICAgaWYgKCFwLmRlbGV0ZWQgJiYgcC5jb3VudGFibGUpIHtcbiAgICAgIHBpbmRleCAtPSBwLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgLy8gd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdCBwIGNhbid0IGJlIG1lcmdlZCB3aXRoIGxlZnQsIGJlY2F1c2UgdGhhdCB3b3VsZCBzY3JldyB1cCBldmVyeXRoaW5nXG4gIC8vIGluIHRoYXQgY2FzIGp1c3QgcmV0dXJuIHdoYXQgd2UgaGF2ZSAoaXQgaXMgbW9zdCBsaWtlbHkgdGhlIGJlc3QgbWFya2VyIGFueXdheSlcbiAgLy8gaXRlcmF0ZSB0byBsZWZ0IHVudGlsIHAgY2FuJ3QgYmUgbWVyZ2VkIHdpdGggbGVmdFxuICB3aGlsZSAocC5sZWZ0ICE9PSBudWxsICYmIHAubGVmdC5pZC5jbGllbnQgPT09IHAuaWQuY2xpZW50ICYmIHAubGVmdC5pZC5jbG9jayArIHAubGVmdC5sZW5ndGggPT09IHAuaWQuY2xvY2spIHtcbiAgICBwID0gcC5sZWZ0O1xuICAgIGlmICghcC5kZWxldGVkICYmIHAuY291bnRhYmxlKSB7XG4gICAgICBwaW5kZXggLT0gcC5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgLy8gQHRvZG8gcmVtb3ZlIVxuICAvLyBhc3N1cmUgcG9zaXRpb25cbiAgLy8ge1xuICAvLyAgIGxldCBzdGFydCA9IHlhcnJheS5fc3RhcnRcbiAgLy8gICBsZXQgcG9zID0gMFxuICAvLyAgIHdoaWxlIChzdGFydCAhPT0gcCkge1xuICAvLyAgICAgaWYgKCFzdGFydC5kZWxldGVkICYmIHN0YXJ0LmNvdW50YWJsZSkge1xuICAvLyAgICAgICBwb3MgKz0gc3RhcnQubGVuZ3RoXG4gIC8vICAgICB9XG4gIC8vICAgICBzdGFydCA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKHN0YXJ0LnJpZ2h0KVxuICAvLyAgIH1cbiAgLy8gICBpZiAocG9zICE9PSBwaW5kZXgpIHtcbiAgLy8gICAgIGRlYnVnZ2VyXG4gIC8vICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dvdGNoYSBwb3NpdGlvbiBmYWlsIScpXG4gIC8vICAgfVxuICAvLyB9XG4gIC8vIGlmIChtYXJrZXIpIHtcbiAgLy8gICBpZiAod2luZG93Lmxlbmd0aHMgPT0gbnVsbCkge1xuICAvLyAgICAgd2luZG93Lmxlbmd0aHMgPSBbXVxuICAvLyAgICAgd2luZG93LmdldExlbmd0aHMgPSAoKSA9PiB3aW5kb3cubGVuZ3Rocy5zb3J0KChhLCBiKSA9PiBhIC0gYilcbiAgLy8gICB9XG4gIC8vICAgd2luZG93Lmxlbmd0aHMucHVzaChtYXJrZXIuaW5kZXggLSBwaW5kZXgpXG4gIC8vICAgY29uc29sZS5sb2coJ2Rpc3RhbmNlJywgbWFya2VyLmluZGV4IC0gcGluZGV4LCAnbGVuJywgcCAmJiBwLnBhcmVudC5sZW5ndGgpXG4gIC8vIH1cbiAgaWYgKG1hcmtlciAhPT0gbnVsbCAmJiBtYXRoLmFicyhtYXJrZXIuaW5kZXggLSBwaW5kZXgpIDwgLyoqIEB0eXBlIHtZVGV4dHxZQXJyYXk8YW55Pn0gKi8gKHAucGFyZW50KS5sZW5ndGggLyBtYXhTZWFyY2hNYXJrZXIpIHtcbiAgICAvLyBhZGp1c3QgZXhpc3RpbmcgbWFya2VyXG4gICAgb3ZlcndyaXRlTWFya2VyKG1hcmtlciwgcCwgcGluZGV4KTtcbiAgICByZXR1cm4gbWFya2VyXG4gIH0gZWxzZSB7XG4gICAgLy8gY3JlYXRlIG5ldyBtYXJrZXJcbiAgICByZXR1cm4gbWFya1Bvc2l0aW9uKHlhcnJheS5fc2VhcmNoTWFya2VyLCBwLCBwaW5kZXgpXG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIG1hcmtlcnMgd2hlbiBhIGNoYW5nZSBoYXBwZW5lZC5cbiAqXG4gKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIGRvaW5nIGEgZGVsZXRpb24hXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheVNlYXJjaE1hcmtlcj59IHNlYXJjaE1hcmtlclxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIElmIGluc2VydGlvbiwgbGVuIGlzIHBvc2l0aXZlLiBJZiBkZWxldGlvbiwgbGVuIGlzIG5lZ2F0aXZlLlxuICovXG5jb25zdCB1cGRhdGVNYXJrZXJDaGFuZ2VzID0gKHNlYXJjaE1hcmtlciwgaW5kZXgsIGxlbikgPT4ge1xuICBmb3IgKGxldCBpID0gc2VhcmNoTWFya2VyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgbSA9IHNlYXJjaE1hcmtlcltpXTtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAgICovXG4gICAgICBsZXQgcCA9IG0ucDtcbiAgICAgIHAubWFya2VyID0gZmFsc2U7XG4gICAgICAvLyBJZGVhbGx5IHdlIGp1c3Qgd2FudCB0byBkbyBhIHNpbXBsZSBwb3NpdGlvbiBjb21wYXJpc29uLCBidXQgdGhpcyB3aWxsIG9ubHkgd29yayBpZlxuICAgICAgLy8gc2VhcmNoIG1hcmtlcnMgZG9uJ3QgcG9pbnQgdG8gZGVsZXRlZCBpdGVtcyBmb3IgZm9ybWF0cy5cbiAgICAgIC8vIEl0ZXJhdGUgbWFya2VyIHRvIHByZXYgdW5kZWxldGVkIGNvdW50YWJsZSBwb3NpdGlvbiBzbyB3ZSBrbm93IHdoYXQgdG8gZG8gd2hlbiB1cGRhdGluZyBhIHBvc2l0aW9uXG4gICAgICB3aGlsZSAocCAmJiAocC5kZWxldGVkIHx8ICFwLmNvdW50YWJsZSkpIHtcbiAgICAgICAgcCA9IHAubGVmdDtcbiAgICAgICAgaWYgKHAgJiYgIXAuZGVsZXRlZCAmJiBwLmNvdW50YWJsZSkge1xuICAgICAgICAgIC8vIGFkanVzdCBwb3NpdGlvbi4gdGhlIGxvb3Agc2hvdWxkIGJyZWFrIG5vd1xuICAgICAgICAgIG0uaW5kZXggLT0gcC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwID09PSBudWxsIHx8IHAubWFya2VyID09PSB0cnVlKSB7XG4gICAgICAgIC8vIHJlbW92ZSBzZWFyY2ggbWFya2VyIGlmIHVwZGF0ZWQgcG9zaXRpb24gaXMgbnVsbCBvciBpZiBwb3NpdGlvbiBpcyBhbHJlYWR5IG1hcmtlZFxuICAgICAgICBzZWFyY2hNYXJrZXIuc3BsaWNlKGksIDEpO1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgbS5wID0gcDtcbiAgICAgIHAubWFya2VyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGluZGV4IDwgbS5pbmRleCB8fCAobGVuID4gMCAmJiBpbmRleCA9PT0gbS5pbmRleCkpIHsgLy8gYSBzaW1wbGUgaW5kZXggPD0gbS5pbmRleCBjaGVjayB3b3VsZCBhY3R1YWxseSBzdWZmaWNlXG4gICAgICBtLmluZGV4ID0gbWF0aC5tYXgoaW5kZXgsIG0uaW5kZXggKyBsZW4pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBBY2N1bXVsYXRlIGFsbCAobGlzdCkgY2hpbGRyZW4gb2YgYSB0eXBlIGFuZCByZXR1cm4gdGhlbSBhcyBhbiBBcnJheS5cbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0XG4gKiBAcmV0dXJuIHtBcnJheTxJdGVtPn1cbiAqL1xuY29uc3QgZ2V0VHlwZUNoaWxkcmVuID0gdCA9PiB7XG4gIHQuZG9jID8/IHdhcm5QcmVtYXR1cmVBY2Nlc3MoKTtcbiAgbGV0IHMgPSB0Ll9zdGFydDtcbiAgY29uc3QgYXJyID0gW107XG4gIHdoaWxlIChzKSB7XG4gICAgYXJyLnB1c2gocyk7XG4gICAgcyA9IHMucmlnaHQ7XG4gIH1cbiAgcmV0dXJuIGFyclxufTtcblxuLyoqXG4gKiBDYWxsIGV2ZW50IGxpc3RlbmVycyB3aXRoIGFuIGV2ZW50LiBUaGlzIHdpbGwgYWxzbyBhZGQgYW4gZXZlbnQgdG8gYWxsXG4gKiBwYXJlbnRzIChmb3IgYC5vYnNlcnZlRGVlcGAgaGFuZGxlcnMpLlxuICpcbiAqIEB0ZW1wbGF0ZSBFdmVudFR5cGVcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPEV2ZW50VHlwZT59IHR5cGVcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0V2ZW50VHlwZX0gZXZlbnRcbiAqL1xuY29uc3QgY2FsbFR5cGVPYnNlcnZlcnMgPSAodHlwZSwgdHJhbnNhY3Rpb24sIGV2ZW50KSA9PiB7XG4gIGNvbnN0IGNoYW5nZWRUeXBlID0gdHlwZTtcbiAgY29uc3QgY2hhbmdlZFBhcmVudFR5cGVzID0gdHJhbnNhY3Rpb24uY2hhbmdlZFBhcmVudFR5cGVzO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBtYXAuc2V0SWZVbmRlZmluZWQoY2hhbmdlZFBhcmVudFR5cGVzLCB0eXBlLCAoKSA9PiBbXSkucHVzaChldmVudCk7XG4gICAgaWYgKHR5cGUuX2l0ZW0gPT09IG51bGwpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIHR5cGUgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodHlwZS5faXRlbS5wYXJlbnQpO1xuICB9XG4gIGNhbGxFdmVudEhhbmRsZXJMaXN0ZW5lcnMoY2hhbmdlZFR5cGUuX2VILCBldmVudCwgdHJhbnNhY3Rpb24pO1xufTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgRXZlbnRUeXBlXG4gKiBBYnN0cmFjdCBZanMgVHlwZSBjbGFzc1xuICovXG5jbGFzcyBBYnN0cmFjdFR5cGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl9pdGVtID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZyxJdGVtPn1cbiAgICAgKi9cbiAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl9zdGFydCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0RvY3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZG9jID0gbnVsbDtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIC8qKlxuICAgICAqIEV2ZW50IGhhbmRsZXJzXG4gICAgICogQHR5cGUge0V2ZW50SGFuZGxlcjxFdmVudFR5cGUsVHJhbnNhY3Rpb24+fVxuICAgICAqL1xuICAgIHRoaXMuX2VIID0gY3JlYXRlRXZlbnRIYW5kbGVyKCk7XG4gICAgLyoqXG4gICAgICogRGVlcCBldmVudCBoYW5kbGVyc1xuICAgICAqIEB0eXBlIHtFdmVudEhhbmRsZXI8QXJyYXk8WUV2ZW50PGFueT4+LFRyYW5zYWN0aW9uPn1cbiAgICAgKi9cbiAgICB0aGlzLl9kRUggPSBjcmVhdGVFdmVudEhhbmRsZXIoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVsbCB8IEFycmF5PEFycmF5U2VhcmNoTWFya2VyPn1cbiAgICAgKi9cbiAgICB0aGlzLl9zZWFyY2hNYXJrZXIgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0Fic3RyYWN0VHlwZTxhbnk+fG51bGx9XG4gICAqL1xuICBnZXQgcGFyZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbSA/IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLl9pdGVtLnBhcmVudCkgOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogSW50ZWdyYXRlIHRoaXMgdHlwZSBpbnRvIHRoZSBZanMgaW5zdGFuY2UuXG4gICAqXG4gICAqICogU2F2ZSB0aGlzIHN0cnVjdCBpbiB0aGUgb3NcbiAgICogKiBUaGlzIHR5cGUgaXMgc2VudCB0byBvdGhlciBjbGllbnRcbiAgICogKiBPYnNlcnZlciBmdW5jdGlvbnMgYXJlIGZpcmVkXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jfSB5IFRoZSBZanMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtJdGVtfG51bGx9IGl0ZW1cbiAgICovXG4gIF9pbnRlZ3JhdGUgKHksIGl0ZW0pIHtcbiAgICB0aGlzLmRvYyA9IHk7XG4gICAgdGhpcy5faXRlbSA9IGl0ZW07XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QWJzdHJhY3RUeXBlPEV2ZW50VHlwZT59XG4gICAqL1xuICBfY29weSAoKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogTWFrZXMgYSBjb3B5IG9mIHRoaXMgZGF0YSB0eXBlIHRoYXQgY2FuIGJlIGluY2x1ZGVkIHNvbWV3aGVyZSBlbHNlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGNvbnRlbnQgaXMgb25seSByZWFkYWJsZSBfYWZ0ZXJfIGl0IGhhcyBiZWVuIGluY2x1ZGVkIHNvbWV3aGVyZSBpbiB0aGUgWWRvYy5cbiAgICpcbiAgICogQHJldHVybiB7QWJzdHJhY3RUeXBlPEV2ZW50VHlwZT59XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IF9lbmNvZGVyXG4gICAqL1xuICBfd3JpdGUgKF9lbmNvZGVyKSB7IH1cblxuICAvKipcbiAgICogVGhlIGZpcnN0IG5vbi1kZWxldGVkIGl0ZW1cbiAgICovXG4gIGdldCBfZmlyc3QgKCkge1xuICAgIGxldCBuID0gdGhpcy5fc3RhcnQ7XG4gICAgd2hpbGUgKG4gIT09IG51bGwgJiYgbi5kZWxldGVkKSB7XG4gICAgICBuID0gbi5yaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFlFdmVudCBhbmQgY2FsbHMgYWxsIHR5cGUgb2JzZXJ2ZXJzLlxuICAgKiBNdXN0IGJlIGltcGxlbWVudGVkIGJ5IGVhY2ggdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8bnVsbHxzdHJpbmc+fSBfcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgX3BhcmVudFN1YnMpIHtcbiAgICBpZiAoIXRyYW5zYWN0aW9uLmxvY2FsICYmIHRoaXMuX3NlYXJjaE1hcmtlcikge1xuICAgICAgdGhpcy5fc2VhcmNoTWFya2VyLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9ic2VydmUgYWxsIGV2ZW50cyB0aGF0IGFyZSBjcmVhdGVkIG9uIHRoaXMgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFdmVudFR5cGUsIFRyYW5zYWN0aW9uKTp2b2lkfSBmIE9ic2VydmVyIGZ1bmN0aW9uXG4gICAqL1xuICBvYnNlcnZlIChmKSB7XG4gICAgYWRkRXZlbnRIYW5kbGVyTGlzdGVuZXIodGhpcy5fZUgsIGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9ic2VydmUgYWxsIGV2ZW50cyB0aGF0IGFyZSBjcmVhdGVkIGJ5IHRoaXMgdHlwZSBhbmQgaXRzIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEFycmF5PFlFdmVudDxhbnk+PixUcmFuc2FjdGlvbik6dm9pZH0gZiBPYnNlcnZlciBmdW5jdGlvblxuICAgKi9cbiAgb2JzZXJ2ZURlZXAgKGYpIHtcbiAgICBhZGRFdmVudEhhbmRsZXJMaXN0ZW5lcih0aGlzLl9kRUgsIGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucmVnaXN0ZXIgYW4gb2JzZXJ2ZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oRXZlbnRUeXBlLFRyYW5zYWN0aW9uKTp2b2lkfSBmIE9ic2VydmVyIGZ1bmN0aW9uXG4gICAqL1xuICB1bm9ic2VydmUgKGYpIHtcbiAgICByZW1vdmVFdmVudEhhbmRsZXJMaXN0ZW5lcih0aGlzLl9lSCwgZik7XG4gIH1cblxuICAvKipcbiAgICogVW5yZWdpc3RlciBhbiBvYnNlcnZlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihBcnJheTxZRXZlbnQ8YW55Pj4sVHJhbnNhY3Rpb24pOnZvaWR9IGYgT2JzZXJ2ZXIgZnVuY3Rpb25cbiAgICovXG4gIHVub2JzZXJ2ZURlZXAgKGYpIHtcbiAgICByZW1vdmVFdmVudEhhbmRsZXJMaXN0ZW5lcih0aGlzLl9kRUgsIGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICB0b0pTT04gKCkge31cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRcbiAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdFNsaWNlID0gKHR5cGUsIHN0YXJ0LCBlbmQpID0+IHtcbiAgdHlwZS5kb2MgPz8gd2FyblByZW1hdHVyZUFjY2VzcygpO1xuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSB0eXBlLl9sZW5ndGggKyBzdGFydDtcbiAgfVxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCA9IHR5cGUuX2xlbmd0aCArIGVuZDtcbiAgfVxuICBsZXQgbGVuID0gZW5kIC0gc3RhcnQ7XG4gIGNvbnN0IGNzID0gW107XG4gIGxldCBuID0gdHlwZS5fc3RhcnQ7XG4gIHdoaWxlIChuICE9PSBudWxsICYmIGxlbiA+IDApIHtcbiAgICBpZiAobi5jb3VudGFibGUgJiYgIW4uZGVsZXRlZCkge1xuICAgICAgY29uc3QgYyA9IG4uY29udGVudC5nZXRDb250ZW50KCk7XG4gICAgICBpZiAoYy5sZW5ndGggPD0gc3RhcnQpIHtcbiAgICAgICAgc3RhcnQgLT0gYy5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjLmxlbmd0aCAmJiBsZW4gPiAwOyBpKyspIHtcbiAgICAgICAgICBjcy5wdXNoKGNbaV0pO1xuICAgICAgICAgIGxlbi0tO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgbiA9IG4ucmlnaHQ7XG4gIH1cbiAgcmV0dXJuIGNzXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdFRvQXJyYXkgPSB0eXBlID0+IHtcbiAgdHlwZS5kb2MgPz8gd2FyblByZW1hdHVyZUFjY2VzcygpO1xuICBjb25zdCBjcyA9IFtdO1xuICBsZXQgbiA9IHR5cGUuX3N0YXJ0O1xuICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgIGlmIChuLmNvdW50YWJsZSAmJiAhbi5kZWxldGVkKSB7XG4gICAgICBjb25zdCBjID0gbi5jb250ZW50LmdldENvbnRlbnQoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcy5wdXNoKGNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBuID0gbi5yaWdodDtcbiAgfVxuICByZXR1cm4gY3Ncbn07XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdFRvQXJyYXlTbmFwc2hvdCA9ICh0eXBlLCBzbmFwc2hvdCkgPT4ge1xuICBjb25zdCBjcyA9IFtdO1xuICBsZXQgbiA9IHR5cGUuX3N0YXJ0O1xuICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgIGlmIChuLmNvdW50YWJsZSAmJiBpc1Zpc2libGUobiwgc25hcHNob3QpKSB7XG4gICAgICBjb25zdCBjID0gbi5jb250ZW50LmdldENvbnRlbnQoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcy5wdXNoKGNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBuID0gbi5yaWdodDtcbiAgfVxuICByZXR1cm4gY3Ncbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbiBvbmNlIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksbnVtYmVyLGFueSk6dm9pZH0gZiBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZXZlcnkgZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVMaXN0Rm9yRWFjaCA9ICh0eXBlLCBmKSA9PiB7XG4gIGxldCBpbmRleCA9IDA7XG4gIGxldCBuID0gdHlwZS5fc3RhcnQ7XG4gIHR5cGUuZG9jID8/IHdhcm5QcmVtYXR1cmVBY2Nlc3MoKTtcbiAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICBpZiAobi5jb3VudGFibGUgJiYgIW4uZGVsZXRlZCkge1xuICAgICAgY29uc3QgYyA9IG4uY29udGVudC5nZXRDb250ZW50KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZihjW2ldLCBpbmRleCsrLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbiA9IG4ucmlnaHQ7XG4gIH1cbn07XG5cbi8qKlxuICogQHRlbXBsYXRlIEMsUlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtmdW5jdGlvbihDLG51bWJlcixBYnN0cmFjdFR5cGU8YW55Pik6Un0gZlxuICogQHJldHVybiB7QXJyYXk8Uj59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdE1hcCA9ICh0eXBlLCBmKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICB0eXBlTGlzdEZvckVhY2godHlwZSwgKGMsIGkpID0+IHtcbiAgICByZXN1bHQucHVzaChmKGMsIGksIHR5cGUpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHRcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxhbnk+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RDcmVhdGVJdGVyYXRvciA9IHR5cGUgPT4ge1xuICBsZXQgbiA9IHR5cGUuX3N0YXJ0O1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PGFueT58bnVsbH1cbiAgICovXG4gIGxldCBjdXJyZW50Q29udGVudCA9IG51bGw7XG4gIGxldCBjdXJyZW50Q29udGVudEluZGV4ID0gMDtcbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgbmV4dDogKCkgPT4ge1xuICAgICAgLy8gZmluZCBzb21lIGNvbnRlbnRcbiAgICAgIGlmIChjdXJyZW50Q29udGVudCA9PT0gbnVsbCkge1xuICAgICAgICB3aGlsZSAobiAhPT0gbnVsbCAmJiBuLmRlbGV0ZWQpIHtcbiAgICAgICAgICBuID0gbi5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiB3ZSByZWFjaGVkIHRoZSBlbmQsIG5vIG5lZWQgdG8gY2hlY2sgY3VycmVudENvbnRlbnQsIGJlY2F1c2UgaXQgZG9lcyBub3QgZXhpc3RcbiAgICAgICAgaWYgKG4gPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgZm91bmQgbiwgc28gd2UgY2FuIHNldCBjdXJyZW50Q29udGVudFxuICAgICAgICBjdXJyZW50Q29udGVudCA9IG4uY29udGVudC5nZXRDb250ZW50KCk7XG4gICAgICAgIGN1cnJlbnRDb250ZW50SW5kZXggPSAwO1xuICAgICAgICBuID0gbi5yaWdodDsgLy8gd2UgdXNlZCB0aGUgY29udGVudCBvZiBuLCBub3cgaXRlcmF0ZSB0byBuZXh0XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IGN1cnJlbnRDb250ZW50W2N1cnJlbnRDb250ZW50SW5kZXgrK107XG4gICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGVtcHR5IGN1cnJlbnRDb250ZW50XG4gICAgICBpZiAoY3VycmVudENvbnRlbnQubGVuZ3RoIDw9IGN1cnJlbnRDb250ZW50SW5kZXgpIHtcbiAgICAgICAgY3VycmVudENvbnRlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7YW55fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RHZXQgPSAodHlwZSwgaW5kZXgpID0+IHtcbiAgdHlwZS5kb2MgPz8gd2FyblByZW1hdHVyZUFjY2VzcygpO1xuICBjb25zdCBtYXJrZXIgPSBmaW5kTWFya2VyKHR5cGUsIGluZGV4KTtcbiAgbGV0IG4gPSB0eXBlLl9zdGFydDtcbiAgaWYgKG1hcmtlciAhPT0gbnVsbCkge1xuICAgIG4gPSBtYXJrZXIucDtcbiAgICBpbmRleCAtPSBtYXJrZXIuaW5kZXg7XG4gIH1cbiAgZm9yICg7IG4gIT09IG51bGw7IG4gPSBuLnJpZ2h0KSB7XG4gICAgaWYgKCFuLmRlbGV0ZWQgJiYgbi5jb3VudGFibGUpIHtcbiAgICAgIGlmIChpbmRleCA8IG4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuLmNvbnRlbnQuZ2V0Q29udGVudCgpW2luZGV4XVxuICAgICAgfVxuICAgICAgaW5kZXggLT0gbi5sZW5ndGg7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7SXRlbT99IHJlZmVyZW5jZUl0ZW1cbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0PHN0cmluZyxhbnk+fEFycmF5PGFueT58Ym9vbGVhbnxudW1iZXJ8bnVsbHxzdHJpbmd8VWludDhBcnJheT59IGNvbnRlbnRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3NBZnRlciA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCByZWZlcmVuY2VJdGVtLCBjb250ZW50KSA9PiB7XG4gIGxldCBsZWZ0ID0gcmVmZXJlbmNlSXRlbTtcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICBjb25zdCBvd25DbGllbnRJZCA9IGRvYy5jbGllbnRJRDtcbiAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmU7XG4gIGNvbnN0IHJpZ2h0ID0gcmVmZXJlbmNlSXRlbSA9PT0gbnVsbCA/IHBhcmVudC5fc3RhcnQgOiByZWZlcmVuY2VJdGVtLnJpZ2h0O1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PE9iamVjdHxBcnJheTxhbnk+fG51bWJlcnxudWxsPn1cbiAgICovXG4gIGxldCBqc29uQ29udGVudCA9IFtdO1xuICBjb25zdCBwYWNrSnNvbkNvbnRlbnQgPSAoKSA9PiB7XG4gICAgaWYgKGpzb25Db250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIGxlZnQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudEFueShqc29uQ29udGVudCkpO1xuICAgICAgbGVmdC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICAgICAganNvbkNvbnRlbnQgPSBbXTtcbiAgICB9XG4gIH07XG4gIGNvbnRlbnQuZm9yRWFjaChjID0+IHtcbiAgICBpZiAoYyA9PT0gbnVsbCkge1xuICAgICAganNvbkNvbnRlbnQucHVzaChjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgTnVtYmVyOlxuICAgICAgICBjYXNlIE9iamVjdDpcbiAgICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICBjYXNlIEFycmF5OlxuICAgICAgICBjYXNlIFN0cmluZzpcbiAgICAgICAgICBqc29uQ29udGVudC5wdXNoKGMpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcGFja0pzb25Db250ZW50KCk7XG4gICAgICAgICAgc3dpdGNoIChjLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjYXNlIFVpbnQ4QXJyYXk6XG4gICAgICAgICAgICBjYXNlIEFycmF5QnVmZmVyOlxuICAgICAgICAgICAgICBsZWZ0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKHN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRCaW5hcnkobmV3IFVpbnQ4QXJyYXkoLyoqIEB0eXBlIHtVaW50OEFycmF5fSAqLyAoYykpKSk7XG4gICAgICAgICAgICAgIGxlZnQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgRG9jOlxuICAgICAgICAgICAgICBsZWZ0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKHN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnREb2MoLyoqIEB0eXBlIHtEb2N9ICovIChjKSkpO1xuICAgICAgICAgICAgICBsZWZ0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudFR5cGUoYykpO1xuICAgICAgICAgICAgICAgIGxlZnQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgY29udGVudCB0eXBlIGluIGluc2VydCBvcGVyYXRpb24nKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHBhY2tKc29uQ29udGVudCgpO1xufTtcblxuY29uc3QgbGVuZ3RoRXhjZWVkZWQgPSAoKSA9PiBlcnJvci5jcmVhdGUoJ0xlbmd0aCBleGNlZWRlZCEnKTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0PHN0cmluZyxhbnk+fEFycmF5PGFueT58bnVtYmVyfG51bGx8c3RyaW5nfFVpbnQ4QXJyYXk+fSBjb250ZW50XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdEluc2VydEdlbmVyaWNzID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGluZGV4LCBjb250ZW50KSA9PiB7XG4gIGlmIChpbmRleCA+IHBhcmVudC5fbGVuZ3RoKSB7XG4gICAgdGhyb3cgbGVuZ3RoRXhjZWVkZWQoKVxuICB9XG4gIGlmIChpbmRleCA9PT0gMCkge1xuICAgIGlmIChwYXJlbnQuX3NlYXJjaE1hcmtlcikge1xuICAgICAgdXBkYXRlTWFya2VyQ2hhbmdlcyhwYXJlbnQuX3NlYXJjaE1hcmtlciwgaW5kZXgsIGNvbnRlbnQubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3NBZnRlcih0cmFuc2FjdGlvbiwgcGFyZW50LCBudWxsLCBjb250ZW50KVxuICB9XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgY29uc3QgbWFya2VyID0gZmluZE1hcmtlcihwYXJlbnQsIGluZGV4KTtcbiAgbGV0IG4gPSBwYXJlbnQuX3N0YXJ0O1xuICBpZiAobWFya2VyICE9PSBudWxsKSB7XG4gICAgbiA9IG1hcmtlci5wO1xuICAgIGluZGV4IC09IG1hcmtlci5pbmRleDtcbiAgICAvLyB3ZSBuZWVkIHRvIGl0ZXJhdGUgb25lIHRvIHRoZSBsZWZ0IHNvIHRoYXQgdGhlIGFsZ29yaXRobSB3b3Jrc1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgLy8gQHRvZG8gcmVmYWN0b3IgdGhpcyBhcyBpdCBhY3R1YWxseSBkb2Vzbid0IGNvbnNpZGVyIGZvcm1hdHNcbiAgICAgIG4gPSBuLnByZXY7IC8vIGltcG9ydGFudCEgZ2V0IHRoZSBsZWZ0IHVuZGVsZXRlZCBpdGVtIHNvIHRoYXQgd2UgY2FuIGFjdHVhbGx5IGRlY3JlYXNlIGluZGV4XG4gICAgICBpbmRleCArPSAobiAmJiBuLmNvdW50YWJsZSAmJiAhbi5kZWxldGVkKSA/IG4ubGVuZ3RoIDogMDtcbiAgICB9XG4gIH1cbiAgZm9yICg7IG4gIT09IG51bGw7IG4gPSBuLnJpZ2h0KSB7XG4gICAgaWYgKCFuLmRlbGV0ZWQgJiYgbi5jb3VudGFibGUpIHtcbiAgICAgIGlmIChpbmRleCA8PSBuLmxlbmd0aCkge1xuICAgICAgICBpZiAoaW5kZXggPCBuLmxlbmd0aCkge1xuICAgICAgICAgIC8vIGluc2VydCBpbi1iZXR3ZWVuXG4gICAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKG4uaWQuY2xpZW50LCBuLmlkLmNsb2NrICsgaW5kZXgpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaW5kZXggLT0gbi5sZW5ndGg7XG4gICAgfVxuICB9XG4gIGlmIChwYXJlbnQuX3NlYXJjaE1hcmtlcikge1xuICAgIHVwZGF0ZU1hcmtlckNoYW5nZXMocGFyZW50Ll9zZWFyY2hNYXJrZXIsIHN0YXJ0SW5kZXgsIGNvbnRlbnQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gdHlwZUxpc3RJbnNlcnRHZW5lcmljc0FmdGVyKHRyYW5zYWN0aW9uLCBwYXJlbnQsIG4sIGNvbnRlbnQpXG59O1xuXG4vKipcbiAqIFB1c2hpbmcgY29udGVudCBpcyBzcGVjaWFsIGFzIHdlIGdlbmVyYWxseSB3YW50IHRvIHB1c2ggYWZ0ZXIgdGhlIGxhc3QgaXRlbS4gU28gd2UgZG9uJ3QgaGF2ZSB0byB1cGRhdGVcbiAqIHRoZSBzZWFyY2ggbWFya2VyLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0PHN0cmluZyxhbnk+fEFycmF5PGFueT58bnVtYmVyfG51bGx8c3RyaW5nfFVpbnQ4QXJyYXk+fSBjb250ZW50XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdFB1c2hHZW5lcmljcyA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBjb250ZW50KSA9PiB7XG4gIC8vIFVzZSB0aGUgbWFya2VyIHdpdGggdGhlIGhpZ2hlc3QgaW5kZXggYW5kIGl0ZXJhdGUgdG8gdGhlIHJpZ2h0LlxuICBjb25zdCBtYXJrZXIgPSAocGFyZW50Ll9zZWFyY2hNYXJrZXIgfHwgW10pLnJlZHVjZSgobWF4TWFya2VyLCBjdXJyTWFya2VyKSA9PiBjdXJyTWFya2VyLmluZGV4ID4gbWF4TWFya2VyLmluZGV4ID8gY3Vyck1hcmtlciA6IG1heE1hcmtlciwgeyBpbmRleDogMCwgcDogcGFyZW50Ll9zdGFydCB9KTtcbiAgbGV0IG4gPSBtYXJrZXIucDtcbiAgaWYgKG4pIHtcbiAgICB3aGlsZSAobi5yaWdodCkge1xuICAgICAgbiA9IG4ucmlnaHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB0eXBlTGlzdEluc2VydEdlbmVyaWNzQWZ0ZXIodHJhbnNhY3Rpb24sIHBhcmVudCwgbiwgY29udGVudClcbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdERlbGV0ZSA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBpbmRleCwgbGVuZ3RoKSA9PiB7XG4gIGlmIChsZW5ndGggPT09IDApIHsgcmV0dXJuIH1cbiAgY29uc3Qgc3RhcnRJbmRleCA9IGluZGV4O1xuICBjb25zdCBzdGFydExlbmd0aCA9IGxlbmd0aDtcbiAgY29uc3QgbWFya2VyID0gZmluZE1hcmtlcihwYXJlbnQsIGluZGV4KTtcbiAgbGV0IG4gPSBwYXJlbnQuX3N0YXJ0O1xuICBpZiAobWFya2VyICE9PSBudWxsKSB7XG4gICAgbiA9IG1hcmtlci5wO1xuICAgIGluZGV4IC09IG1hcmtlci5pbmRleDtcbiAgfVxuICAvLyBjb21wdXRlIHRoZSBmaXJzdCBpdGVtIHRvIGJlIGRlbGV0ZWRcbiAgZm9yICg7IG4gIT09IG51bGwgJiYgaW5kZXggPiAwOyBuID0gbi5yaWdodCkge1xuICAgIGlmICghbi5kZWxldGVkICYmIG4uY291bnRhYmxlKSB7XG4gICAgICBpZiAoaW5kZXggPCBuLmxlbmd0aCkge1xuICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQobi5pZC5jbGllbnQsIG4uaWQuY2xvY2sgKyBpbmRleCkpO1xuICAgICAgfVxuICAgICAgaW5kZXggLT0gbi5sZW5ndGg7XG4gICAgfVxuICB9XG4gIC8vIGRlbGV0ZSBhbGwgaXRlbXMgdW50aWwgZG9uZVxuICB3aGlsZSAobGVuZ3RoID4gMCAmJiBuICE9PSBudWxsKSB7XG4gICAgaWYgKCFuLmRlbGV0ZWQpIHtcbiAgICAgIGlmIChsZW5ndGggPCBuLmxlbmd0aCkge1xuICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQobi5pZC5jbGllbnQsIG4uaWQuY2xvY2sgKyBsZW5ndGgpKTtcbiAgICAgIH1cbiAgICAgIG4uZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgIGxlbmd0aCAtPSBuLmxlbmd0aDtcbiAgICB9XG4gICAgbiA9IG4ucmlnaHQ7XG4gIH1cbiAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBsZW5ndGhFeGNlZWRlZCgpXG4gIH1cbiAgaWYgKHBhcmVudC5fc2VhcmNoTWFya2VyKSB7XG4gICAgdXBkYXRlTWFya2VyQ2hhbmdlcyhwYXJlbnQuX3NlYXJjaE1hcmtlciwgc3RhcnRJbmRleCwgLXN0YXJ0TGVuZ3RoICsgbGVuZ3RoIC8qIGluIGNhc2Ugd2UgcmVtb3ZlIHRoZSBhYm92ZSBleGNlcHRpb24gKi8pO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVNYXBEZWxldGUgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwga2V5KSA9PiB7XG4gIGNvbnN0IGMgPSBwYXJlbnQuX21hcC5nZXQoa2V5KTtcbiAgaWYgKGMgIT09IHVuZGVmaW5lZCkge1xuICAgIGMuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge09iamVjdHxudW1iZXJ8bnVsbHxBcnJheTxhbnk+fHN0cmluZ3xVaW50OEFycmF5fEFic3RyYWN0VHlwZTxhbnk+fSB2YWx1ZVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZU1hcFNldCA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBrZXksIHZhbHVlKSA9PiB7XG4gIGNvbnN0IGxlZnQgPSBwYXJlbnQuX21hcC5nZXQoa2V5KSB8fCBudWxsO1xuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gIGNvbnN0IG93bkNsaWVudElkID0gZG9jLmNsaWVudElEO1xuICBsZXQgY29udGVudDtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICBjb250ZW50ID0gbmV3IENvbnRlbnRBbnkoW3ZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh2YWx1ZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgY2FzZSBOdW1iZXI6XG4gICAgICBjYXNlIE9iamVjdDpcbiAgICAgIGNhc2UgQm9vbGVhbjpcbiAgICAgIGNhc2UgQXJyYXk6XG4gICAgICBjYXNlIFN0cmluZzpcbiAgICAgICAgY29udGVudCA9IG5ldyBDb250ZW50QW55KFt2YWx1ZV0pO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgICBjb250ZW50ID0gbmV3IENvbnRlbnRCaW5hcnkoLyoqIEB0eXBlIHtVaW50OEFycmF5fSAqLyAodmFsdWUpKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgRG9jOlxuICAgICAgICBjb250ZW50ID0gbmV3IENvbnRlbnREb2MoLyoqIEB0eXBlIHtEb2N9ICovICh2YWx1ZSkpO1xuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlKSB7XG4gICAgICAgICAgY29udGVudCA9IG5ldyBDb250ZW50VHlwZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGNvbnRlbnQgdHlwZScpXG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKGRvYy5zdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgbnVsbCwgbnVsbCwgcGFyZW50LCBrZXksIGNvbnRlbnQpLmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7T2JqZWN0PHN0cmluZyxhbnk+fG51bWJlcnxudWxsfEFycmF5PGFueT58c3RyaW5nfFVpbnQ4QXJyYXl8QWJzdHJhY3RUeXBlPGFueT58dW5kZWZpbmVkfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZU1hcEdldCA9IChwYXJlbnQsIGtleSkgPT4ge1xuICBwYXJlbnQuZG9jID8/IHdhcm5QcmVtYXR1cmVBY2Nlc3MoKTtcbiAgY29uc3QgdmFsID0gcGFyZW50Ll9tYXAuZ2V0KGtleSk7XG4gIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCAmJiAhdmFsLmRlbGV0ZWQgPyB2YWwuY29udGVudC5nZXRDb250ZW50KClbdmFsLmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHJldHVybiB7T2JqZWN0PHN0cmluZyxPYmplY3Q8c3RyaW5nLGFueT58bnVtYmVyfG51bGx8QXJyYXk8YW55PnxzdHJpbmd8VWludDhBcnJheXxBYnN0cmFjdFR5cGU8YW55Pnx1bmRlZmluZWQ+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZU1hcEdldEFsbCA9IChwYXJlbnQpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAqL1xuICBjb25zdCByZXMgPSB7fTtcbiAgcGFyZW50LmRvYyA/PyB3YXJuUHJlbWF0dXJlQWNjZXNzKCk7XG4gIHBhcmVudC5fbWFwLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAoIXZhbHVlLmRlbGV0ZWQpIHtcbiAgICAgIHJlc1trZXldID0gdmFsdWUuY29udGVudC5nZXRDb250ZW50KClbdmFsdWUubGVuZ3RoIC0gMV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTWFwSGFzID0gKHBhcmVudCwga2V5KSA9PiB7XG4gIHBhcmVudC5kb2MgPz8gd2FyblByZW1hdHVyZUFjY2VzcygpO1xuICBjb25zdCB2YWwgPSBwYXJlbnQuX21hcC5nZXQoa2V5KTtcbiAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkICYmICF2YWwuZGVsZXRlZFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXBzaG90XG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLGFueT58bnVtYmVyfG51bGx8QXJyYXk8YW55PnxzdHJpbmd8VWludDhBcnJheXxBYnN0cmFjdFR5cGU8YW55Pnx1bmRlZmluZWR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTWFwR2V0U25hcHNob3QgPSAocGFyZW50LCBrZXksIHNuYXBzaG90KSA9PiB7XG4gIGxldCB2ID0gcGFyZW50Ll9tYXAuZ2V0KGtleSkgfHwgbnVsbDtcbiAgd2hpbGUgKHYgIT09IG51bGwgJiYgKCFzbmFwc2hvdC5zdi5oYXModi5pZC5jbGllbnQpIHx8IHYuaWQuY2xvY2sgPj0gKHNuYXBzaG90LnN2LmdldCh2LmlkLmNsaWVudCkgfHwgMCkpKSB7XG4gICAgdiA9IHYubGVmdDtcbiAgfVxuICByZXR1cm4gdiAhPT0gbnVsbCAmJiBpc1Zpc2libGUodiwgc25hcHNob3QpID8gdi5jb250ZW50LmdldENvbnRlbnQoKVt2Lmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsT2JqZWN0PHN0cmluZyxhbnk+fG51bWJlcnxudWxsfEFycmF5PGFueT58c3RyaW5nfFVpbnQ4QXJyYXl8QWJzdHJhY3RUeXBlPGFueT58dW5kZWZpbmVkPn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVNYXBHZXRBbGxTbmFwc2hvdCA9IChwYXJlbnQsIHNuYXBzaG90KSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgKi9cbiAgY29uc3QgcmVzID0ge307XG4gIHBhcmVudC5fbWFwLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAqL1xuICAgIGxldCB2ID0gdmFsdWU7XG4gICAgd2hpbGUgKHYgIT09IG51bGwgJiYgKCFzbmFwc2hvdC5zdi5oYXModi5pZC5jbGllbnQpIHx8IHYuaWQuY2xvY2sgPj0gKHNuYXBzaG90LnN2LmdldCh2LmlkLmNsaWVudCkgfHwgMCkpKSB7XG4gICAgICB2ID0gdi5sZWZ0O1xuICAgIH1cbiAgICBpZiAodiAhPT0gbnVsbCAmJiBpc1Zpc2libGUodiwgc25hcHNob3QpKSB7XG4gICAgICByZXNba2V5XSA9IHYuY29udGVudC5nZXRDb250ZW50KClbdi5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT4gJiB7IF9tYXA6IE1hcDxzdHJpbmcsIEl0ZW0+IH19IHR5cGVcbiAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8QXJyYXk8YW55Pj59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVNYXBJdGVyYXRvciA9IHR5cGUgPT4ge1xuICB0eXBlLmRvYyA/PyB3YXJuUHJlbWF0dXJlQWNjZXNzKCk7XG4gIHJldHVybiBpdGVyYXRvci5pdGVyYXRvckZpbHRlcih0eXBlLl9tYXAuZW50cmllcygpLCAvKiogQHBhcmFtIHthbnl9IGVudHJ5ICovIGVudHJ5ID0+ICFlbnRyeVsxXS5kZWxldGVkKVxufTtcblxuLyoqXG4gKiBAbW9kdWxlIFlBcnJheVxuICovXG5cblxuLyoqXG4gKiBFdmVudCB0aGF0IGRlc2NyaWJlcyB0aGUgY2hhbmdlcyBvbiBhIFlBcnJheVxuICogQHRlbXBsYXRlIFRcbiAqIEBleHRlbmRzIFlFdmVudDxZQXJyYXk8VD4+XG4gKi9cbmNsYXNzIFlBcnJheUV2ZW50IGV4dGVuZHMgWUV2ZW50IHt9XG5cbi8qKlxuICogQSBzaGFyZWQgQXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKiBAdGVtcGxhdGUgVFxuICogQGV4dGVuZHMgQWJzdHJhY3RUeXBlPFlBcnJheUV2ZW50PFQ+PlxuICogQGltcGxlbWVudHMge0l0ZXJhYmxlPFQ+fVxuICovXG5jbGFzcyBZQXJyYXkgZXh0ZW5kcyBBYnN0cmFjdFR5cGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8YW55Pj99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gW107XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PEFycmF5U2VhcmNoTWFya2VyPn1cbiAgICAgKi9cbiAgICB0aGlzLl9zZWFyY2hNYXJrZXIgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgWUFycmF5IGNvbnRhaW5pbmcgdGhlIHNwZWNpZmllZCBpdGVtcy5cbiAgICogQHRlbXBsYXRlIHtPYmplY3Q8c3RyaW5nLGFueT58QXJyYXk8YW55PnxudW1iZXJ8bnVsbHxzdHJpbmd8VWludDhBcnJheX0gVFxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSBpdGVtc1xuICAgKiBAcmV0dXJuIHtZQXJyYXk8VD59XG4gICAqL1xuICBzdGF0aWMgZnJvbSAoaXRlbXMpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7WUFycmF5PFQ+fVxuICAgICAqL1xuICAgIGNvbnN0IGEgPSBuZXcgWUFycmF5KCk7XG4gICAgYS5wdXNoKGl0ZW1zKTtcbiAgICByZXR1cm4gYVxuICB9XG5cbiAgLyoqXG4gICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgKlxuICAgKiAqIFNhdmUgdGhpcyBzdHJ1Y3QgaW4gdGhlIG9zXG4gICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0RvY30geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHN1cGVyLl9pbnRlZ3JhdGUoeSwgaXRlbSk7XG4gICAgdGhpcy5pbnNlcnQoMCwgLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkpO1xuICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lBcnJheTxUPn1cbiAgICovXG4gIF9jb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IFlBcnJheSgpXG4gIH1cblxuICAvKipcbiAgICogTWFrZXMgYSBjb3B5IG9mIHRoaXMgZGF0YSB0eXBlIHRoYXQgY2FuIGJlIGluY2x1ZGVkIHNvbWV3aGVyZSBlbHNlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGNvbnRlbnQgaXMgb25seSByZWFkYWJsZSBfYWZ0ZXJfIGl0IGhhcyBiZWVuIGluY2x1ZGVkIHNvbWV3aGVyZSBpbiB0aGUgWWRvYy5cbiAgICpcbiAgICogQHJldHVybiB7WUFycmF5PFQ+fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtZQXJyYXk8VD59XG4gICAgICovXG4gICAgY29uc3QgYXJyID0gbmV3IFlBcnJheSgpO1xuICAgIGFyci5pbnNlcnQoMCwgdGhpcy50b0FycmF5KCkubWFwKGVsID0+XG4gICAgICBlbCBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IC8qKiBAdHlwZSB7dHlwZW9mIGVsfSAqLyAoZWwuY2xvbmUoKSkgOiBlbFxuICAgICkpO1xuICAgIHJldHVybiBhcnJcbiAgfVxuXG4gIGdldCBsZW5ndGggKCkge1xuICAgIHRoaXMuZG9jID8/IHdhcm5QcmVtYXR1cmVBY2Nlc3MoKTtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBZQXJyYXlFdmVudCBhbmQgY2FsbHMgb2JzZXJ2ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1NldDxudWxsfHN0cmluZz59IHBhcmVudFN1YnMgS2V5cyBjaGFuZ2VkIG9uIHRoaXMgdHlwZS4gYG51bGxgIGlmIGxpc3Qgd2FzIG1vZGlmaWVkLlxuICAgKi9cbiAgX2NhbGxPYnNlcnZlciAodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpIHtcbiAgICBzdXBlci5fY2FsbE9ic2VydmVyKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKTtcbiAgICBjYWxsVHlwZU9ic2VydmVycyh0aGlzLCB0cmFuc2FjdGlvbiwgbmV3IFlBcnJheUV2ZW50KHRoaXMsIHRyYW5zYWN0aW9uKSk7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBuZXcgY29udGVudCBhdCBhbiBpbmRleC5cbiAgICpcbiAgICogSW1wb3J0YW50OiBUaGlzIGZ1bmN0aW9uIGV4cGVjdHMgYW4gYXJyYXkgb2YgY29udGVudC4gTm90IGp1c3QgYSBjb250ZW50XG4gICAqIG9iamVjdC4gVGhlIHJlYXNvbiBmb3IgdGhpcyBcIndlaXJkbmVzc1wiIGlzIHRoYXQgaW5zZXJ0aW5nIHNldmVyYWwgZWxlbWVudHNcbiAgICogaXMgdmVyeSBlZmZpY2llbnQgd2hlbiBpdCBpcyBkb25lIGFzIGEgc2luZ2xlIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIC8vIEluc2VydCBjaGFyYWN0ZXIgJ2EnIGF0IHBvc2l0aW9uIDBcbiAgICogIHlhcnJheS5pbnNlcnQoMCwgWydhJ10pXG4gICAqICAvLyBJbnNlcnQgbnVtYmVycyAxLCAyIGF0IHBvc2l0aW9uIDFcbiAgICogIHlhcnJheS5pbnNlcnQoMSwgWzEsIDJdKVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIGluc2VydCBjb250ZW50IGF0LlxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSBjb250ZW50IFRoZSBhcnJheSBvZiBjb250ZW50XG4gICAqL1xuICBpbnNlcnQgKGluZGV4LCBjb250ZW50KSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTGlzdEluc2VydEdlbmVyaWNzKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCwgLyoqIEB0eXBlIHthbnl9ICovIChjb250ZW50KSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuc3BsaWNlKGluZGV4LCAwLCAuLi5jb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kcyBjb250ZW50IHRvIHRoaXMgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSBjb250ZW50IEFycmF5IG9mIGNvbnRlbnQgdG8gYXBwZW5kLlxuICAgKlxuICAgKiBAdG9kbyBVc2UgdGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvbiBpbiBhbGwgdHlwZXMuXG4gICAqL1xuICBwdXNoIChjb250ZW50KSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTGlzdFB1c2hHZW5lcmljcyh0cmFuc2FjdGlvbiwgdGhpcywgLyoqIEB0eXBlIHthbnl9ICovIChjb250ZW50KSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkucHVzaCguLi5jb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUHJlcGVuZHMgY29udGVudCB0byB0aGlzIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxUPn0gY29udGVudCBBcnJheSBvZiBjb250ZW50IHRvIHByZXBlbmQuXG4gICAqL1xuICB1bnNoaWZ0IChjb250ZW50KSB7XG4gICAgdGhpcy5pbnNlcnQoMCwgY29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBlbGVtZW50cyBzdGFydGluZyBmcm9tIGFuIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgZGVsZXRpbmcgZWxlbWVudHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS4gRGVmYXVsdHMgdG8gMS5cbiAgICovXG4gIGRlbGV0ZSAoaW5kZXgsIGxlbmd0aCA9IDEpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVMaXN0RGVsZXRlKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCwgbGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KS5zcGxpY2UoaW5kZXgsIGxlbmd0aCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGktdGggZWxlbWVudCBmcm9tIGEgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybiBmcm9tIHRoZSBZQXJyYXlcbiAgICogQHJldHVybiB7VH1cbiAgICovXG4gIGdldCAoaW5kZXgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RHZXQodGhpcywgaW5kZXgpXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGlzIFlBcnJheSB0byBhIEphdmFTY3JpcHQgQXJyYXkuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5PFQ+fVxuICAgKi9cbiAgdG9BcnJheSAoKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0VG9BcnJheSh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwb3J0aW9uIG9mIHRoaXMgWUFycmF5IGludG8gYSBKYXZhU2NyaXB0IEFycmF5IHNlbGVjdGVkXG4gICAqIGZyb20gc3RhcnQgdG8gZW5kIChlbmQgbm90IGluY2x1ZGVkKS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdXG4gICAqIEByZXR1cm4ge0FycmF5PFQ+fVxuICAgKi9cbiAgc2xpY2UgKHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhpcyBTaGFyZWQgVHlwZSB0byBhIEpTT04gb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoYyA9PiBjIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gYy50b0pTT04oKSA6IGMpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBBcnJheSB3aXRoIHRoZSByZXN1bHQgb2YgY2FsbGluZyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIGV2ZXJ5XG4gICAqIGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBNXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCxudW1iZXIsWUFycmF5PFQ+KTpNfSBmIEZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gZWxlbWVudCBvZiB0aGUgbmV3IEFycmF5XG4gICAqIEByZXR1cm4ge0FycmF5PE0+fSBBIG5ldyBhcnJheSB3aXRoIGVhY2ggZWxlbWVudCBiZWluZyB0aGUgcmVzdWx0IG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICovXG4gIG1hcCAoZikge1xuICAgIHJldHVybiB0eXBlTGlzdE1hcCh0aGlzLCAvKiogQHR5cGUge2FueX0gKi8gKGYpKVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBvbiBldmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQsbnVtYmVyLFlBcnJheTxUPik6dm9pZH0gZiBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZXZlcnkgZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAgICovXG4gIGZvckVhY2ggKGYpIHtcbiAgICB0eXBlTGlzdEZvckVhY2godGhpcywgZik7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxUPn1cbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RDcmVhdGVJdGVyYXRvcih0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqL1xuICBfd3JpdGUgKGVuY29kZXIpIHtcbiAgICBlbmNvZGVyLndyaXRlVHlwZVJlZihZQXJyYXlSZWZJRCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gX2RlY29kZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRZQXJyYXkgPSBfZGVjb2RlciA9PiBuZXcgWUFycmF5KCk7XG5cbi8qKlxuICogQG1vZHVsZSBZTWFwXG4gKi9cblxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAZXh0ZW5kcyBZRXZlbnQ8WU1hcDxUPj5cbiAqIEV2ZW50IHRoYXQgZGVzY3JpYmVzIHRoZSBjaGFuZ2VzIG9uIGEgWU1hcC5cbiAqL1xuY2xhc3MgWU1hcEV2ZW50IGV4dGVuZHMgWUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WU1hcDxUPn0geW1hcCBUaGUgWUFycmF5IHRoYXQgY2hhbmdlZC5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8YW55Pn0gc3VicyBUaGUga2V5cyB0aGF0IGNoYW5nZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeW1hcCwgdHJhbnNhY3Rpb24sIHN1YnMpIHtcbiAgICBzdXBlcih5bWFwLCB0cmFuc2FjdGlvbik7XG4gICAgdGhpcy5rZXlzQ2hhbmdlZCA9IHN1YnM7XG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgTWFwVHlwZVxuICogQSBzaGFyZWQgTWFwIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBleHRlbmRzIEFic3RyYWN0VHlwZTxZTWFwRXZlbnQ8TWFwVHlwZT4+XG4gKiBAaW1wbGVtZW50cyB7SXRlcmFibGU8W3N0cmluZywgTWFwVHlwZV0+fVxuICovXG5jbGFzcyBZTWFwIGV4dGVuZHMgQWJzdHJhY3RUeXBlIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7SXRlcmFibGU8cmVhZG9ubHkgW3N0cmluZywgYW55XT49fSBlbnRyaWVzIC0gYW4gb3B0aW9uYWwgaXRlcmFibGUgdG8gaW5pdGlhbGl6ZSB0aGUgWU1hcFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGVudHJpZXMpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLGFueT4/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcHJlbGltQ29udGVudCA9IG51bGw7XG5cbiAgICBpZiAoZW50cmllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gbmV3IE1hcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gbmV3IE1hcChlbnRyaWVzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW50ZWdyYXRlIHRoaXMgdHlwZSBpbnRvIHRoZSBZanMgaW5zdGFuY2UuXG4gICAqXG4gICAqICogU2F2ZSB0aGlzIHN0cnVjdCBpbiB0aGUgb3NcbiAgICogKiBUaGlzIHR5cGUgaXMgc2VudCB0byBvdGhlciBjbGllbnRcbiAgICogKiBPYnNlcnZlciBmdW5jdGlvbnMgYXJlIGZpcmVkXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jfSB5IFRoZSBZanMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBfaW50ZWdyYXRlICh5LCBpdGVtKSB7XG4gICAgc3VwZXIuX2ludGVncmF0ZSh5LCBpdGVtKVxuICAgIDsvKiogQHR5cGUge01hcDxzdHJpbmcsIGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtZTWFwPE1hcFR5cGU+fVxuICAgKi9cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWU1hcCgpXG4gIH1cblxuICAvKipcbiAgICogTWFrZXMgYSBjb3B5IG9mIHRoaXMgZGF0YSB0eXBlIHRoYXQgY2FuIGJlIGluY2x1ZGVkIHNvbWV3aGVyZSBlbHNlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGNvbnRlbnQgaXMgb25seSByZWFkYWJsZSBfYWZ0ZXJfIGl0IGhhcyBiZWVuIGluY2x1ZGVkIHNvbWV3aGVyZSBpbiB0aGUgWWRvYy5cbiAgICpcbiAgICogQHJldHVybiB7WU1hcDxNYXBUeXBlPn1cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7WU1hcDxNYXBUeXBlPn1cbiAgICAgKi9cbiAgICBjb25zdCBtYXAgPSBuZXcgWU1hcCgpO1xuICAgIHRoaXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgbWFwLnNldChrZXksIHZhbHVlIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gLyoqIEB0eXBlIHt0eXBlb2YgdmFsdWV9ICovICh2YWx1ZS5jbG9uZSgpKSA6IHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFwXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBZTWFwRXZlbnQgYW5kIGNhbGxzIG9ic2VydmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8bnVsbHxzdHJpbmc+fSBwYXJlbnRTdWJzIEtleXMgY2hhbmdlZCBvbiB0aGlzIHR5cGUuIGBudWxsYCBpZiBsaXN0IHdhcyBtb2RpZmllZC5cbiAgICovXG4gIF9jYWxsT2JzZXJ2ZXIgKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKSB7XG4gICAgY2FsbFR5cGVPYnNlcnZlcnModGhpcywgdHJhbnNhY3Rpb24sIG5ldyBZTWFwRXZlbnQodGhpcywgdHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoaXMgU2hhcmVkIFR5cGUgdG8gYSBKU09OIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICB0aGlzLmRvYyA/PyB3YXJuUHJlbWF0dXJlQWNjZXNzKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsTWFwVHlwZT59XG4gICAgICovXG4gICAgY29uc3QgbWFwID0ge307XG4gICAgdGhpcy5fbWFwLmZvckVhY2goKGl0ZW0sIGtleSkgPT4ge1xuICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgY29uc3QgdiA9IGl0ZW0uY29udGVudC5nZXRDb250ZW50KClbaXRlbS5sZW5ndGggLSAxXTtcbiAgICAgICAgbWFwW2tleV0gPSB2IGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gdi50b0pTT04oKSA6IHY7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIFlNYXAgKGNvdW50IG9mIGtleS92YWx1ZSBwYWlycylcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNpemUgKCkge1xuICAgIHJldHVybiBbLi4uY3JlYXRlTWFwSXRlcmF0b3IodGhpcyldLmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGtleXMgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgWU1hcCBUeXBlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPHN0cmluZz59XG4gICAqL1xuICBrZXlzICgpIHtcbiAgICByZXR1cm4gaXRlcmF0b3IuaXRlcmF0b3JNYXAoY3JlYXRlTWFwSXRlcmF0b3IodGhpcyksIC8qKiBAcGFyYW0ge2FueX0gdiAqLyB2ID0+IHZbMF0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWVzIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIFlNYXAgVHlwZS5cbiAgICpcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxNYXBUeXBlPn1cbiAgICovXG4gIHZhbHVlcyAoKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yLml0ZXJhdG9yTWFwKGNyZWF0ZU1hcEl0ZXJhdG9yKHRoaXMpLCAvKiogQHBhcmFtIHthbnl9IHYgKi8gdiA9PiB2WzFdLmNvbnRlbnQuZ2V0Q29udGVudCgpW3ZbMV0ubGVuZ3RoIC0gMV0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJdGVyYXRvciBvZiBba2V5LCB2YWx1ZV0gcGFpcnNcbiAgICpcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxbc3RyaW5nLCBNYXBUeXBlXT59XG4gICAqL1xuICBlbnRyaWVzICgpIHtcbiAgICByZXR1cm4gaXRlcmF0b3IuaXRlcmF0b3JNYXAoY3JlYXRlTWFwSXRlcmF0b3IodGhpcyksIC8qKiBAcGFyYW0ge2FueX0gdiAqLyB2ID0+IC8qKiBAdHlwZSB7YW55fSAqLyAoW3ZbMF0sIHZbMV0uY29udGVudC5nZXRDb250ZW50KClbdlsxXS5sZW5ndGggLSAxXV0pKVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gb25jZSBvbiBldmVyeSBrZXktdmFsdWUgcGFpci5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihNYXBUeXBlLHN0cmluZyxZTWFwPE1hcFR5cGU+KTp2b2lkfSBmIEEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBldmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICAgKi9cbiAgZm9yRWFjaCAoZikge1xuICAgIHRoaXMuZG9jID8/IHdhcm5QcmVtYXR1cmVBY2Nlc3MoKTtcbiAgICB0aGlzLl9tYXAuZm9yRWFjaCgoaXRlbSwga2V5KSA9PiB7XG4gICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICBmKGl0ZW0uY29udGVudC5nZXRDb250ZW50KClbaXRlbS5sZW5ndGggLSAxXSwga2V5LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIEl0ZXJhdG9yIG9mIFtrZXksIHZhbHVlXSBwYWlyc1xuICAgKlxuICAgKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPFtzdHJpbmcsIE1hcFR5cGVdPn1cbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBzcGVjaWZpZWQgZWxlbWVudCBmcm9tIHRoaXMgWU1hcC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAgICovXG4gIGRlbGV0ZSAoa2V5KSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwRGVsZXRlKHRyYW5zYWN0aW9uLCB0aGlzLCBrZXkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIG9yIHVwZGF0ZXMgYW4gZWxlbWVudCB3aXRoIGEgc3BlY2lmaWVkIGtleSBhbmQgdmFsdWUuXG4gICAqIEB0ZW1wbGF0ZSB7TWFwVHlwZX0gVkFMXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byBhZGQgdG8gdGhpcyBZTWFwXG4gICAqIEBwYXJhbSB7VkFMfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgdG8gYWRkXG4gICAqIEByZXR1cm4ge1ZBTH1cbiAgICovXG4gIHNldCAoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZU1hcFNldCh0cmFuc2FjdGlvbiwgdGhpcywga2V5LCAvKiogQHR5cGUge2FueX0gKi8gKHZhbHVlKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3BlY2lmaWVkIGVsZW1lbnQgZnJvbSB0aGlzIFlNYXAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHJldHVybiB7TWFwVHlwZXx1bmRlZmluZWR9XG4gICAqL1xuICBnZXQgKGtleSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHR5cGVNYXBHZXQodGhpcywga2V5KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBrZXkgZXhpc3RzIG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXMgKGtleSkge1xuICAgIHJldHVybiB0eXBlTWFwSGFzKHRoaXMsIGtleSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBlbGVtZW50cyBmcm9tIHRoaXMgWU1hcC5cbiAgICovXG4gIGNsZWFyICgpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoX3ZhbHVlLCBrZXksIG1hcCkge1xuICAgICAgICAgIHR5cGVNYXBEZWxldGUodHJhbnNhY3Rpb24sIG1hcCwga2V5KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuY2xlYXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlNYXBSZWZJRCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gX2RlY29kZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRZTWFwID0gX2RlY29kZXIgPT4gbmV3IFlNYXAoKTtcblxuLyoqXG4gKiBAbW9kdWxlIFlUZXh0XG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBhXG4gKiBAcGFyYW0ge2FueX0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgZXF1YWxBdHRycyA9IChhLCBiKSA9PiBhID09PSBiIHx8ICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT09ICdvYmplY3QnICYmIGEgJiYgYiAmJiBvYmplY3QuZXF1YWxGbGF0KGEsIGIpKTtcblxuY2xhc3MgSXRlbVRleHRMaXN0UG9zaXRpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtJdGVtfG51bGx9IGxlZnRcbiAgICogQHBhcmFtIHtJdGVtfG51bGx9IHJpZ2h0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge01hcDxzdHJpbmcsYW55Pn0gY3VycmVudEF0dHJpYnV0ZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChsZWZ0LCByaWdodCwgaW5kZXgsIGN1cnJlbnRBdHRyaWJ1dGVzKSB7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuY3VycmVudEF0dHJpYnV0ZXMgPSBjdXJyZW50QXR0cmlidXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBPbmx5IGNhbGwgdGhpcyBpZiB5b3Uga25vdyB0aGF0IHRoaXMucmlnaHQgaXMgZGVmaW5lZFxuICAgKi9cbiAgZm9yd2FyZCAoKSB7XG4gICAgaWYgKHRoaXMucmlnaHQgPT09IG51bGwpIHtcbiAgICAgIGVycm9yLnVuZXhwZWN0ZWRDYXNlKCk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6XG4gICAgICAgIGlmICghdGhpcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICAgICAgdXBkYXRlQ3VycmVudEF0dHJpYnV0ZXModGhpcy5jdXJyZW50QXR0cmlidXRlcywgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAodGhpcy5yaWdodC5jb250ZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICghdGhpcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICAgICAgdGhpcy5pbmRleCArPSB0aGlzLnJpZ2h0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cbiAgICB0aGlzLmxlZnQgPSB0aGlzLnJpZ2h0O1xuICAgIHRoaXMucmlnaHQgPSB0aGlzLnJpZ2h0LnJpZ2h0O1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7SXRlbVRleHRMaXN0UG9zaXRpb259IHBvc1xuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IHN0ZXBzIHRvIG1vdmUgZm9yd2FyZFxuICogQHJldHVybiB7SXRlbVRleHRMaXN0UG9zaXRpb259XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmaW5kTmV4dFBvc2l0aW9uID0gKHRyYW5zYWN0aW9uLCBwb3MsIGNvdW50KSA9PiB7XG4gIHdoaWxlIChwb3MucmlnaHQgIT09IG51bGwgJiYgY291bnQgPiAwKSB7XG4gICAgc3dpdGNoIChwb3MucmlnaHQuY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OlxuICAgICAgICBpZiAoIXBvcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICAgICAgdXBkYXRlQ3VycmVudEF0dHJpYnV0ZXMocG9zLmN1cnJlbnRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChwb3MucmlnaHQuY29udGVudCkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoIXBvcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICAgICAgaWYgKGNvdW50IDwgcG9zLnJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gc3BsaXQgcmlnaHRcbiAgICAgICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChwb3MucmlnaHQuaWQuY2xpZW50LCBwb3MucmlnaHQuaWQuY2xvY2sgKyBjb3VudCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3MuaW5kZXggKz0gcG9zLnJpZ2h0Lmxlbmd0aDtcbiAgICAgICAgICBjb3VudCAtPSBwb3MucmlnaHQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIHBvcy5sZWZ0ID0gcG9zLnJpZ2h0O1xuICAgIHBvcy5yaWdodCA9IHBvcy5yaWdodC5yaWdodDtcbiAgICAvLyBwb3MuZm9yd2FyZCgpIC0gd2UgZG9uJ3QgZm9yd2FyZCBiZWNhdXNlIHRoYXQgd291bGQgaGFsdmUgdGhlIHBlcmZvcm1hbmNlIGJlY2F1c2Ugd2UgYWxyZWFkeSBkbyB0aGUgY2hlY2tzIGFib3ZlXG4gIH1cbiAgcmV0dXJuIHBvc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlU2VhcmNoTWFya2VyXG4gKiBAcmV0dXJuIHtJdGVtVGV4dExpc3RQb3NpdGlvbn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGZpbmRQb3NpdGlvbiA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBpbmRleCwgdXNlU2VhcmNoTWFya2VyKSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICBjb25zdCBtYXJrZXIgPSB1c2VTZWFyY2hNYXJrZXIgPyBmaW5kTWFya2VyKHBhcmVudCwgaW5kZXgpIDogbnVsbDtcbiAgaWYgKG1hcmtlcikge1xuICAgIGNvbnN0IHBvcyA9IG5ldyBJdGVtVGV4dExpc3RQb3NpdGlvbihtYXJrZXIucC5sZWZ0LCBtYXJrZXIucCwgbWFya2VyLmluZGV4LCBjdXJyZW50QXR0cmlidXRlcyk7XG4gICAgcmV0dXJuIGZpbmROZXh0UG9zaXRpb24odHJhbnNhY3Rpb24sIHBvcywgaW5kZXggLSBtYXJrZXIuaW5kZXgpXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcG9zID0gbmV3IEl0ZW1UZXh0TGlzdFBvc2l0aW9uKG51bGwsIHBhcmVudC5fc3RhcnQsIDAsIGN1cnJlbnRBdHRyaWJ1dGVzKTtcbiAgICByZXR1cm4gZmluZE5leHRQb3NpdGlvbih0cmFuc2FjdGlvbiwgcG9zLCBpbmRleClcbiAgfVxufTtcblxuLyoqXG4gKiBOZWdhdGUgYXBwbGllZCBmb3JtYXRzXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtNYXA8c3RyaW5nLGFueT59IG5lZ2F0ZWRBdHRyaWJ1dGVzXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBpbnNlcnROZWdhdGVkQXR0cmlidXRlcyA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCBuZWdhdGVkQXR0cmlidXRlcykgPT4ge1xuICAvLyBjaGVjayBpZiB3ZSByZWFsbHkgbmVlZCB0byByZW1vdmUgYXR0cmlidXRlc1xuICB3aGlsZSAoXG4gICAgY3VyclBvcy5yaWdodCAhPT0gbnVsbCAmJiAoXG4gICAgICBjdXJyUG9zLnJpZ2h0LmRlbGV0ZWQgPT09IHRydWUgfHwgKFxuICAgICAgICBjdXJyUG9zLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQgJiZcbiAgICAgICAgZXF1YWxBdHRycyhuZWdhdGVkQXR0cmlidXRlcy5nZXQoLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KS5rZXkpLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQpLnZhbHVlKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgaWYgKCFjdXJyUG9zLnJpZ2h0LmRlbGV0ZWQpIHtcbiAgICAgIG5lZ2F0ZWRBdHRyaWJ1dGVzLmRlbGV0ZSgvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQpLmtleSk7XG4gICAgfVxuICAgIGN1cnJQb3MuZm9yd2FyZCgpO1xuICB9XG4gIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SUQ7XG4gIG5lZ2F0ZWRBdHRyaWJ1dGVzLmZvckVhY2goKHZhbCwga2V5KSA9PiB7XG4gICAgY29uc3QgbGVmdCA9IGN1cnJQb3MubGVmdDtcbiAgICBjb25zdCByaWdodCA9IGN1cnJQb3MucmlnaHQ7XG4gICAgY29uc3QgbmV4dEZvcm1hdCA9IG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShkb2Muc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudEZvcm1hdChrZXksIHZhbCkpO1xuICAgIG5leHRGb3JtYXQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgICBjdXJyUG9zLnJpZ2h0ID0gbmV4dEZvcm1hdDtcbiAgICBjdXJyUG9zLmZvcndhcmQoKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxhbnk+fSBjdXJyZW50QXR0cmlidXRlc1xuICogQHBhcmFtIHtDb250ZW50Rm9ybWF0fSBmb3JtYXRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzID0gKGN1cnJlbnRBdHRyaWJ1dGVzLCBmb3JtYXQpID0+IHtcbiAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBmb3JtYXQ7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIGN1cnJlbnRBdHRyaWJ1dGVzLmRlbGV0ZShrZXkpO1xuICB9IGVsc2Uge1xuICAgIGN1cnJlbnRBdHRyaWJ1dGVzLnNldChrZXksIHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYXR0cmlidXRlc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgbWluaW1pemVBdHRyaWJ1dGVDaGFuZ2VzID0gKGN1cnJQb3MsIGF0dHJpYnV0ZXMpID0+IHtcbiAgLy8gZ28gcmlnaHQgd2hpbGUgYXR0cmlidXRlc1tyaWdodC5rZXldID09PSByaWdodC52YWx1ZSAob3IgcmlnaHQgaXMgZGVsZXRlZClcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoY3VyclBvcy5yaWdodCA9PT0gbnVsbCkge1xuICAgICAgYnJlYWtcbiAgICB9IGVsc2UgaWYgKGN1cnJQb3MucmlnaHQuZGVsZXRlZCB8fCAoY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0ICYmIGVxdWFsQXR0cnMoYXR0cmlidXRlc1soLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KSkua2V5XSA/PyBudWxsLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQpLnZhbHVlKSkpIDsgZWxzZSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjdXJyUG9zLmZvcndhcmQoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYXR0cmlidXRlc1xuICogQHJldHVybiB7TWFwPHN0cmluZyxhbnk+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqKi9cbmNvbnN0IGluc2VydEF0dHJpYnV0ZXMgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgYXR0cmlidXRlcykgPT4ge1xuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gIGNvbnN0IG93bkNsaWVudElkID0gZG9jLmNsaWVudElEO1xuICBjb25zdCBuZWdhdGVkQXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcbiAgLy8gaW5zZXJ0IGZvcm1hdC1zdGFydCBpdGVtc1xuICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgdmFsID0gYXR0cmlidXRlc1trZXldO1xuICAgIGNvbnN0IGN1cnJlbnRWYWwgPSBjdXJyUG9zLmN1cnJlbnRBdHRyaWJ1dGVzLmdldChrZXkpID8/IG51bGw7XG4gICAgaWYgKCFlcXVhbEF0dHJzKGN1cnJlbnRWYWwsIHZhbCkpIHtcbiAgICAgIC8vIHNhdmUgbmVnYXRlZCBhdHRyaWJ1dGUgKHNldCBudWxsIGlmIGN1cnJlbnRWYWwgdW5kZWZpbmVkKVxuICAgICAgbmVnYXRlZEF0dHJpYnV0ZXMuc2V0KGtleSwgY3VycmVudFZhbCk7XG4gICAgICBjb25zdCB7IGxlZnQsIHJpZ2h0IH0gPSBjdXJyUG9zO1xuICAgICAgY3VyclBvcy5yaWdodCA9IG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShkb2Muc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudEZvcm1hdChrZXksIHZhbCkpO1xuICAgICAgY3VyclBvcy5yaWdodC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICAgICAgY3VyclBvcy5mb3J3YXJkKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWdhdGVkQXR0cmlidXRlc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R8QWJzdHJhY3RUeXBlPGFueT59IHRleHRcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBhdHRyaWJ1dGVzXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICoqL1xuY29uc3QgaW5zZXJ0VGV4dCA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCB0ZXh0LCBhdHRyaWJ1dGVzKSA9PiB7XG4gIGN1cnJQb3MuY3VycmVudEF0dHJpYnV0ZXMuZm9yRWFjaCgoX3ZhbCwga2V5KSA9PiB7XG4gICAgaWYgKGF0dHJpYnV0ZXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhdHRyaWJ1dGVzW2tleV0gPSBudWxsO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SUQ7XG4gIG1pbmltaXplQXR0cmlidXRlQ2hhbmdlcyhjdXJyUG9zLCBhdHRyaWJ1dGVzKTtcbiAgY29uc3QgbmVnYXRlZEF0dHJpYnV0ZXMgPSBpbnNlcnRBdHRyaWJ1dGVzKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGN1cnJQb3MsIGF0dHJpYnV0ZXMpO1xuICAvLyBpbnNlcnQgY29udGVudFxuICBjb25zdCBjb250ZW50ID0gdGV4dC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nID8gbmV3IENvbnRlbnRTdHJpbmcoLyoqIEB0eXBlIHtzdHJpbmd9ICovICh0ZXh0KSkgOiAodGV4dCBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IG5ldyBDb250ZW50VHlwZSh0ZXh0KSA6IG5ldyBDb250ZW50RW1iZWQodGV4dCkpO1xuICBsZXQgeyBsZWZ0LCByaWdodCwgaW5kZXggfSA9IGN1cnJQb3M7XG4gIGlmIChwYXJlbnQuX3NlYXJjaE1hcmtlcikge1xuICAgIHVwZGF0ZU1hcmtlckNoYW5nZXMocGFyZW50Ll9zZWFyY2hNYXJrZXIsIGN1cnJQb3MuaW5kZXgsIGNvbnRlbnQuZ2V0TGVuZ3RoKCkpO1xuICB9XG4gIHJpZ2h0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKGRvYy5zdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgcmlnaHQsIHJpZ2h0ICYmIHJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIGNvbnRlbnQpO1xuICByaWdodC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICBjdXJyUG9zLnJpZ2h0ID0gcmlnaHQ7XG4gIGN1cnJQb3MuaW5kZXggPSBpbmRleDtcbiAgY3VyclBvcy5mb3J3YXJkKCk7XG4gIGluc2VydE5lZ2F0ZWRBdHRyaWJ1dGVzKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGN1cnJQb3MsIG5lZ2F0ZWRBdHRyaWJ1dGVzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IGF0dHJpYnV0ZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGZvcm1hdFRleHQgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgbGVuZ3RoLCBhdHRyaWJ1dGVzKSA9PiB7XG4gIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SUQ7XG4gIG1pbmltaXplQXR0cmlidXRlQ2hhbmdlcyhjdXJyUG9zLCBhdHRyaWJ1dGVzKTtcbiAgY29uc3QgbmVnYXRlZEF0dHJpYnV0ZXMgPSBpbnNlcnRBdHRyaWJ1dGVzKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGN1cnJQb3MsIGF0dHJpYnV0ZXMpO1xuICAvLyBpdGVyYXRlIHVudGlsIGZpcnN0IG5vbi1mb3JtYXQgb3IgbnVsbCBpcyBmb3VuZFxuICAvLyBkZWxldGUgYWxsIGZvcm1hdHMgd2l0aCBhdHRyaWJ1dGVzW2Zvcm1hdC5rZXldICE9IG51bGxcbiAgLy8gYWxzbyBjaGVjayB0aGUgYXR0cmlidXRlcyBhZnRlciB0aGUgZmlyc3Qgbm9uLWZvcm1hdCBhcyB3ZSBkbyBub3Qgd2FudCB0byBpbnNlcnQgcmVkdW5kYW50IG5lZ2F0ZWQgYXR0cmlidXRlcyB0aGVyZVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbGFiZWxzXG4gIGl0ZXJhdGlvbkxvb3A6IHdoaWxlIChcbiAgICBjdXJyUG9zLnJpZ2h0ICE9PSBudWxsICYmXG4gICAgKGxlbmd0aCA+IDAgfHxcbiAgICAgIChcbiAgICAgICAgbmVnYXRlZEF0dHJpYnV0ZXMuc2l6ZSA+IDAgJiZcbiAgICAgICAgKGN1cnJQb3MucmlnaHQuZGVsZXRlZCB8fCBjdXJyUG9zLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQpXG4gICAgICApXG4gICAgKVxuICApIHtcbiAgICBpZiAoIWN1cnJQb3MucmlnaHQuZGVsZXRlZCkge1xuICAgICAgc3dpdGNoIChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OiB7XG4gICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQpO1xuICAgICAgICAgIGNvbnN0IGF0dHIgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgaWYgKGF0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGVxdWFsQXR0cnMoYXR0ciwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgIG5lZ2F0ZWRBdHRyaWJ1dGVzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gZnVydGhlciBleHRlbmQgbmVnYXRlZEF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbGFiZWxzXG4gICAgICAgICAgICAgICAgYnJlYWsgaXRlcmF0aW9uTG9vcFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5lZ2F0ZWRBdHRyaWJ1dGVzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJQb3MucmlnaHQuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VyclBvcy5jdXJyZW50QXR0cmlidXRlcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAobGVuZ3RoIDwgY3VyclBvcy5yaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChjdXJyUG9zLnJpZ2h0LmlkLmNsaWVudCwgY3VyclBvcy5yaWdodC5pZC5jbG9jayArIGxlbmd0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW5ndGggLT0gY3VyclBvcy5yaWdodC5sZW5ndGg7XG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgY3VyclBvcy5mb3J3YXJkKCk7XG4gIH1cbiAgLy8gUXVpbGwganVzdCBhc3N1bWVzIHRoYXQgdGhlIGVkaXRvciBzdGFydHMgd2l0aCBhIG5ld2xpbmUgYW5kIHRoYXQgaXQgYWx3YXlzXG4gIC8vIGVuZHMgd2l0aCBhIG5ld2xpbmUuIFdlIG9ubHkgaW5zZXJ0IHRoYXQgbmV3bGluZSB3aGVuIGEgbmV3IG5ld2xpbmUgaXNcbiAgLy8gaW5zZXJ0ZWQgLSBpLmUgd2hlbiBsZW5ndGggaXMgYmlnZ2VyIHRoYW4gdHlwZS5sZW5ndGhcbiAgaWYgKGxlbmd0aCA+IDApIHtcbiAgICBsZXQgbmV3bGluZXMgPSAnJztcbiAgICBmb3IgKDsgbGVuZ3RoID4gMDsgbGVuZ3RoLS0pIHtcbiAgICAgIG5ld2xpbmVzICs9ICdcXG4nO1xuICAgIH1cbiAgICBjdXJyUG9zLnJpZ2h0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKGRvYy5zdG9yZSwgb3duQ2xpZW50SWQpKSwgY3VyclBvcy5sZWZ0LCBjdXJyUG9zLmxlZnQgJiYgY3VyclBvcy5sZWZ0Lmxhc3RJZCwgY3VyclBvcy5yaWdodCwgY3VyclBvcy5yaWdodCAmJiBjdXJyUG9zLnJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIG5ldyBDb250ZW50U3RyaW5nKG5ld2xpbmVzKSk7XG4gICAgY3VyclBvcy5yaWdodC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICAgIGN1cnJQb3MuZm9yd2FyZCgpO1xuICB9XG4gIGluc2VydE5lZ2F0ZWRBdHRyaWJ1dGVzKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGN1cnJQb3MsIG5lZ2F0ZWRBdHRyaWJ1dGVzKTtcbn07XG5cbi8qKlxuICogQ2FsbCB0aGlzIGZ1bmN0aW9uIGFmdGVyIHN0cmluZyBjb250ZW50IGhhcyBiZWVuIGRlbGV0ZWQgaW4gb3JkZXIgdG9cbiAqIGNsZWFuIHVwIGZvcm1hdHRpbmcgSXRlbXMuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7SXRlbX0gc3RhcnRcbiAqIEBwYXJhbSB7SXRlbXxudWxsfSBjdXJyIGV4Y2x1c2l2ZSBlbmQsIGF1dG9tYXRpY2FsbHkgaXRlcmF0ZXMgdG8gdGhlIG5leHQgQ29udGVudCBJdGVtXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsYW55Pn0gc3RhcnRBdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsYW55Pn0gY3VyckF0dHJpYnV0ZXNcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGFtb3VudCBvZiBmb3JtYXR0aW5nIEl0ZW1zIGRlbGV0ZWQuXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNsZWFudXBGb3JtYXR0aW5nR2FwID0gKHRyYW5zYWN0aW9uLCBzdGFydCwgY3Vyciwgc3RhcnRBdHRyaWJ1dGVzLCBjdXJyQXR0cmlidXRlcykgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICovXG4gIGxldCBlbmQgPSBzdGFydDtcbiAgLyoqXG4gICAqIEB0eXBlIHtNYXA8c3RyaW5nLENvbnRlbnRGb3JtYXQ+fVxuICAgKi9cbiAgY29uc3QgZW5kRm9ybWF0cyA9IG1hcC5jcmVhdGUoKTtcbiAgd2hpbGUgKGVuZCAmJiAoIWVuZC5jb3VudGFibGUgfHwgZW5kLmRlbGV0ZWQpKSB7XG4gICAgaWYgKCFlbmQuZGVsZXRlZCAmJiBlbmQuY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdCkge1xuICAgICAgY29uc3QgY2YgPSAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChlbmQuY29udGVudCk7XG4gICAgICBlbmRGb3JtYXRzLnNldChjZi5rZXksIGNmKTtcbiAgICB9XG4gICAgZW5kID0gZW5kLnJpZ2h0O1xuICB9XG4gIGxldCBjbGVhbnVwcyA9IDA7XG4gIGxldCByZWFjaGVkQ3VyciA9IGZhbHNlO1xuICB3aGlsZSAoc3RhcnQgIT09IGVuZCkge1xuICAgIGlmIChjdXJyID09PSBzdGFydCkge1xuICAgICAgcmVhY2hlZEN1cnIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXN0YXJ0LmRlbGV0ZWQpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBzdGFydC5jb250ZW50O1xuICAgICAgc3dpdGNoIChjb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgQ29udGVudEZvcm1hdDoge1xuICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY29udGVudCk7XG4gICAgICAgICAgY29uc3Qgc3RhcnRBdHRyVmFsdWUgPSBzdGFydEF0dHJpYnV0ZXMuZ2V0KGtleSkgPz8gbnVsbDtcbiAgICAgICAgICBpZiAoZW5kRm9ybWF0cy5nZXQoa2V5KSAhPT0gY29udGVudCB8fCBzdGFydEF0dHJWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEVpdGhlciB0aGlzIGZvcm1hdCBpcyBvdmVyd3JpdHRlbiBvciBpdCBpcyBub3QgbmVjZXNzYXJ5IGJlY2F1c2UgdGhlIGF0dHJpYnV0ZSBhbHJlYWR5IGV4aXN0ZWQuXG4gICAgICAgICAgICBzdGFydC5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgY2xlYW51cHMrKztcbiAgICAgICAgICAgIGlmICghcmVhY2hlZEN1cnIgJiYgKGN1cnJBdHRyaWJ1dGVzLmdldChrZXkpID8/IG51bGwpID09PSB2YWx1ZSAmJiBzdGFydEF0dHJWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0QXR0clZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3VyckF0dHJpYnV0ZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VyckF0dHJpYnV0ZXMuc2V0KGtleSwgc3RhcnRBdHRyVmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVhY2hlZEN1cnIgJiYgIXN0YXJ0LmRlbGV0ZWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjb250ZW50KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQgPSAvKiogQHR5cGUge0l0ZW19ICovIChzdGFydC5yaWdodCk7XG4gIH1cbiAgcmV0dXJuIGNsZWFudXBzXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0l0ZW0gfCBudWxsfSBpdGVtXG4gKi9cbmNvbnN0IGNsZWFudXBDb250ZXh0bGVzc0Zvcm1hdHRpbmdHYXAgPSAodHJhbnNhY3Rpb24sIGl0ZW0pID0+IHtcbiAgLy8gaXRlcmF0ZSB1bnRpbCBpdGVtLnJpZ2h0IGlzIG51bGwgb3IgY29udGVudFxuICB3aGlsZSAoaXRlbSAmJiBpdGVtLnJpZ2h0ICYmIChpdGVtLnJpZ2h0LmRlbGV0ZWQgfHwgIWl0ZW0ucmlnaHQuY291bnRhYmxlKSkge1xuICAgIGl0ZW0gPSBpdGVtLnJpZ2h0O1xuICB9XG4gIGNvbnN0IGF0dHJzID0gbmV3IFNldCgpO1xuICAvLyBpdGVyYXRlIGJhY2sgdW50aWwgYSBjb250ZW50IGl0ZW0gaXMgZm91bmRcbiAgd2hpbGUgKGl0ZW0gJiYgKGl0ZW0uZGVsZXRlZCB8fCAhaXRlbS5jb3VudGFibGUpKSB7XG4gICAgaWYgKCFpdGVtLmRlbGV0ZWQgJiYgaXRlbS5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0KSB7XG4gICAgICBjb25zdCBrZXkgPSAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChpdGVtLmNvbnRlbnQpLmtleTtcbiAgICAgIGlmIChhdHRycy5oYXMoa2V5KSkge1xuICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRycy5hZGQoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaXRlbSA9IGl0ZW0ubGVmdDtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGV4cGVyaW1lbnRhbCBhbmQgc3ViamVjdCB0byBjaGFuZ2UgLyBiZSByZW1vdmVkLlxuICpcbiAqIElkZWFsbHksIHdlIGRvbid0IG5lZWQgdGhpcyBmdW5jdGlvbiBhdCBhbGwuIEZvcm1hdHRpbmcgYXR0cmlidXRlcyBzaG91bGQgYmUgY2xlYW5lZCB1cFxuICogYXV0b21hdGljYWxseSBhZnRlciBlYWNoIGNoYW5nZS4gVGhpcyBmdW5jdGlvbiBpdGVyYXRlcyB0d2ljZSBvdmVyIHRoZSBjb21wbGV0ZSBZVGV4dCB0eXBlXG4gKiBhbmQgcmVtb3ZlcyB1bm5lY2Vzc2FyeSBmb3JtYXR0aW5nIGF0dHJpYnV0ZXMuIFRoaXMgaXMgYWxzbyBoZWxwZnVsIGZvciB0ZXN0aW5nLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd29uJ3QgYmUgZXhwb3J0ZWQgYW55bW9yZSBhcyBzb29uIGFzIHRoZXJlIGlzIGNvbmZpZGVuY2UgdGhhdCB0aGUgWVRleHQgdHlwZSB3b3JrcyBhcyBpbnRlbmRlZC5cbiAqXG4gKiBAcGFyYW0ge1lUZXh0fSB0eXBlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEhvdyBtYW55IGZvcm1hdHRpbmcgYXR0cmlidXRlcyBoYXZlIGJlZW4gY2xlYW5lZCB1cC5cbiAqL1xuY29uc3QgY2xlYW51cFlUZXh0Rm9ybWF0dGluZyA9IHR5cGUgPT4ge1xuICBsZXQgcmVzID0gMDtcbiAgdHJhbnNhY3QoLyoqIEB0eXBlIHtEb2N9ICovICh0eXBlLmRvYyksIHRyYW5zYWN0aW9uID0+IHtcbiAgICBsZXQgc3RhcnQgPSAvKiogQHR5cGUge0l0ZW19ICovICh0eXBlLl9zdGFydCk7XG4gICAgbGV0IGVuZCA9IHR5cGUuX3N0YXJ0O1xuICAgIGxldCBzdGFydEF0dHJpYnV0ZXMgPSBtYXAuY3JlYXRlKCk7XG4gICAgY29uc3QgY3VycmVudEF0dHJpYnV0ZXMgPSBtYXAuY29weShzdGFydEF0dHJpYnV0ZXMpO1xuICAgIHdoaWxlIChlbmQpIHtcbiAgICAgIGlmIChlbmQuZGVsZXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgc3dpdGNoIChlbmQuY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgIGNhc2UgQ29udGVudEZvcm1hdDpcbiAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJlbnRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChlbmQuY29udGVudCkpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmVzICs9IGNsZWFudXBGb3JtYXR0aW5nR2FwKHRyYW5zYWN0aW9uLCBzdGFydCwgZW5kLCBzdGFydEF0dHJpYnV0ZXMsIGN1cnJlbnRBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIHN0YXJ0QXR0cmlidXRlcyA9IG1hcC5jb3B5KGN1cnJlbnRBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZW5kID0gZW5kLnJpZ2h0O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn07XG5cbi8qKlxuICogVGhpcyB3aWxsIGJlIGNhbGxlZCBieSB0aGUgdHJhbnNhY3Rpb24gb25jZSB0aGUgZXZlbnQgaGFuZGxlcnMgYXJlIGNhbGxlZCB0byBwb3RlbnRpYWxseSBjbGVhbnVwXG4gKiBmb3JtYXR0aW5nIGF0dHJpYnV0ZXMuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqL1xuY29uc3QgY2xlYW51cFlUZXh0QWZ0ZXJUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtTZXQ8WVRleHQ+fVxuICAgKi9cbiAgY29uc3QgbmVlZEZ1bGxDbGVhbnVwID0gbmV3IFNldCgpO1xuICAvLyBjaGVjayBpZiBhbm90aGVyIGZvcm1hdHRpbmcgaXRlbSB3YXMgaW5zZXJ0ZWRcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICBmb3IgKGNvbnN0IFtjbGllbnQsIGFmdGVyQ2xvY2tdIG9mIHRyYW5zYWN0aW9uLmFmdGVyU3RhdGUuZW50cmllcygpKSB7XG4gICAgY29uc3QgY2xvY2sgPSB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoY2xpZW50KSB8fCAwO1xuICAgIGlmIChhZnRlckNsb2NrID09PSBjbG9jaykge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaXRlcmF0ZVN0cnVjdHModHJhbnNhY3Rpb24sIC8qKiBAdHlwZSB7QXJyYXk8SXRlbXxHQz59ICovIChkb2Muc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSksIGNsb2NrLCBhZnRlckNsb2NrLCBpdGVtID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgIWl0ZW0uZGVsZXRlZCAmJiAvKiogQHR5cGUge0l0ZW19ICovIChpdGVtKS5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0ICYmIGl0ZW0uY29uc3RydWN0b3IgIT09IEdDXG4gICAgICApIHtcbiAgICAgICAgbmVlZEZ1bGxDbGVhbnVwLmFkZCgvKiogQHR5cGUge2FueX0gKi8gKGl0ZW0pLnBhcmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLy8gY2xlYW51cCBpbiBhIG5ldyB0cmFuc2FjdGlvblxuICB0cmFuc2FjdChkb2MsICh0KSA9PiB7XG4gICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbi5kZWxldGVTZXQsIGl0ZW0gPT4ge1xuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBHQyB8fCAhKC8qKiBAdHlwZSB7WVRleHR9ICovIChpdGVtLnBhcmVudCkuX2hhc0Zvcm1hdHRpbmcpIHx8IG5lZWRGdWxsQ2xlYW51cC5oYXMoLyoqIEB0eXBlIHtZVGV4dH0gKi8gKGl0ZW0ucGFyZW50KSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCBwYXJlbnQgPSAvKiogQHR5cGUge1lUZXh0fSAqLyAoaXRlbS5wYXJlbnQpO1xuICAgICAgaWYgKGl0ZW0uY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdCkge1xuICAgICAgICBuZWVkRnVsbENsZWFudXAuYWRkKHBhcmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBubyBmb3JtYXR0aW5nIGF0dHJpYnV0ZSB3YXMgaW5zZXJ0ZWQgb3IgZGVsZXRlZCwgd2UgY2FuIG1ha2UgZHVlIHdpdGggY29udGV4dGxlc3NcbiAgICAgICAgLy8gZm9ybWF0dGluZyBjbGVhbnVwcy5cbiAgICAgICAgLy8gQ29udGV4dGxlc3M6IGl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcHV0ZSBjdXJyZW50QXR0cmlidXRlcyBmb3IgdGhlIGFmZmVjdGVkIHBvc2l0aW9uLlxuICAgICAgICBjbGVhbnVwQ29udGV4dGxlc3NGb3JtYXR0aW5nR2FwKHQsIGl0ZW0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIElmIGEgZm9ybWF0dGluZyBpdGVtIHdhcyBpbnNlcnRlZCwgd2Ugc2ltcGx5IGNsZWFuIHRoZSB3aG9sZSB0eXBlLlxuICAgIC8vIFdlIG5lZWQgdG8gY29tcHV0ZSBjdXJyZW50QXR0cmlidXRlcyBmb3IgdGhlIGN1cnJlbnQgcG9zaXRpb24gYW55d2F5LlxuICAgIGZvciAoY29uc3QgeVRleHQgb2YgbmVlZEZ1bGxDbGVhbnVwKSB7XG4gICAgICBjbGVhbnVwWVRleHRGb3JtYXR0aW5nKHlUZXh0KTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICogQHJldHVybiB7SXRlbVRleHRMaXN0UG9zaXRpb259XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBkZWxldGVUZXh0ID0gKHRyYW5zYWN0aW9uLCBjdXJyUG9zLCBsZW5ndGgpID0+IHtcbiAgY29uc3Qgc3RhcnRMZW5ndGggPSBsZW5ndGg7XG4gIGNvbnN0IHN0YXJ0QXR0cnMgPSBtYXAuY29weShjdXJyUG9zLmN1cnJlbnRBdHRyaWJ1dGVzKTtcbiAgY29uc3Qgc3RhcnQgPSBjdXJyUG9zLnJpZ2h0O1xuICB3aGlsZSAobGVuZ3RoID4gMCAmJiBjdXJyUG9zLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgaWYgKGN1cnJQb3MucmlnaHQuZGVsZXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHN3aXRjaCAoY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgQ29udGVudFR5cGU6XG4gICAgICAgIGNhc2UgQ29udGVudEVtYmVkOlxuICAgICAgICBjYXNlIENvbnRlbnRTdHJpbmc6XG4gICAgICAgICAgaWYgKGxlbmd0aCA8IGN1cnJQb3MucmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQoY3VyclBvcy5yaWdodC5pZC5jbGllbnQsIGN1cnJQb3MucmlnaHQuaWQuY2xvY2sgKyBsZW5ndGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoIC09IGN1cnJQb3MucmlnaHQubGVuZ3RoO1xuICAgICAgICAgIGN1cnJQb3MucmlnaHQuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBjdXJyUG9zLmZvcndhcmQoKTtcbiAgfVxuICBpZiAoc3RhcnQpIHtcbiAgICBjbGVhbnVwRm9ybWF0dGluZ0dhcCh0cmFuc2FjdGlvbiwgc3RhcnQsIGN1cnJQb3MucmlnaHQsIHN0YXJ0QXR0cnMsIGN1cnJQb3MuY3VycmVudEF0dHJpYnV0ZXMpO1xuICB9XG4gIGNvbnN0IHBhcmVudCA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICgvKiogQHR5cGUge0l0ZW19ICovIChjdXJyUG9zLmxlZnQgfHwgY3VyclBvcy5yaWdodCkucGFyZW50KTtcbiAgaWYgKHBhcmVudC5fc2VhcmNoTWFya2VyKSB7XG4gICAgdXBkYXRlTWFya2VyQ2hhbmdlcyhwYXJlbnQuX3NlYXJjaE1hcmtlciwgY3VyclBvcy5pbmRleCwgLXN0YXJ0TGVuZ3RoICsgbGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gY3VyclBvc1xufTtcblxuLyoqXG4gKiBUaGUgUXVpbGwgRGVsdGEgZm9ybWF0IHJlcHJlc2VudHMgY2hhbmdlcyBvbiBhIHRleHQgZG9jdW1lbnQgd2l0aFxuICogZm9ybWF0dGluZyBpbmZvcm1hdGlvbi4gRm9yIG1vcmUgaW5mb3JtYXRpb24gdmlzaXQge0BsaW5rIGh0dHBzOi8vcXVpbGxqcy5jb20vZG9jcy9kZWx0YS98UXVpbGwgRGVsdGF9XG4gKlxuICogQGV4YW1wbGVcbiAqICAge1xuICogICAgIG9wczogW1xuICogICAgICAgeyBpbnNlcnQ6ICdHYW5kYWxmJywgYXR0cmlidXRlczogeyBib2xkOiB0cnVlIH0gfSxcbiAqICAgICAgIHsgaW5zZXJ0OiAnIHRoZSAnIH0sXG4gKiAgICAgICB7IGluc2VydDogJ0dyZXknLCBhdHRyaWJ1dGVzOiB7IGNvbG9yOiAnI2NjY2NjYycgfSB9XG4gKiAgICAgXVxuICogICB9XG4gKlxuICovXG5cbi8qKlxuICAqIEF0dHJpYnV0ZXMgdGhhdCBjYW4gYmUgYXNzaWduZWQgdG8gYSBzZWxlY3Rpb24gb2YgdGV4dC5cbiAgKlxuICAqIEBleGFtcGxlXG4gICogICB7XG4gICogICAgIGJvbGQ6IHRydWUsXG4gICogICAgIGZvbnQtc2l6ZTogJzQwcHgnXG4gICogICB9XG4gICpcbiAgKiBAdHlwZWRlZiB7T2JqZWN0fSBUZXh0QXR0cmlidXRlc1xuICAqL1xuXG4vKipcbiAqIEBleHRlbmRzIFlFdmVudDxZVGV4dD5cbiAqIEV2ZW50IHRoYXQgZGVzY3JpYmVzIHRoZSBjaGFuZ2VzIG9uIGEgWVRleHQgdHlwZS5cbiAqL1xuY2xhc3MgWVRleHRFdmVudCBleHRlbmRzIFlFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1lUZXh0fSB5dGV4dFxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1NldDxhbnk+fSBzdWJzIFRoZSBrZXlzIHRoYXQgY2hhbmdlZFxuICAgKi9cbiAgY29uc3RydWN0b3IgKHl0ZXh0LCB0cmFuc2FjdGlvbiwgc3Vicykge1xuICAgIHN1cGVyKHl0ZXh0LCB0cmFuc2FjdGlvbik7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY2hpbGRyZW4gY2hhbmdlZC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY2hpbGRMaXN0Q2hhbmdlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFNldCBvZiBhbGwgY2hhbmdlZCBhdHRyaWJ1dGVzLlxuICAgICAqIEB0eXBlIHtTZXQ8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmtleXNDaGFuZ2VkID0gbmV3IFNldCgpO1xuICAgIHN1YnMuZm9yRWFjaCgoc3ViKSA9PiB7XG4gICAgICBpZiAoc3ViID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2hpbGRMaXN0Q2hhbmdlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmtleXNDaGFuZ2VkLmFkZChzdWIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHt7YWRkZWQ6U2V0PEl0ZW0+LGRlbGV0ZWQ6U2V0PEl0ZW0+LGtleXM6TWFwPHN0cmluZyx7YWN0aW9uOidhZGQnfCd1cGRhdGUnfCdkZWxldGUnLG9sZFZhbHVlOmFueX0+LGRlbHRhOkFycmF5PHtpbnNlcnQ/OkFycmF5PGFueT58c3RyaW5nLCBkZWxldGU/Om51bWJlciwgcmV0YWluPzpudW1iZXJ9Pn19XG4gICAqL1xuICBnZXQgY2hhbmdlcyAoKSB7XG4gICAgaWYgKHRoaXMuX2NoYW5nZXMgPT09IG51bGwpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge3thZGRlZDpTZXQ8SXRlbT4sZGVsZXRlZDpTZXQ8SXRlbT4sa2V5czpNYXA8c3RyaW5nLHthY3Rpb246J2FkZCd8J3VwZGF0ZSd8J2RlbGV0ZScsb2xkVmFsdWU6YW55fT4sZGVsdGE6QXJyYXk8e2luc2VydD86QXJyYXk8YW55PnxzdHJpbmd8QWJzdHJhY3RUeXBlPGFueT58b2JqZWN0LCBkZWxldGU/Om51bWJlciwgcmV0YWluPzpudW1iZXJ9Pn19XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGNoYW5nZXMgPSB7XG4gICAgICAgIGtleXM6IHRoaXMua2V5cyxcbiAgICAgICAgZGVsdGE6IHRoaXMuZGVsdGEsXG4gICAgICAgIGFkZGVkOiBuZXcgU2V0KCksXG4gICAgICAgIGRlbGV0ZWQ6IG5ldyBTZXQoKVxuICAgICAgfTtcbiAgICAgIHRoaXMuX2NoYW5nZXMgPSBjaGFuZ2VzO1xuICAgIH1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovICh0aGlzLl9jaGFuZ2VzKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIGNoYW5nZXMgaW4gdGhlIGRlbHRhIGZvcm1hdC5cbiAgICogQSB7QGxpbmsgaHR0cHM6Ly9xdWlsbGpzLmNvbS9kb2NzL2RlbHRhL3xRdWlsbCBEZWx0YX0pIHRoYXQgcmVwcmVzZW50cyB0aGUgY2hhbmdlcyBvbiB0aGUgZG9jdW1lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTx7aW5zZXJ0PzpzdHJpbmd8b2JqZWN0fEFic3RyYWN0VHlwZTxhbnk+LCBkZWxldGU/Om51bWJlciwgcmV0YWluPzpudW1iZXIsIGF0dHJpYnV0ZXM/OiBPYmplY3Q8c3RyaW5nLGFueT59Pn1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0IGRlbHRhICgpIHtcbiAgICBpZiAodGhpcy5fZGVsdGEgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHkgPSAvKiogQHR5cGUge0RvY30gKi8gKHRoaXMudGFyZ2V0LmRvYyk7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtBcnJheTx7aW5zZXJ0PzpzdHJpbmd8b2JqZWN0fEFic3RyYWN0VHlwZTxhbnk+LCBkZWxldGU/Om51bWJlciwgcmV0YWluPzpudW1iZXIsIGF0dHJpYnV0ZXM/OiBPYmplY3Q8c3RyaW5nLGFueT59Pn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgZGVsdGEgPSBbXTtcbiAgICAgIHRyYW5zYWN0KHksIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudEF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7IC8vIHNhdmVzIGFsbCBjdXJyZW50IGF0dHJpYnV0ZXMgZm9yIGluc2VydFxuICAgICAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMudGFyZ2V0Ll9zdGFydDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmc/fVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGFjdGlvbiA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHt9OyAvLyBjb3VudHMgYWRkZWQgb3IgcmVtb3ZlZCBuZXcgYXR0cmlidXRlcyBmb3IgcmV0YWluXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfG9iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGxldCBpbnNlcnQgPSAnJztcbiAgICAgICAgbGV0IHJldGFpbiA9IDA7XG4gICAgICAgIGxldCBkZWxldGVMZW4gPSAwO1xuICAgICAgICBjb25zdCBhZGRPcCA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoYWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlIHthbnl9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxldCBvcCA9IG51bGw7XG4gICAgICAgICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgICAgIGlmIChkZWxldGVMZW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICBvcCA9IHsgZGVsZXRlOiBkZWxldGVMZW4gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlTGVuID0gMDtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlICdpbnNlcnQnOlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5zZXJ0ID09PSAnb2JqZWN0JyB8fCBpbnNlcnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgb3AgPSB7IGluc2VydCB9O1xuICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBdHRyaWJ1dGVzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wLmF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEF0dHJpYnV0ZXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3AuYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5zZXJ0ID0gJyc7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSAncmV0YWluJzpcbiAgICAgICAgICAgICAgICBpZiAocmV0YWluID4gMCkge1xuICAgICAgICAgICAgICAgICAgb3AgPSB7IHJldGFpbiB9O1xuICAgICAgICAgICAgICAgICAgaWYgKCFvYmplY3QuaXNFbXB0eShhdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBvcC5hdHRyaWJ1dGVzID0gb2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldGFpbiA9IDA7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcCkgZGVsdGEucHVzaChvcCk7XG4gICAgICAgICAgICBhY3Rpb24gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2hpbGUgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICBzd2l0Y2ggKGl0ZW0uY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY2FzZSBDb250ZW50VHlwZTpcbiAgICAgICAgICAgIGNhc2UgQ29udGVudEVtYmVkOlxuICAgICAgICAgICAgICBpZiAodGhpcy5hZGRzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICBhY3Rpb24gPSAnaW5zZXJ0JztcbiAgICAgICAgICAgICAgICAgIGluc2VydCA9IGl0ZW0uY29udGVudC5nZXRDb250ZW50KClbMF07XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdkZWxldGUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGVMZW4gKz0gMTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ3JldGFpbicpIHtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICBhY3Rpb24gPSAncmV0YWluJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0YWluICs9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgQ29udGVudFN0cmluZzpcbiAgICAgICAgICAgICAgaWYgKHRoaXMuYWRkcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kZWxldGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9PSAnaW5zZXJ0Jykge1xuICAgICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSAnaW5zZXJ0JztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGluc2VydCArPSAvKiogQHR5cGUge0NvbnRlbnRTdHJpbmd9ICovIChpdGVtLmNvbnRlbnQpLnN0cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kZWxldGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICBhY3Rpb24gPSAnZGVsZXRlJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlTGVuICs9IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdyZXRhaW4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXRhaW4gKz0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgQ29udGVudEZvcm1hdDoge1xuICAgICAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGl0ZW0uY29udGVudCk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgY3VyVmFsID0gY3VycmVudEF0dHJpYnV0ZXMuZ2V0KGtleSkgPz8gbnVsbDtcbiAgICAgICAgICAgICAgICAgIGlmICghZXF1YWxBdHRycyhjdXJWYWwsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVxdWFsQXR0cnModmFsdWUsIChvbGRBdHRyaWJ1dGVzLmdldChrZXkpID8/IG51bGwpKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBvbGRBdHRyaWJ1dGVzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJWYWwgPSBjdXJyZW50QXR0cmlidXRlcy5nZXQoa2V5KSA/PyBudWxsO1xuICAgICAgICAgICAgICAgIGlmICghZXF1YWxBdHRycyhjdXJWYWwsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3JldGFpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IGN1clZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIG9sZEF0dHJpYnV0ZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFlcXVhbEF0dHJzKGF0dHIsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRyICE9PSBudWxsKSB7IC8vIHRoaXMgd2lsbCBiZSBjbGVhbmVkIHVwIGF1dG9tYXRpY2FsbHkgYnkgdGhlIGNvbnRleHRsZXNzIGNsZWFudXAgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgaXRlbS5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdpbnNlcnQnKSB7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhjdXJyZW50QXR0cmlidXRlcywgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoaXRlbS5jb250ZW50KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlbSA9IGl0ZW0ucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgd2hpbGUgKGRlbHRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBsYXN0T3AgPSBkZWx0YVtkZWx0YS5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAobGFzdE9wLnJldGFpbiAhPT0gdW5kZWZpbmVkICYmIGxhc3RPcC5hdHRyaWJ1dGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHJldGFpbiBkZWx0YSdzIGlmIHRoZXkgZG9uJ3QgYXNzaWduIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGRlbHRhLnBvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9kZWx0YSA9IGRlbHRhO1xuICAgIH1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovICh0aGlzLl9kZWx0YSlcbiAgfVxufVxuXG4vKipcbiAqIFR5cGUgdGhhdCByZXByZXNlbnRzIHRleHQgd2l0aCBmb3JtYXR0aW5nIGluZm9ybWF0aW9uLlxuICpcbiAqIFRoaXMgdHlwZSByZXBsYWNlcyB5LXJpY2h0ZXh0IGFzIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgYWJsZSB0byBoYW5kbGVcbiAqIGJsb2NrIGZvcm1hdHMgKGZvcm1hdCBpbmZvcm1hdGlvbiBvbiBhIHBhcmFncmFwaCksIGVtYmVkcyAoY29tcGxleCBlbGVtZW50c1xuICogbGlrZSBwaWN0dXJlcyBhbmQgdmlkZW9zKSwgYW5kIHRleHQgZm9ybWF0cyAoKipib2xkKiosICppdGFsaWMqKS5cbiAqXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFR5cGU8WVRleHRFdmVudD5cbiAqL1xuY2xhc3MgWVRleHQgZXh0ZW5kcyBBYnN0cmFjdFR5cGUge1xuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtzdHJpbmddIFRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBZVGV4dC5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChzdHJpbmcpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIHBlbmRpbmcgb3BlcmF0aW9ucyBvbiB0aGlzIHR5cGVcbiAgICAgKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24oKTp2b2lkPj99XG4gICAgICovXG4gICAgdGhpcy5fcGVuZGluZyA9IHN0cmluZyAhPT0gdW5kZWZpbmVkID8gWygpID0+IHRoaXMuaW5zZXJ0KDAsIHN0cmluZyldIDogW107XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PEFycmF5U2VhcmNoTWFya2VyPnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX3NlYXJjaE1hcmtlciA9IFtdO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBZVGV4dCBjb250YWlucyBmb3JtYXR0aW5nIGF0dHJpYnV0ZXMuXG4gICAgICogVGhpcyBmbGFnIGlzIHVwZGF0ZWQgd2hlbiBhIGZvcm1hdHRpbmcgaXRlbSBpcyBpbnRlZ3JhdGVkIChzZWUgQ29udGVudEZvcm1hdC5pbnRlZ3JhdGUpXG4gICAgICovXG4gICAgdGhpcy5faGFzRm9ybWF0dGluZyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBjaGFyYWN0ZXJzIG9mIHRoaXMgdGV4dCB0eXBlLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGxlbmd0aCAoKSB7XG4gICAgdGhpcy5kb2MgPz8gd2FyblByZW1hdHVyZUFjY2VzcygpO1xuICAgIHJldHVybiB0aGlzLl9sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30geVxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIF9pbnRlZ3JhdGUgKHksIGl0ZW0pIHtcbiAgICBzdXBlci5faW50ZWdyYXRlKHksIGl0ZW0pO1xuICAgIHRyeSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLmZvckVhY2goZiA9PiBmKCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgfVxuICAgIHRoaXMuX3BlbmRpbmcgPSBudWxsO1xuICB9XG5cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWVRleHQoKVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIGEgY29weSBvZiB0aGlzIGRhdGEgdHlwZSB0aGF0IGNhbiBiZSBpbmNsdWRlZCBzb21ld2hlcmUgZWxzZS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBjb250ZW50IGlzIG9ubHkgcmVhZGFibGUgX2FmdGVyXyBpdCBoYXMgYmVlbiBpbmNsdWRlZCBzb21ld2hlcmUgaW4gdGhlIFlkb2MuXG4gICAqXG4gICAqIEByZXR1cm4ge1lUZXh0fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGNvbnN0IHRleHQgPSBuZXcgWVRleHQoKTtcbiAgICB0ZXh0LmFwcGx5RGVsdGEodGhpcy50b0RlbHRhKCkpO1xuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBZVGV4dEV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PG51bGx8c3RyaW5nPn0gcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgcGFyZW50U3Vicykge1xuICAgIHN1cGVyLl9jYWxsT2JzZXJ2ZXIodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpO1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IFlUZXh0RXZlbnQodGhpcywgdHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpO1xuICAgIGNhbGxUeXBlT2JzZXJ2ZXJzKHRoaXMsIHRyYW5zYWN0aW9uLCBldmVudCk7XG4gICAgLy8gSWYgYSByZW1vdGUgY2hhbmdlIGhhcHBlbmVkLCB3ZSB0cnkgdG8gY2xlYW51cCBwb3RlbnRpYWwgZm9ybWF0dGluZyBkdXBsaWNhdGVzLlxuICAgIGlmICghdHJhbnNhY3Rpb24ubG9jYWwgJiYgdGhpcy5faGFzRm9ybWF0dGluZykge1xuICAgICAgdHJhbnNhY3Rpb24uX25lZWRGb3JtYXR0aW5nQ2xlYW51cCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVuZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFlUZXh0IHR5cGUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICB0aGlzLmRvYyA/PyB3YXJuUHJlbWF0dXJlQWNjZXNzKCk7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICovXG4gICAgbGV0IG4gPSB0aGlzLl9zdGFydDtcbiAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgaWYgKCFuLmRlbGV0ZWQgJiYgbi5jb3VudGFibGUgJiYgbi5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50U3RyaW5nKSB7XG4gICAgICAgIHN0ciArPSAvKiogQHR5cGUge0NvbnRlbnRTdHJpbmd9ICovIChuLmNvbnRlbnQpLnN0cjtcbiAgICAgIH1cbiAgICAgIG4gPSBuLnJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gc3RyXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdW5mb3JtYXR0ZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgWVRleHQgdHlwZS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSBhIHtAbGluayBEZWx0YX0gb24gdGhpcyBzaGFyZWQgWVRleHQgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBkZWx0YSBUaGUgY2hhbmdlcyB0byBhcHBseSBvbiB0aGlzIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgb3B0c1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNhbml0aXplXSBTYW5pdGl6ZSBpbnB1dCBkZWx0YS4gUmVtb3ZlcyBlbmRpbmcgbmV3bGluZXMgaWYgc2V0IHRvIHRydWUuXG4gICAqXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFwcGx5RGVsdGEgKGRlbHRhLCB7IHNhbml0aXplID0gdHJ1ZSB9ID0ge30pIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJQb3MgPSBuZXcgSXRlbVRleHRMaXN0UG9zaXRpb24obnVsbCwgdGhpcy5fc3RhcnQsIDAsIG5ldyBNYXAoKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBvcCA9IGRlbHRhW2ldO1xuICAgICAgICAgIGlmIChvcC5pbnNlcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gUXVpbGwgYXNzdW1lcyB0aGF0IHRoZSBjb250ZW50IHN0YXJ0cyB3aXRoIGFuIGVtcHR5IHBhcmFncmFwaC5cbiAgICAgICAgICAgIC8vIFlqcy9ZLlRleHQgYXNzdW1lcyB0aGF0IGl0IHN0YXJ0cyBlbXB0eS4gV2UgYWx3YXlzIGhpZGUgdGhhdFxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgYSBuZXdsaW5lIGF0IHRoZSBlbmQgb2YgdGhlIGNvbnRlbnQuXG4gICAgICAgICAgICAvLyBJZiB3ZSBvbWl0IHRoaXMgc3RlcCwgY2xpZW50cyB3aWxsIHNlZSBhIGRpZmZlcmVudCBudW1iZXIgb2ZcbiAgICAgICAgICAgIC8vIHBhcmFncmFwaHMsIGJ1dCBub3RoaW5nIGJhZCB3aWxsIGhhcHBlbi5cbiAgICAgICAgICAgIGNvbnN0IGlucyA9ICghc2FuaXRpemUgJiYgdHlwZW9mIG9wLmluc2VydCA9PT0gJ3N0cmluZycgJiYgaSA9PT0gZGVsdGEubGVuZ3RoIC0gMSAmJiBjdXJyUG9zLnJpZ2h0ID09PSBudWxsICYmIG9wLmluc2VydC5zbGljZSgtMSkgPT09ICdcXG4nKSA/IG9wLmluc2VydC5zbGljZSgwLCAtMSkgOiBvcC5pbnNlcnQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucyAhPT0gJ3N0cmluZycgfHwgaW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgaW5zZXJ0VGV4dCh0cmFuc2FjdGlvbiwgdGhpcywgY3VyclBvcywgaW5zLCBvcC5hdHRyaWJ1dGVzIHx8IHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKG9wLnJldGFpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3JtYXRUZXh0KHRyYW5zYWN0aW9uLCB0aGlzLCBjdXJyUG9zLCBvcC5yZXRhaW4sIG9wLmF0dHJpYnV0ZXMgfHwge30pO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3AuZGVsZXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZVRleHQodHJhbnNhY3Rpb24sIGN1cnJQb3MsIG9wLmRlbGV0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMuYXBwbHlEZWx0YShkZWx0YSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBEZWx0YSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFlUZXh0IHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U25hcHNob3R9IFtzbmFwc2hvdF1cbiAgICogQHBhcmFtIHtTbmFwc2hvdH0gW3ByZXZTbmFwc2hvdF1cbiAgICogQHBhcmFtIHtmdW5jdGlvbigncmVtb3ZlZCcgfCAnYWRkZWQnLCBJRCk6YW55fSBbY29tcHV0ZVlDaGFuZ2VdXG4gICAqIEByZXR1cm4ge2FueX0gVGhlIERlbHRhIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9EZWx0YSAoc25hcHNob3QsIHByZXZTbmFwc2hvdCwgY29tcHV0ZVlDaGFuZ2UpIHtcbiAgICB0aGlzLmRvYyA/PyB3YXJuUHJlbWF0dXJlQWNjZXNzKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGV7QXJyYXk8YW55Pn1cbiAgICAgKi9cbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBjb25zdCBjdXJyZW50QXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkb2MgPSAvKiogQHR5cGUge0RvY30gKi8gKHRoaXMuZG9jKTtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgbGV0IG4gPSB0aGlzLl9zdGFydDtcbiAgICBmdW5jdGlvbiBwYWNrU3RyICgpIHtcbiAgICAgIGlmIChzdHIubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBwYWNrIHN0ciB3aXRoIGF0dHJpYnV0ZXMgdG8gb3BzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBsZXQgYWRkQXR0cmlidXRlcyA9IGZhbHNlO1xuICAgICAgICBjdXJyZW50QXR0cmlidXRlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgYWRkQXR0cmlidXRlcyA9IHRydWU7XG4gICAgICAgICAgYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsYW55Pn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IG9wID0geyBpbnNlcnQ6IHN0ciB9O1xuICAgICAgICBpZiAoYWRkQXR0cmlidXRlcykge1xuICAgICAgICAgIG9wLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB9XG4gICAgICAgIG9wcy5wdXNoKG9wKTtcbiAgICAgICAgc3RyID0gJyc7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbXB1dGVEZWx0YSA9ICgpID0+IHtcbiAgICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1Zpc2libGUobiwgc25hcHNob3QpIHx8IChwcmV2U25hcHNob3QgIT09IHVuZGVmaW5lZCAmJiBpc1Zpc2libGUobiwgcHJldlNuYXBzaG90KSkpIHtcbiAgICAgICAgICBzd2l0Y2ggKG4uY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY2FzZSBDb250ZW50U3RyaW5nOiB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1ciA9IGN1cnJlbnRBdHRyaWJ1dGVzLmdldCgneWNoYW5nZScpO1xuICAgICAgICAgICAgICBpZiAoc25hcHNob3QgIT09IHVuZGVmaW5lZCAmJiAhaXNWaXNpYmxlKG4sIHNuYXBzaG90KSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXIgPT09IHVuZGVmaW5lZCB8fCBjdXIudXNlciAhPT0gbi5pZC5jbGllbnQgfHwgY3VyLnR5cGUgIT09ICdyZW1vdmVkJykge1xuICAgICAgICAgICAgICAgICAgcGFja1N0cigpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudEF0dHJpYnV0ZXMuc2V0KCd5Y2hhbmdlJywgY29tcHV0ZVlDaGFuZ2UgPyBjb21wdXRlWUNoYW5nZSgncmVtb3ZlZCcsIG4uaWQpIDogeyB0eXBlOiAncmVtb3ZlZCcgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZTbmFwc2hvdCAhPT0gdW5kZWZpbmVkICYmICFpc1Zpc2libGUobiwgcHJldlNuYXBzaG90KSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXIgPT09IHVuZGVmaW5lZCB8fCBjdXIudXNlciAhPT0gbi5pZC5jbGllbnQgfHwgY3VyLnR5cGUgIT09ICdhZGRlZCcpIHtcbiAgICAgICAgICAgICAgICAgIHBhY2tTdHIoKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLnNldCgneWNoYW5nZScsIGNvbXB1dGVZQ2hhbmdlID8gY29tcHV0ZVlDaGFuZ2UoJ2FkZGVkJywgbi5pZCkgOiB7IHR5cGU6ICdhZGRlZCcgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFja1N0cigpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLmRlbGV0ZSgneWNoYW5nZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0ciArPSAvKiogQHR5cGUge0NvbnRlbnRTdHJpbmd9ICovIChuLmNvbnRlbnQpLnN0cjtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQ29udGVudFR5cGU6XG4gICAgICAgICAgICBjYXNlIENvbnRlbnRFbWJlZDoge1xuICAgICAgICAgICAgICBwYWNrU3RyKCk7XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgY29uc3Qgb3AgPSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0OiBuLmNvbnRlbnQuZ2V0Q29udGVudCgpWzBdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50QXR0cmlidXRlcy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gLyoqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59ICovICh7fSk7XG4gICAgICAgICAgICAgICAgb3AuYXR0cmlidXRlcyA9IGF0dHJzO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcHMucHVzaChvcCk7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6XG4gICAgICAgICAgICAgIGlmIChpc1Zpc2libGUobiwgc25hcHNob3QpKSB7XG4gICAgICAgICAgICAgICAgcGFja1N0cigpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJlbnRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChuLmNvbnRlbnQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuID0gbi5yaWdodDtcbiAgICAgIH1cbiAgICAgIHBhY2tTdHIoKTtcbiAgICB9O1xuICAgIGlmIChzbmFwc2hvdCB8fCBwcmV2U25hcHNob3QpIHtcbiAgICAgIC8vIHNuYXBzaG90cyBhcmUgbWVyZ2VkIGFnYWluIGFmdGVyIHRoZSB0cmFuc2FjdGlvbiwgc28gd2UgbmVlZCB0byBrZWVwIHRoZVxuICAgICAgLy8gdHJhbnNhY3Rpb24gYWxpdmUgdW50aWwgd2UgYXJlIGRvbmVcbiAgICAgIHRyYW5zYWN0KGRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBpZiAoc25hcHNob3QpIHtcbiAgICAgICAgICBzcGxpdFNuYXBzaG90QWZmZWN0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCBzbmFwc2hvdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZTbmFwc2hvdCkge1xuICAgICAgICAgIHNwbGl0U25hcHNob3RBZmZlY3RlZFN0cnVjdHModHJhbnNhY3Rpb24sIHByZXZTbmFwc2hvdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29tcHV0ZURlbHRhKCk7XG4gICAgICB9LCAnY2xlYW51cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21wdXRlRGVsdGEoKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wc1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCB0ZXh0IGF0IGEgZ2l2ZW4gaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgaW5zZXJ0aW5nLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBpbnNlcnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtUZXh0QXR0cmlidXRlc30gW2F0dHJpYnV0ZXNdIE9wdGlvbmFsbHkgZGVmaW5lIHNvbWUgZm9ybWF0dGluZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9ybWF0aW9uIHRvIGFwcGx5IG9uIHRoZSBpbnNlcnRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRleHQuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGluc2VydCAoaW5kZXgsIHRleHQsIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAodGV4dC5sZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHkgPSB0aGlzLmRvYztcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QoeSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBwb3MgPSBmaW5kUG9zaXRpb24odHJhbnNhY3Rpb24sIHRoaXMsIGluZGV4LCAhYXR0cmlidXRlcyk7XG4gICAgICAgIGlmICghYXR0cmlidXRlcykge1xuICAgICAgICAgIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgcG9zLmN1cnJlbnRBdHRyaWJ1dGVzLmZvckVhY2goKHYsIGspID0+IHsgYXR0cmlidXRlc1trXSA9IHY7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydFRleHQodHJhbnNhY3Rpb24sIHRoaXMsIHBvcywgdGV4dCwgYXR0cmlidXRlcyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMuaW5zZXJ0KGluZGV4LCB0ZXh0LCBhdHRyaWJ1dGVzKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYW4gZW1iZWQgYXQgYSBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byBpbnNlcnQgdGhlIGVtYmVkIGF0LlxuICAgKiBAcGFyYW0ge09iamVjdCB8IEFic3RyYWN0VHlwZTxhbnk+fSBlbWJlZCBUaGUgT2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgZW1iZWQuXG4gICAqIEBwYXJhbSB7VGV4dEF0dHJpYnV0ZXN9IFthdHRyaWJ1dGVzXSBBdHRyaWJ1dGUgaW5mb3JtYXRpb24gdG8gYXBwbHkgb24gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1iZWRcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaW5zZXJ0RW1iZWQgKGluZGV4LCBlbWJlZCwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IHkgPSB0aGlzLmRvYztcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QoeSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBwb3MgPSBmaW5kUG9zaXRpb24odHJhbnNhY3Rpb24sIHRoaXMsIGluZGV4LCAhYXR0cmlidXRlcyk7XG4gICAgICAgIGluc2VydFRleHQodHJhbnNhY3Rpb24sIHRoaXMsIHBvcywgZW1iZWQsIGF0dHJpYnV0ZXMgfHwge30pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLmluc2VydEVtYmVkKGluZGV4LCBlbWJlZCwgYXR0cmlidXRlcyB8fCB7fSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRleHQgc3RhcnRpbmcgZnJvbSBhbiBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IGRlbGV0aW5nLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byByZW1vdmUuIERlZmF1bHRzIHRvIDEuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGRlbGV0ZSAoaW5kZXgsIGxlbmd0aCkge1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCB5ID0gdGhpcy5kb2M7XG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHksIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgZGVsZXRlVGV4dCh0cmFuc2FjdGlvbiwgZmluZFBvc2l0aW9uKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCwgdHJ1ZSksIGxlbmd0aCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMuZGVsZXRlKGluZGV4LCBsZW5ndGgpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXNzaWducyBwcm9wZXJ0aWVzIHRvIGEgcmFuZ2Ugb2YgdGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBwb3NpdGlvbiB3aGVyZSB0byBzdGFydCBmb3JtYXR0aW5nLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoIFRoZSBhbW91bnQgb2YgY2hhcmFjdGVycyB0byBhc3NpZ24gcHJvcGVydGllcyB0by5cbiAgICogQHBhcmFtIHtUZXh0QXR0cmlidXRlc30gYXR0cmlidXRlcyBBdHRyaWJ1dGUgaW5mb3JtYXRpb24gdG8gYXBwbHkgb24gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZm9ybWF0IChpbmRleCwgbGVuZ3RoLCBhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHkgPSB0aGlzLmRvYztcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QoeSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBwb3MgPSBmaW5kUG9zaXRpb24odHJhbnNhY3Rpb24sIHRoaXMsIGluZGV4LCBmYWxzZSk7XG4gICAgICAgIGlmIChwb3MucmlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBmb3JtYXRUZXh0KHRyYW5zYWN0aW9uLCB0aGlzLCBwb3MsIGxlbmd0aCwgYXR0cmlidXRlcyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMuZm9ybWF0KGluZGV4LCBsZW5ndGgsIGF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBub3RlIFhtbC1UZXh0IG5vZGVzIGRvbid0IGhhdmUgYXR0cmlidXRlcy4gWW91IGNhbiB1c2UgdGhpcyBmZWF0dXJlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzIHRvIGNvbXBsZXRlIHRleHQtYmxvY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpcyB0byBiZSByZW1vdmVkLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW1vdmVBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBEZWxldGUodHJhbnNhY3Rpb24sIHRoaXMsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgb3IgdXBkYXRlcyBhbiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBub3RlIFhtbC1UZXh0IG5vZGVzIGRvbid0IGhhdmUgYXR0cmlidXRlcy4gWW91IGNhbiB1c2UgdGhpcyBmZWF0dXJlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzIHRvIGNvbXBsZXRlIHRleHQtYmxvY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpcyB0byBiZSBzZXQuXG4gICAqIEBwYXJhbSB7YW55fSBhdHRyaWJ1dGVWYWx1ZSBUaGUgYXR0cmlidXRlIHZhbHVlIHRoYXQgaXMgdG8gYmUgc2V0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBzZXRBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwU2V0KHRyYW5zYWN0aW9uLCB0aGlzLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXR0cmlidXRlIHZhbHVlIHRoYXQgYmVsb25ncyB0byB0aGUgYXR0cmlidXRlIG5hbWUuXG4gICAqXG4gICAqIEBub3RlIFhtbC1UZXh0IG5vZGVzIGRvbid0IGhhdmUgYXR0cmlidXRlcy4gWW91IGNhbiB1c2UgdGhpcyBmZWF0dXJlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzIHRvIGNvbXBsZXRlIHRleHQtYmxvY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpZGVudGlmaWVzIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyaWVkIHZhbHVlLlxuICAgKiBAcmV0dXJuIHthbnl9IFRoZSBxdWVyaWVkIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0QXR0cmlidXRlIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAodHlwZU1hcEdldCh0aGlzLCBhdHRyaWJ1dGVOYW1lKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBpbiBhIEpTT04gT2JqZWN0LlxuICAgKlxuICAgKiBAbm90ZSBYbWwtVGV4dCBub2RlcyBkb24ndCBoYXZlIGF0dHJpYnV0ZXMuIFlvdSBjYW4gdXNlIHRoaXMgZmVhdHVyZSB0byBhc3NpZ24gcHJvcGVydGllcyB0byBjb21wbGV0ZSB0ZXh0LWJsb2Nrcy5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0PHN0cmluZywgYW55Pn0gQSBKU09OIE9iamVjdCB0aGF0IGRlc2NyaWJlcyB0aGUgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0QXR0cmlidXRlcyAoKSB7XG4gICAgcmV0dXJuIHR5cGVNYXBHZXRBbGwodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWVRleHRSZWZJRCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gX2RlY29kZXJcbiAqIEByZXR1cm4ge1lUZXh0fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFlUZXh0ID0gX2RlY29kZXIgPT4gbmV3IFlUZXh0KCk7XG5cbi8qKlxuICogQG1vZHVsZSBZWG1sXG4gKi9cblxuXG4vKipcbiAqIERlZmluZSB0aGUgZWxlbWVudHMgdG8gd2hpY2ggYSBzZXQgb2YgQ1NTIHF1ZXJpZXMgYXBwbHkuXG4gKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NTU19TZWxlY3RvcnN8Q1NTX1NlbGVjdG9yc31cbiAqXG4gKiBAZXhhbXBsZVxuICogICBxdWVyeSA9ICcuY2xhc3NTZWxlY3RvcidcbiAqICAgcXVlcnkgPSAnbm9kZVNlbGVjdG9yJ1xuICogICBxdWVyeSA9ICcjaWRTZWxlY3RvcidcbiAqXG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBDU1NfU2VsZWN0b3JcbiAqL1xuXG4vKipcbiAqIERvbSBmaWx0ZXIgZnVuY3Rpb24uXG4gKlxuICogQGNhbGxiYWNrIGRvbUZpbHRlclxuICogQHBhcmFtIHtzdHJpbmd9IG5vZGVOYW1lIFRoZSBub2RlTmFtZSBvZiB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtNYXB9IGF0dHJpYnV0ZXMgVGhlIG1hcCBvZiBhdHRyaWJ1dGVzLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0byBpbmNsdWRlIHRoZSBEb20gbm9kZSBpbiB0aGUgWVhtbEVsZW1lbnQuXG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc3Vic2V0IG9mIHRoZSBub2RlcyBvZiBhIFlYbWxFbGVtZW50IC8gWVhtbEZyYWdtZW50IGFuZCBhXG4gKiBwb3NpdGlvbiB3aXRoaW4gdGhlbS5cbiAqXG4gKiBDYW4gYmUgY3JlYXRlZCB3aXRoIHtAbGluayBZWG1sRnJhZ21lbnQjY3JlYXRlVHJlZVdhbGtlcn1cbiAqXG4gKiBAcHVibGljXG4gKiBAaW1wbGVtZW50cyB7SXRlcmFibGU8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEVsZW1lbnR8WVhtbEhvb2s+fVxuICovXG5jbGFzcyBZWG1sVHJlZVdhbGtlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1lYbWxGcmFnbWVudCB8IFlYbWxFbGVtZW50fSByb290XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oQWJzdHJhY3RUeXBlPGFueT4pOmJvb2xlYW59IFtmXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHJvb3QsIGYgPSAoKSA9PiB0cnVlKSB7XG4gICAgdGhpcy5fZmlsdGVyID0gZjtcbiAgICB0aGlzLl9yb290ID0gcm9vdDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SXRlbX1cbiAgICAgKi9cbiAgICB0aGlzLl9jdXJyZW50Tm9kZSA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKHJvb3QuX3N0YXJ0KTtcbiAgICB0aGlzLl9maXJzdENhbGwgPSB0cnVlO1xuICAgIHJvb3QuZG9jID8/IHdhcm5QcmVtYXR1cmVBY2Nlc3MoKTtcbiAgfVxuXG4gIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV4dCBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtJdGVyYXRvclJlc3VsdDxZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sSG9vaz59IFRoZSBuZXh0IG5vZGUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG5leHQgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICovXG4gICAgbGV0IG4gPSB0aGlzLl9jdXJyZW50Tm9kZTtcbiAgICBsZXQgdHlwZSA9IG4gJiYgbi5jb250ZW50ICYmIC8qKiBAdHlwZSB7YW55fSAqLyAobi5jb250ZW50KS50eXBlO1xuICAgIGlmIChuICE9PSBudWxsICYmICghdGhpcy5fZmlyc3RDYWxsIHx8IG4uZGVsZXRlZCB8fCAhdGhpcy5fZmlsdGVyKHR5cGUpKSkgeyAvLyBpZiBmaXJzdCBjYWxsLCB3ZSBjaGVjayBpZiB3ZSBjYW4gdXNlIHRoZSBmaXJzdCBpdGVtXG4gICAgICBkbyB7XG4gICAgICAgIHR5cGUgPSAvKiogQHR5cGUge2FueX0gKi8gKG4uY29udGVudCkudHlwZTtcbiAgICAgICAgaWYgKCFuLmRlbGV0ZWQgJiYgKHR5cGUuY29uc3RydWN0b3IgPT09IFlYbWxFbGVtZW50IHx8IHR5cGUuY29uc3RydWN0b3IgPT09IFlYbWxGcmFnbWVudCkgJiYgdHlwZS5fc3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyB3YWxrIGRvd24gaW4gdGhlIHRyZWVcbiAgICAgICAgICBuID0gdHlwZS5fc3RhcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gd2FsayByaWdodCBvciB1cCBpbiB0aGUgdHJlZVxuICAgICAgICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlIHtJdGVtIHwgbnVsbH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3Qgbnh0ID0gbi5uZXh0O1xuICAgICAgICAgICAgaWYgKG54dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBuID0gbnh0O1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuLnBhcmVudCA9PT0gdGhpcy5fcm9vdCkge1xuICAgICAgICAgICAgICBuID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG4gPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAobi5wYXJlbnQpLl9pdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAobiAhPT0gbnVsbCAmJiAobi5kZWxldGVkIHx8ICF0aGlzLl9maWx0ZXIoLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKG4uY29udGVudCkudHlwZSkpKVxuICAgIH1cbiAgICB0aGlzLl9maXJzdENhbGwgPSBmYWxzZTtcbiAgICBpZiAobiA9PT0gbnVsbCkge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9XG4gICAgfVxuICAgIHRoaXMuX2N1cnJlbnROb2RlID0gbjtcbiAgICByZXR1cm4geyB2YWx1ZTogLyoqIEB0eXBlIHthbnl9ICovIChuLmNvbnRlbnQpLnR5cGUsIGRvbmU6IGZhbHNlIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBsaXN0IG9mIHtAbGluayBZWG1sRWxlbWVudH0uYW5kIHtAbGluayBZWG1sVGV4dH0gdHlwZXMuXG4gKiBBIFl4bWxGcmFnbWVudCBpcyBzaW1pbGFyIHRvIGEge0BsaW5rIFlYbWxFbGVtZW50fSwgYnV0IGl0IGRvZXMgbm90IGhhdmUgYVxuICogbm9kZU5hbWUgYW5kIGl0IGRvZXMgbm90IGhhdmUgYXR0cmlidXRlcy4gVGhvdWdoIGl0IGNhbiBiZSBib3VuZCB0byBhIERPTVxuICogZWxlbWVudCAtIGluIHRoaXMgY2FzZSB0aGUgYXR0cmlidXRlcyBhbmQgdGhlIG5vZGVOYW1lIGFyZSBub3Qgc2hhcmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleHRlbmRzIEFic3RyYWN0VHlwZTxZWG1sRXZlbnQ+XG4gKi9cbmNsYXNzIFlYbWxGcmFnbWVudCBleHRlbmRzIEFic3RyYWN0VHlwZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxhbnk+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fcHJlbGltQ29udGVudCA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dHxudWxsfVxuICAgKi9cbiAgZ2V0IGZpcnN0Q2hpbGQgKCkge1xuICAgIGNvbnN0IGZpcnN0ID0gdGhpcy5fZmlyc3Q7XG4gICAgcmV0dXJuIGZpcnN0ID8gZmlyc3QuY29udGVudC5nZXRDb250ZW50KClbMF0gOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogSW50ZWdyYXRlIHRoaXMgdHlwZSBpbnRvIHRoZSBZanMgaW5zdGFuY2UuXG4gICAqXG4gICAqICogU2F2ZSB0aGlzIHN0cnVjdCBpbiB0aGUgb3NcbiAgICogKiBUaGlzIHR5cGUgaXMgc2VudCB0byBvdGhlciBjbGllbnRcbiAgICogKiBPYnNlcnZlciBmdW5jdGlvbnMgYXJlIGZpcmVkXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jfSB5IFRoZSBZanMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBfaW50ZWdyYXRlICh5LCBpdGVtKSB7XG4gICAgc3VwZXIuX2ludGVncmF0ZSh5LCBpdGVtKTtcbiAgICB0aGlzLmluc2VydCgwLCAvKiogQHR5cGUge0FycmF5PGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KSk7XG4gICAgdGhpcy5fcHJlbGltQ29udGVudCA9IG51bGw7XG4gIH1cblxuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZWG1sRnJhZ21lbnQoKVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIGEgY29weSBvZiB0aGlzIGRhdGEgdHlwZSB0aGF0IGNhbiBiZSBpbmNsdWRlZCBzb21ld2hlcmUgZWxzZS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBjb250ZW50IGlzIG9ubHkgcmVhZGFibGUgX2FmdGVyXyBpdCBoYXMgYmVlbiBpbmNsdWRlZCBzb21ld2hlcmUgaW4gdGhlIFlkb2MuXG4gICAqXG4gICAqIEByZXR1cm4ge1lYbWxGcmFnbWVudH1cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICBjb25zdCBlbCA9IG5ldyBZWG1sRnJhZ21lbnQoKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZWwuaW5zZXJ0KDAsIHRoaXMudG9BcnJheSgpLm1hcChpdGVtID0+IGl0ZW0gaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUgPyBpdGVtLmNsb25lKCkgOiBpdGVtKSk7XG4gICAgcmV0dXJuIGVsXG4gIH1cblxuICBnZXQgbGVuZ3RoICgpIHtcbiAgICB0aGlzLmRvYyA/PyB3YXJuUHJlbWF0dXJlQWNjZXNzKCk7XG4gICAgcmV0dXJuIHRoaXMuX3ByZWxpbUNvbnRlbnQgPT09IG51bGwgPyB0aGlzLl9sZW5ndGggOiB0aGlzLl9wcmVsaW1Db250ZW50Lmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHN1YnRyZWUgb2YgY2hpbGROb2Rlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgd2Fsa2VyID0gZWxlbS5jcmVhdGVUcmVlV2Fsa2VyKGRvbSA9PiBkb20ubm9kZU5hbWUgPT09ICdkaXYnKVxuICAgKiBmb3IgKGxldCBub2RlIGluIHdhbGtlcikge1xuICAgKiAgIC8vIGBub2RlYCBpcyBhIGRpdiBub2RlXG4gICAqICAgbm9wKG5vZGUpXG4gICAqIH1cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihBYnN0cmFjdFR5cGU8YW55Pik6Ym9vbGVhbn0gZmlsdGVyIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uIGVhY2ggY2hpbGQgZWxlbWVudCBhbmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybnMgYSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY2hpbGRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBzdWJ0cmVlLlxuICAgKiBAcmV0dXJuIHtZWG1sVHJlZVdhbGtlcn0gQSBzdWJ0cmVlIGFuZCBhIHBvc2l0aW9uIHdpdGhpbiBpdC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY3JlYXRlVHJlZVdhbGtlciAoZmlsdGVyKSB7XG4gICAgcmV0dXJuIG5ldyBZWG1sVHJlZVdhbGtlcih0aGlzLCBmaWx0ZXIpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgWVhtbEVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBxdWVyeS5cbiAgICogU2ltaWxhciB0byBET00ncyB7QGxpbmsgcXVlcnlTZWxlY3Rvcn0uXG4gICAqXG4gICAqIFF1ZXJ5IHN1cHBvcnQ6XG4gICAqICAgLSB0YWduYW1lXG4gICAqIFRPRE86XG4gICAqICAgLSBpZFxuICAgKiAgIC0gYXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Q1NTX1NlbGVjdG9yfSBxdWVyeSBUaGUgcXVlcnkgb24gdGhlIGNoaWxkcmVuLlxuICAgKiBAcmV0dXJuIHtZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sSG9va3xudWxsfSBUaGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHF1ZXJ5IG9yIG51bGwuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHF1ZXJ5U2VsZWN0b3IgKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBxdWVyeS50b1VwcGVyQ2FzZSgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBpdGVyYXRvciA9IG5ldyBZWG1sVHJlZVdhbGtlcih0aGlzLCBlbGVtZW50ID0+IGVsZW1lbnQubm9kZU5hbWUgJiYgZWxlbWVudC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBxdWVyeSk7XG4gICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV4dC52YWx1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBZWG1sRWxlbWVudHMgdGhhdCBtYXRjaCB0aGUgcXVlcnkuXG4gICAqIFNpbWlsYXIgdG8gRG9tJ3Mge0BsaW5rIHF1ZXJ5U2VsZWN0b3JBbGx9LlxuICAgKlxuICAgKiBAdG9kbyBEb2VzIG5vdCB5ZXQgc3VwcG9ydCBhbGwgcXVlcmllcy4gQ3VycmVudGx5IG9ubHkgcXVlcnkgYnkgdGFnTmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtDU1NfU2VsZWN0b3J9IHF1ZXJ5IFRoZSBxdWVyeSBvbiB0aGUgY2hpbGRyZW5cbiAgICogQHJldHVybiB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEhvb2t8bnVsbD59IFRoZSBlbGVtZW50cyB0aGF0IG1hdGNoIHRoaXMgcXVlcnkuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHF1ZXJ5U2VsZWN0b3JBbGwgKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBxdWVyeS50b1VwcGVyQ2FzZSgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gYXJyYXkuZnJvbShuZXcgWVhtbFRyZWVXYWxrZXIodGhpcywgZWxlbWVudCA9PiBlbGVtZW50Lm5vZGVOYW1lICYmIGVsZW1lbnQubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gcXVlcnkpKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgWVhtbEV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PG51bGx8c3RyaW5nPn0gcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgcGFyZW50U3Vicykge1xuICAgIGNhbGxUeXBlT2JzZXJ2ZXJzKHRoaXMsIHRyYW5zYWN0aW9uLCBuZXcgWVhtbEV2ZW50KHRoaXMsIHBhcmVudFN1YnMsIHRyYW5zYWN0aW9uKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYWxsIHRoZSBjaGlsZHJlbiBvZiB0aGlzIFlYbWxGcmFnbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFsbCBjaGlsZHJlbi5cbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RNYXAodGhpcywgeG1sID0+IHhtbC50b1N0cmluZygpKS5qb2luKCcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBEb20gRWxlbWVudCB0aGF0IG1pcnJvcnMgdGhpcyBZWG1sRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gW19kb2N1bWVudD1kb2N1bWVudF0gVGhlIGRvY3VtZW50IG9iamVjdCAoeW91IG11c3QgZGVmaW5lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgd2hlbiBjYWxsaW5nIHRoaXMgbWV0aG9kIGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVqcylcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBbaG9va3M9e31dIE9wdGlvbmFsIHByb3BlcnR5IHRvIGN1c3RvbWl6ZSBob3cgaG9va3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgcHJlc2VudGVkIGluIHRoZSBET01cbiAgICogQHBhcmFtIHthbnl9IFtiaW5kaW5nXSBZb3Ugc2hvdWxkIG5vdCBzZXQgdGhpcyBwcm9wZXJ0eS4gVGhpcyBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIGlmIERvbUJpbmRpbmcgd2FudHMgdG8gY3JlYXRlIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb24gdG8gdGhlIGNyZWF0ZWQgRE9NIHR5cGUuXG4gICAqIEByZXR1cm4ge05vZGV9IFRoZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnR8RG9tIEVsZW1lbnR9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvRE9NIChfZG9jdW1lbnQgPSBkb2N1bWVudCwgaG9va3MgPSB7fSwgYmluZGluZykge1xuICAgIGNvbnN0IGZyYWdtZW50ID0gX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBpZiAoYmluZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiaW5kaW5nLl9jcmVhdGVBc3NvY2lhdGlvbihmcmFnbWVudCwgdGhpcyk7XG4gICAgfVxuICAgIHR5cGVMaXN0Rm9yRWFjaCh0aGlzLCB4bWxUeXBlID0+IHtcbiAgICAgIGZyYWdtZW50Lmluc2VydEJlZm9yZSh4bWxUeXBlLnRvRE9NKF9kb2N1bWVudCwgaG9va3MsIGJpbmRpbmcpLCBudWxsKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnJhZ21lbnRcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIG5ldyBjb250ZW50IGF0IGFuIGluZGV4LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gSW5zZXJ0IGNoYXJhY3RlciAnYScgYXQgcG9zaXRpb24gMFxuICAgKiAgeG1sLmluc2VydCgwLCBbbmV3IFkuWG1sVGV4dCgndGV4dCcpXSlcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byBpbnNlcnQgY29udGVudCBhdFxuICAgKiBAcGFyYW0ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn0gY29udGVudCBUaGUgYXJyYXkgb2YgY29udGVudFxuICAgKi9cbiAgaW5zZXJ0IChpbmRleCwgY29udGVudCkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZUxpc3RJbnNlcnRHZW5lcmljcyh0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsIGNvbnRlbnQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgX3ByZWxpbUNvbnRlbnQgaXMgZGVmaW5lZCBiZWNhdXNlIHRoaXMgaXMgbm90IHlldCBpbnRlZ3JhdGVkXG4gICAgICB0aGlzLl9wcmVsaW1Db250ZW50LnNwbGljZShpbmRleCwgMCwgLi4uY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgbmV3IGNvbnRlbnQgYXQgYW4gaW5kZXguXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBJbnNlcnQgY2hhcmFjdGVyICdhJyBhdCBwb3NpdGlvbiAwXG4gICAqICB4bWwuaW5zZXJ0KDAsIFtuZXcgWS5YbWxUZXh0KCd0ZXh0JyldKVxuICAgKlxuICAgKiBAcGFyYW0ge251bGx8SXRlbXxZWG1sRWxlbWVudHxZWG1sVGV4dH0gcmVmIFRoZSBpbmRleCB0byBpbnNlcnQgY29udGVudCBhdFxuICAgKiBAcGFyYW0ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn0gY29udGVudCBUaGUgYXJyYXkgb2YgY29udGVudFxuICAgKi9cbiAgaW5zZXJ0QWZ0ZXIgKHJlZiwgY29udGVudCkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgcmVmSXRlbSA9IChyZWYgJiYgcmVmIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlKSA/IHJlZi5faXRlbSA6IHJlZjtcbiAgICAgICAgdHlwZUxpc3RJbnNlcnRHZW5lcmljc0FmdGVyKHRyYW5zYWN0aW9uLCB0aGlzLCByZWZJdGVtLCBjb250ZW50KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwYyA9IC8qKiBAdHlwZSB7QXJyYXk8YW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpO1xuICAgICAgY29uc3QgaW5kZXggPSByZWYgPT09IG51bGwgPyAwIDogcGMuZmluZEluZGV4KGVsID0+IGVsID09PSByZWYpICsgMTtcbiAgICAgIGlmIChpbmRleCA9PT0gMCAmJiByZWYgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgZXJyb3IuY3JlYXRlKCdSZWZlcmVuY2UgaXRlbSBub3QgZm91bmQnKVxuICAgICAgfVxuICAgICAgcGMuc3BsaWNlKGluZGV4LCAwLCAuLi5jb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBlbGVtZW50cyBzdGFydGluZyBmcm9tIGFuIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgZGVsZXRpbmcgZWxlbWVudHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZW1vdmUuIERlZmF1bHRzIHRvIDEuXG4gICAqL1xuICBkZWxldGUgKGluZGV4LCBsZW5ndGggPSAxKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTGlzdERlbGV0ZSh0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQHRzLWlnbm9yZSBfcHJlbGltQ29udGVudCBpcyBkZWZpbmVkIGJlY2F1c2UgdGhpcyBpcyBub3QgeWV0IGludGVncmF0ZWRcbiAgICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQuc3BsaWNlKGluZGV4LCBsZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoaXMgWUFycmF5IHRvIGEgSmF2YVNjcmlwdCBBcnJheS5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEhvb2s+fVxuICAgKi9cbiAgdG9BcnJheSAoKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0VG9BcnJheSh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgY29udGVudCB0byB0aGlzIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxZWG1sRWxlbWVudHxZWG1sVGV4dD59IGNvbnRlbnQgQXJyYXkgb2YgY29udGVudCB0byBhcHBlbmQuXG4gICAqL1xuICBwdXNoIChjb250ZW50KSB7XG4gICAgdGhpcy5pbnNlcnQodGhpcy5sZW5ndGgsIGNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXBlbmRzIGNvbnRlbnQgdG8gdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHQ+fSBjb250ZW50IEFycmF5IG9mIGNvbnRlbnQgdG8gcHJlcGVuZC5cbiAgICovXG4gIHVuc2hpZnQgKGNvbnRlbnQpIHtcbiAgICB0aGlzLmluc2VydCgwLCBjb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpLXRoIGVsZW1lbnQgZnJvbSBhIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4gZnJvbSB0aGUgWUFycmF5XG4gICAqIEByZXR1cm4ge1lYbWxFbGVtZW50fFlYbWxUZXh0fVxuICAgKi9cbiAgZ2V0IChpbmRleCkge1xuICAgIHJldHVybiB0eXBlTGlzdEdldCh0aGlzLCBpbmRleClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcG9ydGlvbiBvZiB0aGlzIFlYbWxGcmFnbWVudCBpbnRvIGEgSmF2YVNjcmlwdCBBcnJheSBzZWxlY3RlZFxuICAgKiBmcm9tIHN0YXJ0IHRvIGVuZCAoZW5kIG5vdCBpbmNsdWRlZCkuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnRdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXVxuICAgKiBAcmV0dXJuIHtBcnJheTxZWG1sRWxlbWVudHxZWG1sVGV4dD59XG4gICAqL1xuICBzbGljZSAoc3RhcnQgPSAwLCBlbmQgPSB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiB0eXBlTGlzdFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbiBvbmNlIG9uIGV2ZXJ5IGNoaWxkIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oWVhtbEVsZW1lbnR8WVhtbFRleHQsbnVtYmVyLCB0eXBlb2Ygc2VsZik6dm9pZH0gZiBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZXZlcnkgZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAgICovXG4gIGZvckVhY2ggKGYpIHtcbiAgICB0eXBlTGlzdEZvckVhY2godGhpcywgZik7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdHlwZSB0byBiaW5hcnkgYW5kIHdyaXRlIGl0IHRvIGFuXG4gICAqIEJpbmFyeUVuY29kZXIuXG4gICAqXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhpcyBJdGVtIGlzIHNlbnQgdG8gYSByZW1vdGUgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXIgVGhlIGVuY29kZXIgdG8gd3JpdGUgZGF0YSB0by5cbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlYbWxGcmFnbWVudFJlZklEKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBfZGVjb2RlclxuICogQHJldHVybiB7WVhtbEZyYWdtZW50fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFlYbWxGcmFnbWVudCA9IF9kZWNvZGVyID0+IG5ldyBZWG1sRnJhZ21lbnQoKTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fG51bWJlcnxudWxsfEFycmF5PGFueT58c3RyaW5nfFVpbnQ4QXJyYXl8QWJzdHJhY3RUeXBlPGFueT59IFZhbHVlVHlwZXNcbiAqL1xuXG4vKipcbiAqIEFuIFlYbWxFbGVtZW50IGltaXRhdGVzIHRoZSBiZWhhdmlvciBvZiBhXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudFxuICpcbiAqICogQW4gWVhtbEVsZW1lbnQgaGFzIGF0dHJpYnV0ZXMgKGtleSB2YWx1ZSBwYWlycylcbiAqICogQW4gWVhtbEVsZW1lbnQgaGFzIGNoaWxkRWxlbWVudHMgdGhhdCBtdXN0IGluaGVyaXQgZnJvbSBZWG1sRWxlbWVudFxuICpcbiAqIEB0ZW1wbGF0ZSB7eyBba2V5OiBzdHJpbmddOiBWYWx1ZVR5cGVzIH19IFtLVj17IFtrZXk6IHN0cmluZ106IHN0cmluZyB9XVxuICovXG5jbGFzcyBZWG1sRWxlbWVudCBleHRlbmRzIFlYbWxGcmFnbWVudCB7XG4gIGNvbnN0cnVjdG9yIChub2RlTmFtZSA9ICdVTkRFRklORUQnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5vZGVOYW1lID0gbm9kZU5hbWU7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsIGFueT58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl9wcmVsaW1BdHRycyA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8bnVsbH1cbiAgICovXG4gIGdldCBuZXh0U2libGluZyAoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2l0ZW0gPyB0aGlzLl9pdGVtLm5leHQgOiBudWxsO1xuICAgIHJldHVybiBuID8gLyoqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dH0gKi8gKC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGUpIDogbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dHxudWxsfVxuICAgKi9cbiAgZ2V0IHByZXZTaWJsaW5nICgpIHtcbiAgICBjb25zdCBuID0gdGhpcy5faXRlbSA/IHRoaXMuX2l0ZW0ucHJldiA6IG51bGw7XG4gICAgcmV0dXJuIG4gPyAvKiogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fSAqLyAoLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKG4uY29udGVudCkudHlwZSkgOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogSW50ZWdyYXRlIHRoaXMgdHlwZSBpbnRvIHRoZSBZanMgaW5zdGFuY2UuXG4gICAqXG4gICAqICogU2F2ZSB0aGlzIHN0cnVjdCBpbiB0aGUgb3NcbiAgICogKiBUaGlzIHR5cGUgaXMgc2VudCB0byBvdGhlciBjbGllbnRcbiAgICogKiBPYnNlcnZlciBmdW5jdGlvbnMgYXJlIGZpcmVkXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jfSB5IFRoZSBZanMgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBfaW50ZWdyYXRlICh5LCBpdGVtKSB7XG4gICAgc3VwZXIuX2ludGVncmF0ZSh5LCBpdGVtKVxuICAgIDsoLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fSAqLyAodGhpcy5fcHJlbGltQXR0cnMpKS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgICB0aGlzLl9wcmVsaW1BdHRycyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBJdGVtIHdpdGggdGhlIHNhbWUgZWZmZWN0IGFzIHRoaXMgSXRlbSAod2l0aG91dCBwb3NpdGlvbiBlZmZlY3QpXG4gICAqXG4gICAqIEByZXR1cm4ge1lYbWxFbGVtZW50fVxuICAgKi9cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWVhtbEVsZW1lbnQodGhpcy5ub2RlTmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcyBhIGNvcHkgb2YgdGhpcyBkYXRhIHR5cGUgdGhhdCBjYW4gYmUgaW5jbHVkZWQgc29tZXdoZXJlIGVsc2UuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgY29udGVudCBpcyBvbmx5IHJlYWRhYmxlIF9hZnRlcl8gaXQgaGFzIGJlZW4gaW5jbHVkZWQgc29tZXdoZXJlIGluIHRoZSBZZG9jLlxuICAgKlxuICAgKiBAcmV0dXJuIHtZWG1sRWxlbWVudDxLVj59XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1lYbWxFbGVtZW50PEtWPn1cbiAgICAgKi9cbiAgICBjb25zdCBlbCA9IG5ldyBZWG1sRWxlbWVudCh0aGlzLm5vZGVOYW1lKTtcbiAgICBjb25zdCBhdHRycyA9IHRoaXMuZ2V0QXR0cmlidXRlcygpO1xuICAgIG9iamVjdC5mb3JFYWNoKGF0dHJzLCAodmFsdWUsIGtleSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBlbC5pbnNlcnQoMCwgdGhpcy50b0FycmF5KCkubWFwKGl0ZW0gPT4gaXRlbSBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IGl0ZW0uY2xvbmUoKSA6IGl0ZW0pKTtcbiAgICByZXR1cm4gZWxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBYTUwgc2VyaWFsaXphdGlvbiBvZiB0aGlzIFlYbWxFbGVtZW50LlxuICAgKiBUaGUgYXR0cmlidXRlcyBhcmUgb3JkZXJlZCBieSBhdHRyaWJ1dGUtbmFtZSwgc28geW91IGNhbiBlYXNpbHkgdXNlIHRoaXNcbiAgICogbWV0aG9kIHRvIGNvbXBhcmUgWVhtbEVsZW1lbnRzXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHR5cGUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICBjb25zdCBhdHRycyA9IHRoaXMuZ2V0QXR0cmlidXRlcygpO1xuICAgIGNvbnN0IHN0cmluZ0J1aWxkZXIgPSBbXTtcbiAgICBjb25zdCBrZXlzID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cnMpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnNvcnQoKTtcbiAgICBjb25zdCBrZXlzTGVuID0ga2V5cy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzTGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBzdHJpbmdCdWlsZGVyLnB1c2goa2V5ICsgJz1cIicgKyBhdHRyc1trZXldICsgJ1wiJyk7XG4gICAgfVxuICAgIGNvbnN0IG5vZGVOYW1lID0gdGhpcy5ub2RlTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGF0dHJzU3RyaW5nID0gc3RyaW5nQnVpbGRlci5sZW5ndGggPiAwID8gJyAnICsgc3RyaW5nQnVpbGRlci5qb2luKCcgJykgOiAnJztcbiAgICByZXR1cm4gYDwke25vZGVOYW1lfSR7YXR0cnNTdHJpbmd9PiR7c3VwZXIudG9TdHJpbmcoKX08LyR7bm9kZU5hbWV9PmBcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGF0dHJpYnV0ZSBmcm9tIHRoaXMgWVhtbEVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlzIHRvIGJlIHJlbW92ZWQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlbW92ZUF0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZU1hcERlbGV0ZSh0cmFuc2FjdGlvbiwgdGhpcywgYXR0cmlidXRlTmFtZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLGFueT59ICovICh0aGlzLl9wcmVsaW1BdHRycykuZGVsZXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIG9yIHVwZGF0ZXMgYW4gYXR0cmlidXRlLlxuICAgKlxuICAgKiBAdGVtcGxhdGUge2tleW9mIEtWICYgc3RyaW5nfSBLRVlcbiAgICpcbiAgICogQHBhcmFtIHtLRVl9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRoYXQgaXMgdG8gYmUgc2V0LlxuICAgKiBAcGFyYW0ge0tWW0tFWV19IGF0dHJpYnV0ZVZhbHVlIFRoZSBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBpcyB0byBiZSBzZXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNldEF0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBTZXQodHJhbnNhY3Rpb24sIHRoaXMsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsIGFueT59ICovICh0aGlzLl9wcmVsaW1BdHRycykuc2V0KGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBiZWxvbmdzIHRvIHRoZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICpcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBLViAmIHN0cmluZ30gS0VZXG4gICAqXG4gICAqIEBwYXJhbSB7S0VZfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlkZW50aWZpZXMgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJpZWQgdmFsdWUuXG4gICAqIEByZXR1cm4ge0tWW0tFWV18dW5kZWZpbmVkfSBUaGUgcXVlcmllZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEF0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHR5cGVNYXBHZXQodGhpcywgYXR0cmlidXRlTmFtZSkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIGFuIGF0dHJpYnV0ZSBleGlzdHNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZU5hbWUgVGhlIGF0dHJpYnV0ZSBuYW1lIHRvIGNoZWNrIGZvciBleGlzdGVuY2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgdGhlIGF0dHJpYnV0ZSBleGlzdHMuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGhhc0F0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHR5cGVNYXBIYXModGhpcywgYXR0cmlidXRlTmFtZSkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgYXR0cmlidXRlIG5hbWUvdmFsdWUgcGFpcnMgaW4gYSBKU09OIE9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtTbmFwc2hvdH0gW3NuYXBzaG90XVxuICAgKiBAcmV0dXJuIHt7IFtLZXkgaW4gRXh0cmFjdDxrZXlvZiBLVixzdHJpbmc+XT86IEtWW0tleV19fSBBIEpTT04gT2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRBdHRyaWJ1dGVzIChzbmFwc2hvdCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHNuYXBzaG90ID8gdHlwZU1hcEdldEFsbFNuYXBzaG90KHRoaXMsIHNuYXBzaG90KSA6IHR5cGVNYXBHZXRBbGwodGhpcykpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIERvbSBFbGVtZW50IHRoYXQgbWlycm9ycyB0aGlzIFlYbWxFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtob29rcz17fV0gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZS5cbiAgICogQHJldHVybiB7Tm9kZX0gVGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9ET00gKF9kb2N1bWVudCA9IGRvY3VtZW50LCBob29rcyA9IHt9LCBiaW5kaW5nKSB7XG4gICAgY29uc3QgZG9tID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5ub2RlTmFtZSk7XG4gICAgY29uc3QgYXR0cnMgPSB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgICAgY29uc3QgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHlwZUxpc3RGb3JFYWNoKHRoaXMsIHl4bWwgPT4ge1xuICAgICAgZG9tLmFwcGVuZENoaWxkKHl4bWwudG9ET00oX2RvY3VtZW50LCBob29rcywgYmluZGluZykpO1xuICAgIH0pO1xuICAgIGlmIChiaW5kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJpbmRpbmcuX2NyZWF0ZUFzc29jaWF0aW9uKGRvbSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBkb21cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgb2YgdGhpcyB0eXBlIHRvIGJpbmFyeSBhbmQgd3JpdGUgaXQgdG8gYW5cbiAgICogQmluYXJ5RW5jb2Rlci5cbiAgICpcbiAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGlzIEl0ZW0gaXMgc2VudCB0byBhIHJlbW90ZSBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlciBUaGUgZW5jb2RlciB0byB3cml0ZSBkYXRhIHRvLlxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWVhtbEVsZW1lbnRSZWZJRCk7XG4gICAgZW5jb2Rlci53cml0ZUtleSh0aGlzLm5vZGVOYW1lKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtZWG1sRWxlbWVudH1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFlYbWxFbGVtZW50ID0gZGVjb2RlciA9PiBuZXcgWVhtbEVsZW1lbnQoZGVjb2Rlci5yZWFkS2V5KCkpO1xuXG4vKipcbiAqIEBleHRlbmRzIFlFdmVudDxZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sRnJhZ21lbnQ+XG4gKiBBbiBFdmVudCB0aGF0IGRlc2NyaWJlcyBjaGFuZ2VzIG9uIGEgWVhtbCBFbGVtZW50IG9yIFl4bWwgRnJhZ21lbnRcbiAqL1xuY2xhc3MgWVhtbEV2ZW50IGV4dGVuZHMgWUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEZyYWdtZW50fSB0YXJnZXQgVGhlIHRhcmdldCBvbiB3aGljaCB0aGUgZXZlbnQgaXMgY3JlYXRlZC5cbiAgICogQHBhcmFtIHtTZXQ8c3RyaW5nfG51bGw+fSBzdWJzIFRoZSBzZXQgb2YgY2hhbmdlZCBhdHRyaWJ1dGVzLiBgbnVsbGAgaXMgaW5jbHVkZWQgaWYgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgIGNoaWxkIGxpc3QgY2hhbmdlZC5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gVGhlIHRyYW5zYWN0aW9uIGluc3RhbmNlIHdpdGggd2hpY2ggdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZSB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yICh0YXJnZXQsIHN1YnMsIHRyYW5zYWN0aW9uKSB7XG4gICAgc3VwZXIodGFyZ2V0LCB0cmFuc2FjdGlvbik7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY2hpbGRyZW4gY2hhbmdlZC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY2hpbGRMaXN0Q2hhbmdlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFNldCBvZiBhbGwgY2hhbmdlZCBhdHRyaWJ1dGVzLlxuICAgICAqIEB0eXBlIHtTZXQ8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmF0dHJpYnV0ZXNDaGFuZ2VkID0gbmV3IFNldCgpO1xuICAgIHN1YnMuZm9yRWFjaCgoc3ViKSA9PiB7XG4gICAgICBpZiAoc3ViID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY2hpbGRMaXN0Q2hhbmdlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNDaGFuZ2VkLmFkZChzdWIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogWW91IGNhbiBtYW5hZ2UgYmluZGluZyB0byBhIGN1c3RvbSB0eXBlIHdpdGggWVhtbEhvb2suXG4gKlxuICogQGV4dGVuZHMge1lNYXA8YW55Pn1cbiAqL1xuY2xhc3MgWVhtbEhvb2sgZXh0ZW5kcyBZTWFwIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBob29rTmFtZSBub2RlTmFtZSBvZiB0aGUgRG9tIE5vZGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoaG9va05hbWUpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5ob29rTmFtZSA9IGhvb2tOYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gSXRlbSB3aXRoIHRoZSBzYW1lIGVmZmVjdCBhcyB0aGlzIEl0ZW0gKHdpdGhvdXQgcG9zaXRpb24gZWZmZWN0KVxuICAgKi9cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWVhtbEhvb2sodGhpcy5ob29rTmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcyBhIGNvcHkgb2YgdGhpcyBkYXRhIHR5cGUgdGhhdCBjYW4gYmUgaW5jbHVkZWQgc29tZXdoZXJlIGVsc2UuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgY29udGVudCBpcyBvbmx5IHJlYWRhYmxlIF9hZnRlcl8gaXQgaGFzIGJlZW4gaW5jbHVkZWQgc29tZXdoZXJlIGluIHRoZSBZZG9jLlxuICAgKlxuICAgKiBAcmV0dXJuIHtZWG1sSG9va31cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICBjb25zdCBlbCA9IG5ldyBZWG1sSG9vayh0aGlzLmhvb2tOYW1lKTtcbiAgICB0aGlzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGVsLnNldChrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZWxcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgRG9tIEVsZW1lbnQgdGhhdCBtaXJyb3JzIHRoaXMgWVhtbEVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IFtfZG9jdW1lbnQ9ZG9jdW1lbnRdIFRoZSBkb2N1bWVudCBvYmplY3QgKHlvdSBtdXN0IGRlZmluZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlanMpXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsIGFueT59IFtob29rc10gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZVxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBUaGUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50fERvbSBFbGVtZW50fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b0RPTSAoX2RvY3VtZW50ID0gZG9jdW1lbnQsIGhvb2tzID0ge30sIGJpbmRpbmcpIHtcbiAgICBjb25zdCBob29rID0gaG9va3NbdGhpcy5ob29rTmFtZV07XG4gICAgbGV0IGRvbTtcbiAgICBpZiAoaG9vayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkb20gPSBob29rLmNyZWF0ZURvbSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLmhvb2tOYW1lKTtcbiAgICB9XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnZGF0YS15anMtaG9vaycsIHRoaXMuaG9va05hbWUpO1xuICAgIGlmIChiaW5kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJpbmRpbmcuX2NyZWF0ZUFzc29jaWF0aW9uKGRvbSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBkb21cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgb2YgdGhpcyB0eXBlIHRvIGJpbmFyeSBhbmQgd3JpdGUgaXQgdG8gYW5cbiAgICogQmluYXJ5RW5jb2Rlci5cbiAgICpcbiAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGlzIEl0ZW0gaXMgc2VudCB0byBhIHJlbW90ZSBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlciBUaGUgZW5jb2RlciB0byB3cml0ZSBkYXRhIHRvLlxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWVhtbEhvb2tSZWZJRCk7XG4gICAgZW5jb2Rlci53cml0ZUtleSh0aGlzLmhvb2tOYW1lKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtZWG1sSG9va31cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRZWG1sSG9vayA9IGRlY29kZXIgPT5cbiAgbmV3IFlYbWxIb29rKGRlY29kZXIucmVhZEtleSgpKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRleHQgaW4gYSBEb20gRWxlbWVudC4gSW4gdGhlIGZ1dHVyZSB0aGlzIHR5cGUgd2lsbCBhbHNvIGhhbmRsZVxuICogc2ltcGxlIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24gbGlrZSBib2xkIGFuZCBpdGFsaWMuXG4gKi9cbmNsYXNzIFlYbWxUZXh0IGV4dGVuZHMgWVRleHQge1xuICAvKipcbiAgICogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fG51bGx9XG4gICAqL1xuICBnZXQgbmV4dFNpYmxpbmcgKCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9pdGVtID8gdGhpcy5faXRlbS5uZXh0IDogbnVsbDtcbiAgICByZXR1cm4gbiA/IC8qKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR9ICovICgvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAobi5jb250ZW50KS50eXBlKSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8bnVsbH1cbiAgICovXG4gIGdldCBwcmV2U2libGluZyAoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2l0ZW0gPyB0aGlzLl9pdGVtLnByZXYgOiBudWxsO1xuICAgIHJldHVybiBuID8gLyoqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dH0gKi8gKC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGUpIDogbnVsbFxuICB9XG5cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWVhtbFRleHQoKVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIGEgY29weSBvZiB0aGlzIGRhdGEgdHlwZSB0aGF0IGNhbiBiZSBpbmNsdWRlZCBzb21ld2hlcmUgZWxzZS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBjb250ZW50IGlzIG9ubHkgcmVhZGFibGUgX2FmdGVyXyBpdCBoYXMgYmVlbiBpbmNsdWRlZCBzb21ld2hlcmUgaW4gdGhlIFlkb2MuXG4gICAqXG4gICAqIEByZXR1cm4ge1lYbWxUZXh0fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGNvbnN0IHRleHQgPSBuZXcgWVhtbFRleHQoKTtcbiAgICB0ZXh0LmFwcGx5RGVsdGEodGhpcy50b0RlbHRhKCkpO1xuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIERvbSBFbGVtZW50IHRoYXQgbWlycm9ycyB0aGlzIFlYbWxUZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtob29rc10gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZS5cbiAgICogQHJldHVybiB7VGV4dH0gVGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9ET00gKF9kb2N1bWVudCA9IGRvY3VtZW50LCBob29rcywgYmluZGluZykge1xuICAgIGNvbnN0IGRvbSA9IF9kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRvU3RyaW5nKCkpO1xuICAgIGlmIChiaW5kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJpbmRpbmcuX2NyZWF0ZUFzc29jaWF0aW9uKGRvbSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBkb21cbiAgfVxuXG4gIHRvU3RyaW5nICgpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHRoaXMudG9EZWx0YSgpLm1hcChkZWx0YSA9PiB7XG4gICAgICBjb25zdCBuZXN0ZWROb2RlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBub2RlTmFtZSBpbiBkZWx0YS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnN0IGF0dHJzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRlbHRhLmF0dHJpYnV0ZXNbbm9kZU5hbWVdKSB7XG4gICAgICAgICAgYXR0cnMucHVzaCh7IGtleSwgdmFsdWU6IGRlbHRhLmF0dHJpYnV0ZXNbbm9kZU5hbWVdW2tleV0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc29ydCBhdHRyaWJ1dGVzIHRvIGdldCBhIHVuaXF1ZSBvcmRlclxuICAgICAgICBhdHRycy5zb3J0KChhLCBiKSA9PiBhLmtleSA8IGIua2V5ID8gLTEgOiAxKTtcbiAgICAgICAgbmVzdGVkTm9kZXMucHVzaCh7IG5vZGVOYW1lLCBhdHRycyB9KTtcbiAgICAgIH1cbiAgICAgIC8vIHNvcnQgbm9kZSBvcmRlciB0byBnZXQgYSB1bmlxdWUgb3JkZXJcbiAgICAgIG5lc3RlZE5vZGVzLnNvcnQoKGEsIGIpID0+IGEubm9kZU5hbWUgPCBiLm5vZGVOYW1lID8gLTEgOiAxKTtcbiAgICAgIC8vIG5vdyBjb252ZXJ0IHRvIGRvbSBzdHJpbmdcbiAgICAgIGxldCBzdHIgPSAnJztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmVzdGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5lc3RlZE5vZGVzW2ldO1xuICAgICAgICBzdHIgKz0gYDwke25vZGUubm9kZU5hbWV9YDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBub2RlLmF0dHJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgYXR0ciA9IG5vZGUuYXR0cnNbal07XG4gICAgICAgICAgc3RyICs9IGAgJHthdHRyLmtleX09XCIke2F0dHIudmFsdWV9XCJgO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSAnPic7XG4gICAgICB9XG4gICAgICBzdHIgKz0gZGVsdGEuaW5zZXJ0O1xuICAgICAgZm9yIChsZXQgaSA9IG5lc3RlZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHN0ciArPSBgPC8ke25lc3RlZE5vZGVzW2ldLm5vZGVOYW1lfT5gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0clxuICAgIH0pLmpvaW4oJycpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlYbWxUZXh0UmVmSUQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1lYbWxUZXh0fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFlYbWxUZXh0ID0gZGVjb2RlciA9PiBuZXcgWVhtbFRleHQoKTtcblxuY2xhc3MgQWJzdHJhY3RTdHJ1Y3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGlkLCBsZW5ndGgpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgZGVsZXRlZCAoKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgdGhpcyBzdHJ1Y3Qgd2l0aCB0aGUgaXRlbSB0byB0aGUgcmlnaHQuXG4gICAqIFRoaXMgbWV0aG9kIGlzIGFscmVhZHkgYXNzdW1pbmcgdGhhdCBgdGhpcy5pZC5jbG9jayArIHRoaXMubGVuZ3RoID09PSB0aGlzLmlkLmNsb2NrYC5cbiAgICogQWxzbyB0aGlzIG1ldGhvZCBkb2VzICpub3QqIHJlbW92ZSByaWdodCBmcm9tIFN0cnVjdFN0b3JlIVxuICAgKiBAcGFyYW0ge0Fic3RyYWN0U3RydWN0fSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHRoaXMgbWVyZ2VkIHdpdGggcmlnaHRcbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlciBUaGUgZW5jb2RlciB0byB3cml0ZSBkYXRhIHRvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBlbmNvZGluZ1JlZlxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCwgZW5jb2RpbmdSZWYpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBvZmZzZXQpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxufVxuXG5jb25zdCBzdHJ1Y3RHQ1JlZk51bWJlciA9IDA7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgR0MgZXh0ZW5kcyBBYnN0cmFjdFN0cnVjdCB7XG4gIGdldCBkZWxldGVkICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZGVsZXRlICgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7R0N9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgIT09IHJpZ2h0LmNvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgdGhpcy5sZW5ndGggKz0gcmlnaHQubGVuZ3RoO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgIHRoaXMuaWQuY2xvY2sgKz0gb2Zmc2V0O1xuICAgICAgdGhpcy5sZW5ndGggLT0gb2Zmc2V0O1xuICAgIH1cbiAgICBhZGRTdHJ1Y3QodHJhbnNhY3Rpb24uZG9jLnN0b3JlLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUluZm8oc3RydWN0R0NSZWZOdW1iZXIpO1xuICAgIGVuY29kZXIud3JpdGVMZW4odGhpcy5sZW5ndGggLSBvZmZzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqIEByZXR1cm4ge251bGwgfCBudW1iZXJ9XG4gICAqL1xuICBnZXRNaXNzaW5nICh0cmFuc2FjdGlvbiwgc3RvcmUpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmNsYXNzIENvbnRlbnRCaW5hcnkge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBjb250ZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvciAoY29udGVudCkge1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gW3RoaXMuY29udGVudF1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudEJpbmFyeX1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudEJpbmFyeSh0aGlzLmNvbnRlbnQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50QmluYXJ5fVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRCaW5hcnl9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVCdWYodGhpcy5jb250ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiAzXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMiB9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnRCaW5hcnl9XG4gKi9cbmNvbnN0IHJlYWRDb250ZW50QmluYXJ5ID0gZGVjb2RlciA9PiBuZXcgQ29udGVudEJpbmFyeShkZWNvZGVyLnJlYWRCdWYoKSk7XG5cbmNsYXNzIENvbnRlbnREZWxldGVkIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChsZW4pIHtcbiAgICB0aGlzLmxlbiA9IGxlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLmxlblxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnREZWxldGVkfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50RGVsZXRlZCh0aGlzLmxlbilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnREZWxldGVkfVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICBjb25zdCByaWdodCA9IG5ldyBDb250ZW50RGVsZXRlZCh0aGlzLmxlbiAtIG9mZnNldCk7XG4gICAgdGhpcy5sZW4gPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHJpZ2h0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50RGVsZXRlZH0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICB0aGlzLmxlbiArPSByaWdodC5sZW47XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHtcbiAgICBhZGRUb0RlbGV0ZVNldCh0cmFuc2FjdGlvbi5kZWxldGVTZXQsIGl0ZW0uaWQuY2xpZW50LCBpdGVtLmlkLmNsb2NrLCB0aGlzLmxlbik7XG4gICAgaXRlbS5tYXJrRGVsZXRlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlTGVuKHRoaXMubGVuIC0gb2Zmc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiAxXG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyIH0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudERlbGV0ZWR9XG4gKi9cbmNvbnN0IHJlYWRDb250ZW50RGVsZXRlZCA9IGRlY29kZXIgPT4gbmV3IENvbnRlbnREZWxldGVkKGRlY29kZXIucmVhZExlbigpKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZ3VpZFxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBvcHRzXG4gKi9cbmNvbnN0IGNyZWF0ZURvY0Zyb21PcHRzID0gKGd1aWQsIG9wdHMpID0+IG5ldyBEb2MoeyBndWlkLCAuLi5vcHRzLCBzaG91bGRMb2FkOiBvcHRzLnNob3VsZExvYWQgfHwgb3B0cy5hdXRvTG9hZCB8fCBmYWxzZSB9KTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb250ZW50RG9jIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBkb2NcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkb2MpIHtcbiAgICBpZiAoZG9jLl9pdGVtKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUaGlzIGRvY3VtZW50IHdhcyBhbHJlYWR5IGludGVncmF0ZWQgYXMgYSBzdWItZG9jdW1lbnQuIFlvdSBzaG91bGQgY3JlYXRlIGEgc2Vjb25kIGluc3RhbmNlIGluc3RlYWQgd2l0aCB0aGUgc2FtZSBndWlkLicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RG9jfVxuICAgICAqL1xuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHthbnl9XG4gICAgICovXG4gICAgY29uc3Qgb3B0cyA9IHt9O1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgaWYgKCFkb2MuZ2MpIHtcbiAgICAgIG9wdHMuZ2MgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRvYy5hdXRvTG9hZCkge1xuICAgICAgb3B0cy5hdXRvTG9hZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChkb2MubWV0YSAhPT0gbnVsbCkge1xuICAgICAgb3B0cy5tZXRhID0gZG9jLm1ldGE7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmRvY11cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudERvY31cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudERvYyhjcmVhdGVEb2NGcm9tT3B0cyh0aGlzLmRvYy5ndWlkLCB0aGlzLm9wdHMpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudERvY31cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50RG9jfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge1xuICAgIC8vIHRoaXMgbmVlZHMgdG8gYmUgcmVmbGVjdGVkIGluIGRvYy5kZXN0cm95IGFzIHdlbGxcbiAgICB0aGlzLmRvYy5faXRlbSA9IGl0ZW07XG4gICAgdHJhbnNhY3Rpb24uc3ViZG9jc0FkZGVkLmFkZCh0aGlzLmRvYyk7XG4gICAgaWYgKHRoaXMuZG9jLnNob3VsZExvYWQpIHtcbiAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NMb2FkZWQuYWRkKHRoaXMuZG9jKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodHJhbnNhY3Rpb24uc3ViZG9jc0FkZGVkLmhhcyh0aGlzLmRvYykpIHtcbiAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NBZGRlZC5kZWxldGUodGhpcy5kb2MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzUmVtb3ZlZC5hZGQodGhpcy5kb2MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7IH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVTdHJpbmcodGhpcy5kb2MuZ3VpZCk7XG4gICAgZW5jb2Rlci53cml0ZUFueSh0aGlzLm9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDlcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnREb2N9XG4gKi9cbmNvbnN0IHJlYWRDb250ZW50RG9jID0gZGVjb2RlciA9PiBuZXcgQ29udGVudERvYyhjcmVhdGVEb2NGcm9tT3B0cyhkZWNvZGVyLnJlYWRTdHJpbmcoKSwgZGVjb2Rlci5yZWFkQW55KCkpKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb250ZW50RW1iZWQge1xuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3R9IGVtYmVkXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZW1iZWQpIHtcbiAgICB0aGlzLmVtYmVkID0gZW1iZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gW3RoaXMuZW1iZWRdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRFbWJlZH1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudEVtYmVkKHRoaXMuZW1iZWQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50RW1iZWR9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudEVtYmVkfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlSlNPTih0aGlzLmVtYmVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiA1XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50RW1iZWR9XG4gKi9cbmNvbnN0IHJlYWRDb250ZW50RW1iZWQgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50RW1iZWQoZGVjb2Rlci5yZWFkSlNPTigpKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb250ZW50Rm9ybWF0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudEZvcm1hdH1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudEZvcm1hdCh0aGlzLmtleSwgdGhpcy52YWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gX29mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50Rm9ybWF0fVxuICAgKi9cbiAgc3BsaWNlIChfb2Zmc2V0KSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50Rm9ybWF0fSBfcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAoX3JpZ2h0KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gX3RyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlIChfdHJhbnNhY3Rpb24sIGl0ZW0pIHtcbiAgICAvLyBAdG9kbyBzZWFyY2htYXJrZXIgYXJlIGN1cnJlbnRseSB1bnN1cHBvcnRlZCBmb3IgcmljaCB0ZXh0IGRvY3VtZW50c1xuICAgIGNvbnN0IHAgPSAvKiogQHR5cGUge1lUZXh0fSAqLyAoaXRlbS5wYXJlbnQpO1xuICAgIHAuX3NlYXJjaE1hcmtlciA9IG51bGw7XG4gICAgcC5faGFzRm9ybWF0dGluZyA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVLZXkodGhpcy5rZXkpO1xuICAgIGVuY29kZXIud3JpdGVKU09OKHRoaXMudmFsdWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDZcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50Rm9ybWF0fVxuICovXG5jb25zdCByZWFkQ29udGVudEZvcm1hdCA9IGRlY29kZXIgPT4gbmV3IENvbnRlbnRGb3JtYXQoZGVjb2Rlci5yZWFkS2V5KCksIGRlY29kZXIucmVhZEpTT04oKSk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ29udGVudEpTT04ge1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChhcnIpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLmFyciA9IGFycjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLmFyci5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRKU09OfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50SlNPTih0aGlzLmFycilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRKU09OfVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICBjb25zdCByaWdodCA9IG5ldyBDb250ZW50SlNPTih0aGlzLmFyci5zbGljZShvZmZzZXQpKTtcbiAgICB0aGlzLmFyciA9IHRoaXMuYXJyLnNsaWNlKDAsIG9mZnNldCk7XG4gICAgcmV0dXJuIHJpZ2h0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50SlNPTn0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICB0aGlzLmFyciA9IHRoaXMuYXJyLmNvbmNhdChyaWdodC5hcnIpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGNvbnN0IGxlbiA9IHRoaXMuYXJyLmxlbmd0aDtcbiAgICBlbmNvZGVyLndyaXRlTGVuKGxlbiAtIG9mZnNldCk7XG4gICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gdGhpcy5hcnJbaV07XG4gICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKGMgPT09IHVuZGVmaW5lZCA/ICd1bmRlZmluZWQnIDogSlNPTi5zdHJpbmdpZnkoYykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiAyXG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50SlNPTn1cbiAqL1xuY29uc3QgcmVhZENvbnRlbnRKU09OID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IGxlbiA9IGRlY29kZXIucmVhZExlbigpO1xuICBjb25zdCBjcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgYyA9IGRlY29kZXIucmVhZFN0cmluZygpO1xuICAgIGlmIChjID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY3MucHVzaCh1bmRlZmluZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjcy5wdXNoKEpTT04ucGFyc2UoYykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IENvbnRlbnRKU09OKGNzKVxufTtcblxuY29uc3QgaXNEZXZNb2RlID0gZW52LmdldFZhcmlhYmxlKCdub2RlX2VudicpID09PSAnZGV2ZWxvcG1lbnQnO1xuXG5jbGFzcyBDb250ZW50QW55IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoYXJyKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGFueT59XG4gICAgICovXG4gICAgdGhpcy5hcnIgPSBhcnI7XG4gICAgaXNEZXZNb2RlICYmIG9iamVjdC5kZWVwRnJlZXplKGFycik7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnIubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLmFyclxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50QW55fVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50QW55KHRoaXMuYXJyKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudEFueX1cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgY29uc3QgcmlnaHQgPSBuZXcgQ29udGVudEFueSh0aGlzLmFyci5zbGljZShvZmZzZXQpKTtcbiAgICB0aGlzLmFyciA9IHRoaXMuYXJyLnNsaWNlKDAsIG9mZnNldCk7XG4gICAgcmV0dXJuIHJpZ2h0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50QW55fSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHRoaXMuYXJyID0gdGhpcy5hcnIuY29uY2F0KHJpZ2h0LmFycik7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgY29uc3QgbGVuID0gdGhpcy5hcnIubGVuZ3RoO1xuICAgIGVuY29kZXIud3JpdGVMZW4obGVuIC0gb2Zmc2V0KTtcbiAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLmFycltpXTtcbiAgICAgIGVuY29kZXIud3JpdGVBbnkoYyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDhcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50QW55fVxuICovXG5jb25zdCByZWFkQ29udGVudEFueSA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBsZW4gPSBkZWNvZGVyLnJlYWRMZW4oKTtcbiAgY29uc3QgY3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNzLnB1c2goZGVjb2Rlci5yZWFkQW55KCkpO1xuICB9XG4gIHJldHVybiBuZXcgQ29udGVudEFueShjcylcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ29udGVudFN0cmluZyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoc3RyKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnN0ciA9IHN0cjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLnN0ci5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyLnNwbGl0KCcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50U3RyaW5nfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50U3RyaW5nKHRoaXMuc3RyKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudFN0cmluZ31cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgY29uc3QgcmlnaHQgPSBuZXcgQ29udGVudFN0cmluZyh0aGlzLnN0ci5zbGljZShvZmZzZXQpKTtcbiAgICB0aGlzLnN0ciA9IHRoaXMuc3RyLnNsaWNlKDAsIG9mZnNldCk7XG5cbiAgICAvLyBQcmV2ZW50IGVuY29kaW5nIGludmFsaWQgZG9jdW1lbnRzIGJlY2F1c2Ugb2Ygc3BsaXR0aW5nIG9mIHN1cnJvZ2F0ZSBwYWlyczogaHR0cHM6Ly9naXRodWIuY29tL3lqcy95anMvaXNzdWVzLzI0OFxuICAgIGNvbnN0IGZpcnN0Q2hhckNvZGUgPSB0aGlzLnN0ci5jaGFyQ29kZUF0KG9mZnNldCAtIDEpO1xuICAgIGlmIChmaXJzdENoYXJDb2RlID49IDB4RDgwMCAmJiBmaXJzdENoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgLy8gTGFzdCBjaGFyYWN0ZXIgb2YgdGhlIGxlZnQgc3BsaXQgaXMgdGhlIHN0YXJ0IG9mIGEgc3Vycm9nYXRlIHV0ZjE2L3VjczIgcGFpci5cbiAgICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgc3BsaXR0aW5nIG9mIHN1cnJvZ2F0ZSBwYWlycyBiZWNhdXNlIHRoaXMgbWF5IGxlYWQgdG8gaW52YWxpZCBkb2N1bWVudHMuXG4gICAgICAvLyBSZXBsYWNlIHRoZSBpbnZhbGlkIGNoYXJhY3RlciB3aXRoIGEgdW5pY29kZSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKO+/vSAvIFUrRkZGRClcbiAgICAgIHRoaXMuc3RyID0gdGhpcy5zdHIuc2xpY2UoMCwgb2Zmc2V0IC0gMSkgKyAn77+9JztcbiAgICAgIC8vIHJlcGxhY2UgcmlnaHQgYXMgd2VsbFxuICAgICAgcmlnaHQuc3RyID0gJ++/vScgKyByaWdodC5zdHIuc2xpY2UoMSk7XG4gICAgfVxuICAgIHJldHVybiByaWdodFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudFN0cmluZ30gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICB0aGlzLnN0ciArPSByaWdodC5zdHI7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZVN0cmluZyhvZmZzZXQgPT09IDAgPyB0aGlzLnN0ciA6IHRoaXMuc3RyLnNsaWNlKG9mZnNldCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDRcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnRTdHJpbmd9XG4gKi9cbmNvbnN0IHJlYWRDb250ZW50U3RyaW5nID0gZGVjb2RlciA9PiBuZXcgQ29udGVudFN0cmluZyhkZWNvZGVyLnJlYWRTdHJpbmcoKSk7XG5cbi8qKlxuICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKFVwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMik6QWJzdHJhY3RUeXBlPGFueT4+fVxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgdHlwZVJlZnMgPSBbXG4gIHJlYWRZQXJyYXksXG4gIHJlYWRZTWFwLFxuICByZWFkWVRleHQsXG4gIHJlYWRZWG1sRWxlbWVudCxcbiAgcmVhZFlYbWxGcmFnbWVudCxcbiAgcmVhZFlYbWxIb29rLFxuICByZWFkWVhtbFRleHRcbl07XG5cbmNvbnN0IFlBcnJheVJlZklEID0gMDtcbmNvbnN0IFlNYXBSZWZJRCA9IDE7XG5jb25zdCBZVGV4dFJlZklEID0gMjtcbmNvbnN0IFlYbWxFbGVtZW50UmVmSUQgPSAzO1xuY29uc3QgWVhtbEZyYWdtZW50UmVmSUQgPSA0O1xuY29uc3QgWVhtbEhvb2tSZWZJRCA9IDU7XG5jb25zdCBZWG1sVGV4dFJlZklEID0gNjtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb250ZW50VHlwZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodHlwZSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFt0aGlzLnR5cGVdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRUeXBlfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50VHlwZSh0aGlzLnR5cGUuX2NvcHkoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRUeXBlfVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRUeXBlfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge1xuICAgIHRoaXMudHlwZS5faW50ZWdyYXRlKHRyYW5zYWN0aW9uLmRvYywgaXRlbSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHtcbiAgICBsZXQgaXRlbSA9IHRoaXMudHlwZS5fc3RhcnQ7XG4gICAgd2hpbGUgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgIGl0ZW0uZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5pZC5jbG9jayA8ICh0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoaXRlbS5pZC5jbGllbnQpIHx8IDApKSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBnYydkIGxhdGVyIGFuZCB3ZSB3YW50IHRvIG1lcmdlIGl0IGlmIHBvc3NpYmxlXG4gICAgICAgIC8vIFdlIHRyeSB0byBtZXJnZSBhbGwgZGVsZXRlZCBpdGVtcyBhZnRlciBlYWNoIHRyYW5zYWN0aW9uLFxuICAgICAgICAvLyBidXQgd2UgaGF2ZSBubyBrbm93bGVkZ2UgYWJvdXQgdGhhdCB0aGlzIG5lZWRzIHRvIGJlIG1lcmdlZFxuICAgICAgICAvLyBzaW5jZSBpdCBpcyBub3QgaW4gdHJhbnNhY3Rpb24uZHMuIEhlbmNlIHdlIGFkZCBpdCB0byB0cmFuc2FjdGlvbi5fbWVyZ2VTdHJ1Y3RzXG4gICAgICAgIHRyYW5zYWN0aW9uLl9tZXJnZVN0cnVjdHMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICAgIGl0ZW0gPSBpdGVtLnJpZ2h0O1xuICAgIH1cbiAgICB0aGlzLnR5cGUuX21hcC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgaXRlbS5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmIChpdGVtLmlkLmNsb2NrIDwgKHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChpdGVtLmlkLmNsaWVudCkgfHwgMCkpIHtcbiAgICAgICAgLy8gc2FtZSBhcyBhYm92ZVxuICAgICAgICB0cmFuc2FjdGlvbi5fbWVyZ2VTdHJ1Y3RzLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdHJhbnNhY3Rpb24uY2hhbmdlZC5kZWxldGUodGhpcy50eXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7XG4gICAgbGV0IGl0ZW0gPSB0aGlzLnR5cGUuX3N0YXJ0O1xuICAgIHdoaWxlIChpdGVtICE9PSBudWxsKSB7XG4gICAgICBpdGVtLmdjKHN0b3JlLCB0cnVlKTtcbiAgICAgIGl0ZW0gPSBpdGVtLnJpZ2h0O1xuICAgIH1cbiAgICB0aGlzLnR5cGUuX3N0YXJ0ID0gbnVsbDtcbiAgICB0aGlzLnR5cGUuX21hcC5mb3JFYWNoKC8qKiBAcGFyYW0ge0l0ZW0gfCBudWxsfSBpdGVtICovIChpdGVtKSA9PiB7XG4gICAgICB3aGlsZSAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgICBpdGVtLmdjKHN0b3JlLCB0cnVlKTtcbiAgICAgICAgaXRlbSA9IGl0ZW0ubGVmdDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnR5cGUuX21hcCA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgdGhpcy50eXBlLl93cml0ZShlbmNvZGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiA3XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50VHlwZX1cbiAqL1xuY29uc3QgcmVhZENvbnRlbnRUeXBlID0gZGVjb2RlciA9PiBuZXcgQ29udGVudFR5cGUodHlwZVJlZnNbZGVjb2Rlci5yZWFkVHlwZVJlZigpXShkZWNvZGVyKSk7XG5cbi8qKlxuICogQHRvZG8gVGhpcyBzaG91bGQgcmV0dXJuIHNldmVyYWwgaXRlbXNcbiAqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJRH0gaWRcbiAqIEByZXR1cm4ge3tpdGVtOkl0ZW0sIGRpZmY6bnVtYmVyfX1cbiAqL1xuY29uc3QgZm9sbG93UmVkb25lID0gKHN0b3JlLCBpZCkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0lEfG51bGx9XG4gICAqL1xuICBsZXQgbmV4dElEID0gaWQ7XG4gIGxldCBkaWZmID0gMDtcbiAgbGV0IGl0ZW07XG4gIGRvIHtcbiAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgIG5leHRJRCA9IGNyZWF0ZUlEKG5leHRJRC5jbGllbnQsIG5leHRJRC5jbG9jayArIGRpZmYpO1xuICAgIH1cbiAgICBpdGVtID0gZ2V0SXRlbShzdG9yZSwgbmV4dElEKTtcbiAgICBkaWZmID0gbmV4dElELmNsb2NrIC0gaXRlbS5pZC5jbG9jaztcbiAgICBuZXh0SUQgPSBpdGVtLnJlZG9uZTtcbiAgfSB3aGlsZSAobmV4dElEICE9PSBudWxsICYmIGl0ZW0gaW5zdGFuY2VvZiBJdGVtKVxuICByZXR1cm4ge1xuICAgIGl0ZW0sIGRpZmZcbiAgfVxufTtcblxuLyoqXG4gKiBNYWtlIHN1cmUgdGhhdCBuZWl0aGVyIGl0ZW0gbm9yIGFueSBvZiBpdHMgcGFyZW50cyBpcyBldmVyIGRlbGV0ZWQuXG4gKlxuICogVGhpcyBwcm9wZXJ0eSBkb2VzIG5vdCBwZXJzaXN0IHdoZW4gc3RvcmluZyBpdCBpbnRvIGEgZGF0YWJhc2Ugb3Igd2hlblxuICogc2VuZGluZyBpdCB0byBvdGhlciBwZWVyc1xuICpcbiAqIEBwYXJhbSB7SXRlbXxudWxsfSBpdGVtXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGtlZXBcbiAqL1xuY29uc3Qga2VlcEl0ZW0gPSAoaXRlbSwga2VlcCkgPT4ge1xuICB3aGlsZSAoaXRlbSAhPT0gbnVsbCAmJiBpdGVtLmtlZXAgIT09IGtlZXApIHtcbiAgICBpdGVtLmtlZXAgPSBrZWVwO1xuICAgIGl0ZW0gPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoaXRlbS5wYXJlbnQpLl9pdGVtO1xuICB9XG59O1xuXG4vKipcbiAqIFNwbGl0IGxlZnRJdGVtIGludG8gdHdvIGl0ZW1zXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtJdGVtfSBsZWZ0SXRlbVxuICogQHBhcmFtIHtudW1iZXJ9IGRpZmZcbiAqIEByZXR1cm4ge0l0ZW19XG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCBzcGxpdEl0ZW0gPSAodHJhbnNhY3Rpb24sIGxlZnRJdGVtLCBkaWZmKSA9PiB7XG4gIC8vIGNyZWF0ZSByaWdodEl0ZW1cbiAgY29uc3QgeyBjbGllbnQsIGNsb2NrIH0gPSBsZWZ0SXRlbS5pZDtcbiAgY29uc3QgcmlnaHRJdGVtID0gbmV3IEl0ZW0oXG4gICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayArIGRpZmYpLFxuICAgIGxlZnRJdGVtLFxuICAgIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2sgKyBkaWZmIC0gMSksXG4gICAgbGVmdEl0ZW0ucmlnaHQsXG4gICAgbGVmdEl0ZW0ucmlnaHRPcmlnaW4sXG4gICAgbGVmdEl0ZW0ucGFyZW50LFxuICAgIGxlZnRJdGVtLnBhcmVudFN1YixcbiAgICBsZWZ0SXRlbS5jb250ZW50LnNwbGljZShkaWZmKVxuICApO1xuICBpZiAobGVmdEl0ZW0uZGVsZXRlZCkge1xuICAgIHJpZ2h0SXRlbS5tYXJrRGVsZXRlZCgpO1xuICB9XG4gIGlmIChsZWZ0SXRlbS5rZWVwKSB7XG4gICAgcmlnaHRJdGVtLmtlZXAgPSB0cnVlO1xuICB9XG4gIGlmIChsZWZ0SXRlbS5yZWRvbmUgIT09IG51bGwpIHtcbiAgICByaWdodEl0ZW0ucmVkb25lID0gY3JlYXRlSUQobGVmdEl0ZW0ucmVkb25lLmNsaWVudCwgbGVmdEl0ZW0ucmVkb25lLmNsb2NrICsgZGlmZik7XG4gIH1cbiAgLy8gdXBkYXRlIGxlZnQgKGRvIG5vdCBzZXQgbGVmdEl0ZW0ucmlnaHRPcmlnaW4gYXMgaXQgd2lsbCBsZWFkIHRvIHByb2JsZW1zIHdoZW4gc3luY2luZylcbiAgbGVmdEl0ZW0ucmlnaHQgPSByaWdodEl0ZW07XG4gIC8vIHVwZGF0ZSByaWdodFxuICBpZiAocmlnaHRJdGVtLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgcmlnaHRJdGVtLnJpZ2h0LmxlZnQgPSByaWdodEl0ZW07XG4gIH1cbiAgLy8gcmlnaHQgaXMgbW9yZSBzcGVjaWZpYy5cbiAgdHJhbnNhY3Rpb24uX21lcmdlU3RydWN0cy5wdXNoKHJpZ2h0SXRlbSk7XG4gIC8vIHVwZGF0ZSBwYXJlbnQuX21hcFxuICBpZiAocmlnaHRJdGVtLnBhcmVudFN1YiAhPT0gbnVsbCAmJiByaWdodEl0ZW0ucmlnaHQgPT09IG51bGwpIHtcbiAgICAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHRJdGVtLnBhcmVudCkuX21hcC5zZXQocmlnaHRJdGVtLnBhcmVudFN1YiwgcmlnaHRJdGVtKTtcbiAgfVxuICBsZWZ0SXRlbS5sZW5ndGggPSBkaWZmO1xuICByZXR1cm4gcmlnaHRJdGVtXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8U3RhY2tJdGVtPn0gc3RhY2tcbiAqIEBwYXJhbSB7SUR9IGlkXG4gKi9cbmNvbnN0IGlzRGVsZXRlZEJ5VW5kb1N0YWNrID0gKHN0YWNrLCBpZCkgPT4gYXJyYXkuc29tZShzdGFjaywgLyoqIEBwYXJhbSB7U3RhY2tJdGVtfSBzICovIHMgPT4gaXNEZWxldGVkKHMuZGVsZXRpb25zLCBpZCkpO1xuXG4vKipcbiAqIFJlZG9lcyB0aGUgZWZmZWN0IG9mIHRoaXMgb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIFRoZSBZanMgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7U2V0PEl0ZW0+fSByZWRvaXRlbXNcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBpdGVtc1RvRGVsZXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlnbm9yZVJlbW90ZU1hcENoYW5nZXNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi91dGlscy9VbmRvTWFuYWdlci5qcycpLlVuZG9NYW5hZ2VyfSB1bVxuICpcbiAqIEByZXR1cm4ge0l0ZW18bnVsbH1cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCByZWRvSXRlbSA9ICh0cmFuc2FjdGlvbiwgaXRlbSwgcmVkb2l0ZW1zLCBpdGVtc1RvRGVsZXRlLCBpZ25vcmVSZW1vdGVNYXBDaGFuZ2VzLCB1bSkgPT4ge1xuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlO1xuICBjb25zdCBvd25DbGllbnRJRCA9IGRvYy5jbGllbnRJRDtcbiAgY29uc3QgcmVkb25lID0gaXRlbS5yZWRvbmU7XG4gIGlmIChyZWRvbmUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIHJlZG9uZSlcbiAgfVxuICBsZXQgcGFyZW50SXRlbSA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChpdGVtLnBhcmVudCkuX2l0ZW07XG4gIC8qKlxuICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgKi9cbiAgbGV0IGxlZnQgPSBudWxsO1xuICAvKipcbiAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICovXG4gIGxldCByaWdodDtcbiAgLy8gbWFrZSBzdXJlIHRoYXQgcGFyZW50IGlzIHJlZG9uZVxuICBpZiAocGFyZW50SXRlbSAhPT0gbnVsbCAmJiBwYXJlbnRJdGVtLmRlbGV0ZWQgPT09IHRydWUpIHtcbiAgICAvLyB0cnkgdG8gdW5kbyBwYXJlbnQgaWYgaXQgd2lsbCBiZSB1bmRvbmUgYW55d2F5XG4gICAgaWYgKHBhcmVudEl0ZW0ucmVkb25lID09PSBudWxsICYmICghcmVkb2l0ZW1zLmhhcyhwYXJlbnRJdGVtKSB8fCByZWRvSXRlbSh0cmFuc2FjdGlvbiwgcGFyZW50SXRlbSwgcmVkb2l0ZW1zLCBpdGVtc1RvRGVsZXRlLCBpZ25vcmVSZW1vdGVNYXBDaGFuZ2VzLCB1bSkgPT09IG51bGwpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB3aGlsZSAocGFyZW50SXRlbS5yZWRvbmUgIT09IG51bGwpIHtcbiAgICAgIHBhcmVudEl0ZW0gPSBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgcGFyZW50SXRlbS5yZWRvbmUpO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYXJlbnRUeXBlID0gcGFyZW50SXRlbSA9PT0gbnVsbCA/IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChpdGVtLnBhcmVudCkgOiAvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAocGFyZW50SXRlbS5jb250ZW50KS50eXBlO1xuXG4gIGlmIChpdGVtLnBhcmVudFN1YiA9PT0gbnVsbCkge1xuICAgIC8vIElzIGFuIGFycmF5IGl0ZW0uIEluc2VydCBhdCB0aGUgb2xkIHBvc2l0aW9uXG4gICAgbGVmdCA9IGl0ZW0ubGVmdDtcbiAgICByaWdodCA9IGl0ZW07XG4gICAgLy8gZmluZCBuZXh0IGNsb25lZF9yZWRvIGl0ZW1zXG4gICAgd2hpbGUgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgICAqL1xuICAgICAgbGV0IGxlZnRUcmFjZSA9IGxlZnQ7XG4gICAgICAvLyB0cmFjZSByZWRvbmUgdW50aWwgcGFyZW50IG1hdGNoZXNcbiAgICAgIHdoaWxlIChsZWZ0VHJhY2UgIT09IG51bGwgJiYgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGxlZnRUcmFjZS5wYXJlbnQpLl9pdGVtICE9PSBwYXJlbnRJdGVtKSB7XG4gICAgICAgIGxlZnRUcmFjZSA9IGxlZnRUcmFjZS5yZWRvbmUgPT09IG51bGwgPyBudWxsIDogZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGxlZnRUcmFjZS5yZWRvbmUpO1xuICAgICAgfVxuICAgICAgaWYgKGxlZnRUcmFjZSAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAobGVmdFRyYWNlLnBhcmVudCkuX2l0ZW0gPT09IHBhcmVudEl0ZW0pIHtcbiAgICAgICAgbGVmdCA9IGxlZnRUcmFjZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGxlZnQgPSBsZWZ0LmxlZnQ7XG4gICAgfVxuICAgIHdoaWxlIChyaWdodCAhPT0gbnVsbCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAgICovXG4gICAgICBsZXQgcmlnaHRUcmFjZSA9IHJpZ2h0O1xuICAgICAgLy8gdHJhY2UgcmVkb25lIHVudGlsIHBhcmVudCBtYXRjaGVzXG4gICAgICB3aGlsZSAocmlnaHRUcmFjZSAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHRUcmFjZS5wYXJlbnQpLl9pdGVtICE9PSBwYXJlbnRJdGVtKSB7XG4gICAgICAgIHJpZ2h0VHJhY2UgPSByaWdodFRyYWNlLnJlZG9uZSA9PT0gbnVsbCA/IG51bGwgOiBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgcmlnaHRUcmFjZS5yZWRvbmUpO1xuICAgICAgfVxuICAgICAgaWYgKHJpZ2h0VHJhY2UgIT09IG51bGwgJiYgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHJpZ2h0VHJhY2UucGFyZW50KS5faXRlbSA9PT0gcGFyZW50SXRlbSkge1xuICAgICAgICByaWdodCA9IHJpZ2h0VHJhY2U7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICByaWdodCA9IHJpZ2h0LnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByaWdodCA9IG51bGw7XG4gICAgaWYgKGl0ZW0ucmlnaHQgJiYgIWlnbm9yZVJlbW90ZU1hcENoYW5nZXMpIHtcbiAgICAgIGxlZnQgPSBpdGVtO1xuICAgICAgLy8gSXRlcmF0ZSByaWdodCB3aGlsZSByaWdodCBpcyBpbiBpdGVtc1RvRGVsZXRlXG4gICAgICAvLyBJZiBpdCBpcyBpbnRlbmRlZCB0byBkZWxldGUgcmlnaHQgd2hpbGUgaXRlbSBpcyByZWRvbmUsIHdlIGNhbiBleHBlY3QgdGhhdCBpdGVtIHNob3VsZCByZXBsYWNlIHJpZ2h0LlxuICAgICAgd2hpbGUgKGxlZnQgIT09IG51bGwgJiYgbGVmdC5yaWdodCAhPT0gbnVsbCAmJiAobGVmdC5yaWdodC5yZWRvbmUgfHwgaXNEZWxldGVkKGl0ZW1zVG9EZWxldGUsIGxlZnQucmlnaHQuaWQpIHx8IGlzRGVsZXRlZEJ5VW5kb1N0YWNrKHVtLnVuZG9TdGFjaywgbGVmdC5yaWdodC5pZCkgfHwgaXNEZWxldGVkQnlVbmRvU3RhY2sodW0ucmVkb1N0YWNrLCBsZWZ0LnJpZ2h0LmlkKSkpIHtcbiAgICAgICAgbGVmdCA9IGxlZnQucmlnaHQ7XG4gICAgICAgIC8vIGZvbGxvdyByZWRvbmVcbiAgICAgICAgd2hpbGUgKGxlZnQucmVkb25lKSBsZWZ0ID0gZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGxlZnQucmVkb25lKTtcbiAgICAgIH1cbiAgICAgIGlmIChsZWZ0ICYmIGxlZnQucmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSXQgaXMgbm90IHBvc3NpYmxlIHRvIHJlZG8gdGhpcyBpdGVtIGJlY2F1c2UgaXQgY29uZmxpY3RzIHdpdGggYVxuICAgICAgICAvLyBjaGFuZ2UgZnJvbSBhbm90aGVyIGNsaWVudFxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gcGFyZW50VHlwZS5fbWFwLmdldChpdGVtLnBhcmVudFN1YikgfHwgbnVsbDtcbiAgICB9XG4gIH1cbiAgY29uc3QgbmV4dENsb2NrID0gZ2V0U3RhdGUoc3RvcmUsIG93bkNsaWVudElEKTtcbiAgY29uc3QgbmV4dElkID0gY3JlYXRlSUQob3duQ2xpZW50SUQsIG5leHRDbG9jayk7XG4gIGNvbnN0IHJlZG9uZUl0ZW0gPSBuZXcgSXRlbShcbiAgICBuZXh0SWQsXG4gICAgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCxcbiAgICByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsXG4gICAgcGFyZW50VHlwZSxcbiAgICBpdGVtLnBhcmVudFN1YixcbiAgICBpdGVtLmNvbnRlbnQuY29weSgpXG4gICk7XG4gIGl0ZW0ucmVkb25lID0gbmV4dElkO1xuICBrZWVwSXRlbShyZWRvbmVJdGVtLCB0cnVlKTtcbiAgcmVkb25lSXRlbS5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICByZXR1cm4gcmVkb25lSXRlbVxufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYW55IGNvbnRlbnQuXG4gKi9cbmNsYXNzIEl0ZW0gZXh0ZW5kcyBBYnN0cmFjdFN0cnVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKiBAcGFyYW0ge0l0ZW0gfCBudWxsfSBsZWZ0XG4gICAqIEBwYXJhbSB7SUQgfCBudWxsfSBvcmlnaW5cbiAgICogQHBhcmFtIHtJdGVtIHwgbnVsbH0gcmlnaHRcbiAgICogQHBhcmFtIHtJRCB8IG51bGx9IHJpZ2h0T3JpZ2luXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT58SUR8bnVsbH0gcGFyZW50IElzIGEgdHlwZSBpZiBpbnRlZ3JhdGVkLCBpcyBudWxsIGlmIGl0IGlzIHBvc3NpYmxlIHRvIGNvcHkgcGFyZW50IGZyb20gbGVmdCBvciByaWdodCwgaXMgSUQgYmVmb3JlIGludGVncmF0aW9uIHRvIHNlYXJjaCBmb3IgaXQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbH0gcGFyZW50U3ViXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RDb250ZW50fSBjb250ZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvciAoaWQsIGxlZnQsIG9yaWdpbiwgcmlnaHQsIHJpZ2h0T3JpZ2luLCBwYXJlbnQsIHBhcmVudFN1YiwgY29udGVudCkge1xuICAgIHN1cGVyKGlkLCBjb250ZW50LmdldExlbmd0aCgpKTtcbiAgICAvKipcbiAgICAgKiBUaGUgaXRlbSB0aGF0IHdhcyBvcmlnaW5hbGx5IHRvIHRoZSBsZWZ0IG9mIHRoaXMgaXRlbS5cbiAgICAgKiBAdHlwZSB7SUQgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luO1xuICAgIC8qKlxuICAgICAqIFRoZSBpdGVtIHRoYXQgaXMgY3VycmVudGx5IHRvIHRoZSBsZWZ0IG9mIHRoaXMgaXRlbS5cbiAgICAgKiBAdHlwZSB7SXRlbSB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICAvKipcbiAgICAgKiBUaGUgaXRlbSB0aGF0IGlzIGN1cnJlbnRseSB0byB0aGUgcmlnaHQgb2YgdGhpcyBpdGVtLlxuICAgICAqIEB0eXBlIHtJdGVtIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgLyoqXG4gICAgICogVGhlIGl0ZW0gdGhhdCB3YXMgb3JpZ2luYWxseSB0byB0aGUgcmlnaHQgb2YgdGhpcyBpdGVtLlxuICAgICAqIEB0eXBlIHtJRCB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yaWdodE9yaWdpbiA9IHJpZ2h0T3JpZ2luO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55PnxJRHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIC8qKlxuICAgICAqIElmIHRoZSBwYXJlbnQgcmVmZXJzIHRvIHRoaXMgaXRlbSB3aXRoIHNvbWUga2luZCBvZiBrZXkgKGUuZy4gWU1hcCwgdGhlXG4gICAgICoga2V5IGlzIHNwZWNpZmllZCBoZXJlLiBUaGUga2V5IGlzIHRoZW4gdXNlZCB0byByZWZlciB0byB0aGUgbGlzdCBpbiB3aGljaFxuICAgICAqIHRvIGluc2VydCB0aGlzIGl0ZW0uIElmIGBwYXJlbnRTdWIgPSBudWxsYCB0eXBlLl9zdGFydCBpcyB0aGUgbGlzdCBpblxuICAgICAqIHdoaWNoIHRvIGluc2VydCB0by4gT3RoZXJ3aXNlIGl0IGlzIGBwYXJlbnQuX21hcGAuXG4gICAgICogQHR5cGUge1N0cmluZyB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5wYXJlbnRTdWIgPSBwYXJlbnRTdWI7XG4gICAgLyoqXG4gICAgICogSWYgdGhpcyB0eXBlJ3MgZWZmZWN0IGlzIHJlZG9uZSB0aGlzIHR5cGUgcmVmZXJzIHRvIHRoZSB0eXBlIHRoYXQgdW5kaWRcbiAgICAgKiB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7SUQgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVkb25lID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QWJzdHJhY3RDb250ZW50fVxuICAgICAqL1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgLyoqXG4gICAgICogYml0MToga2VlcFxuICAgICAqIGJpdDI6IGNvdW50YWJsZVxuICAgICAqIGJpdDM6IGRlbGV0ZWRcbiAgICAgKiBiaXQ0OiBtYXJrIC0gbWFyayBub2RlIGFzIGZhc3Qtc2VhcmNoLW1hcmtlclxuICAgICAqIEB0eXBlIHtudW1iZXJ9IGJ5dGVcbiAgICAgKi9cbiAgICB0aGlzLmluZm8gPSB0aGlzLmNvbnRlbnQuaXNDb3VudGFibGUoKSA/IGJpbmFyeS5CSVQyIDogMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gbWFyayB0aGUgaXRlbSBhcyBhbiBpbmRleGVkIGZhc3Qtc2VhcmNoIG1hcmtlclxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHNldCBtYXJrZXIgKGlzTWFya2VkKSB7XG4gICAgaWYgKCgodGhpcy5pbmZvICYgYmluYXJ5LkJJVDQpID4gMCkgIT09IGlzTWFya2VkKSB7XG4gICAgICB0aGlzLmluZm8gXj0gYmluYXJ5LkJJVDQ7XG4gICAgfVxuICB9XG5cbiAgZ2V0IG1hcmtlciAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmluZm8gJiBiaW5hcnkuQklUNCkgPiAwXG4gIH1cblxuICAvKipcbiAgICogSWYgdHJ1ZSwgZG8gbm90IGdhcmJhZ2UgY29sbGVjdCB0aGlzIEl0ZW0uXG4gICAqL1xuICBnZXQga2VlcCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmluZm8gJiBiaW5hcnkuQklUMSkgPiAwXG4gIH1cblxuICBzZXQga2VlcCAoZG9LZWVwKSB7XG4gICAgaWYgKHRoaXMua2VlcCAhPT0gZG9LZWVwKSB7XG4gICAgICB0aGlzLmluZm8gXj0gYmluYXJ5LkJJVDE7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGNvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmluZm8gJiBiaW5hcnkuQklUMikgPiAwXG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIGl0ZW0gd2FzIGRlbGV0ZWQgb3Igbm90LlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBkZWxldGVkICgpIHtcbiAgICByZXR1cm4gKHRoaXMuaW5mbyAmIGJpbmFyeS5CSVQzKSA+IDBcbiAgfVxuXG4gIHNldCBkZWxldGVkIChkb0RlbGV0ZSkge1xuICAgIGlmICh0aGlzLmRlbGV0ZWQgIT09IGRvRGVsZXRlKSB7XG4gICAgICB0aGlzLmluZm8gXj0gYmluYXJ5LkJJVDM7XG4gICAgfVxuICB9XG5cbiAgbWFya0RlbGV0ZWQgKCkge1xuICAgIHRoaXMuaW5mbyB8PSBiaW5hcnkuQklUMztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGNyZWF0b3IgY2xpZW50SUQgb2YgdGhlIG1pc3Npbmcgb3Agb3IgZGVmaW5lIG1pc3NpbmcgaXRlbXMgYW5kIHJldHVybiBudWxsLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKiBAcmV0dXJuIHtudWxsIHwgbnVtYmVyfVxuICAgKi9cbiAgZ2V0TWlzc2luZyAodHJhbnNhY3Rpb24sIHN0b3JlKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luICYmIHRoaXMub3JpZ2luLmNsaWVudCAhPT0gdGhpcy5pZC5jbGllbnQgJiYgdGhpcy5vcmlnaW4uY2xvY2sgPj0gZ2V0U3RhdGUoc3RvcmUsIHRoaXMub3JpZ2luLmNsaWVudCkpIHtcbiAgICAgIHJldHVybiB0aGlzLm9yaWdpbi5jbGllbnRcbiAgICB9XG4gICAgaWYgKHRoaXMucmlnaHRPcmlnaW4gJiYgdGhpcy5yaWdodE9yaWdpbi5jbGllbnQgIT09IHRoaXMuaWQuY2xpZW50ICYmIHRoaXMucmlnaHRPcmlnaW4uY2xvY2sgPj0gZ2V0U3RhdGUoc3RvcmUsIHRoaXMucmlnaHRPcmlnaW4uY2xpZW50KSkge1xuICAgICAgcmV0dXJuIHRoaXMucmlnaHRPcmlnaW4uY2xpZW50XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5jb25zdHJ1Y3RvciA9PT0gSUQgJiYgdGhpcy5pZC5jbGllbnQgIT09IHRoaXMucGFyZW50LmNsaWVudCAmJiB0aGlzLnBhcmVudC5jbG9jayA+PSBnZXRTdGF0ZShzdG9yZSwgdGhpcy5wYXJlbnQuY2xpZW50KSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNsaWVudFxuICAgIH1cblxuICAgIC8vIFdlIGhhdmUgYWxsIG1pc3NpbmcgaWRzLCBub3cgZmluZCB0aGUgaXRlbXNcblxuICAgIGlmICh0aGlzLm9yaWdpbikge1xuICAgICAgdGhpcy5sZWZ0ID0gZ2V0SXRlbUNsZWFuRW5kKHRyYW5zYWN0aW9uLCBzdG9yZSwgdGhpcy5vcmlnaW4pO1xuICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLmxlZnQubGFzdElkO1xuICAgIH1cbiAgICBpZiAodGhpcy5yaWdodE9yaWdpbikge1xuICAgICAgdGhpcy5yaWdodCA9IGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCB0aGlzLnJpZ2h0T3JpZ2luKTtcbiAgICAgIHRoaXMucmlnaHRPcmlnaW4gPSB0aGlzLnJpZ2h0LmlkO1xuICAgIH1cbiAgICBpZiAoKHRoaXMubGVmdCAmJiB0aGlzLmxlZnQuY29uc3RydWN0b3IgPT09IEdDKSB8fCAodGhpcy5yaWdodCAmJiB0aGlzLnJpZ2h0LmNvbnN0cnVjdG9yID09PSBHQykpIHtcbiAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgLy8gb25seSBzZXQgcGFyZW50IGlmIHRoaXMgc2hvdWxkbid0IGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICBpZiAodGhpcy5sZWZ0ICYmIHRoaXMubGVmdC5jb25zdHJ1Y3RvciA9PT0gSXRlbSkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHRoaXMubGVmdC5wYXJlbnQ7XG4gICAgICAgIHRoaXMucGFyZW50U3ViID0gdGhpcy5sZWZ0LnBhcmVudFN1YjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yaWdodCAmJiB0aGlzLnJpZ2h0LmNvbnN0cnVjdG9yID09PSBJdGVtKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gdGhpcy5yaWdodC5wYXJlbnQ7XG4gICAgICAgIHRoaXMucGFyZW50U3ViID0gdGhpcy5yaWdodC5wYXJlbnRTdWI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudC5jb25zdHJ1Y3RvciA9PT0gSUQpIHtcbiAgICAgIGNvbnN0IHBhcmVudEl0ZW0gPSBnZXRJdGVtKHN0b3JlLCB0aGlzLnBhcmVudCk7XG4gICAgICBpZiAocGFyZW50SXRlbS5jb25zdHJ1Y3RvciA9PT0gR0MpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSAvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAocGFyZW50SXRlbS5jb250ZW50KS50eXBlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICB0aGlzLmlkLmNsb2NrICs9IG9mZnNldDtcbiAgICAgIHRoaXMubGVmdCA9IGdldEl0ZW1DbGVhbkVuZCh0cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24uZG9jLnN0b3JlLCBjcmVhdGVJRCh0aGlzLmlkLmNsaWVudCwgdGhpcy5pZC5jbG9jayAtIDEpKTtcbiAgICAgIHRoaXMub3JpZ2luID0gdGhpcy5sZWZ0Lmxhc3RJZDtcbiAgICAgIHRoaXMuY29udGVudCA9IHRoaXMuY29udGVudC5zcGxpY2Uob2Zmc2V0KTtcbiAgICAgIHRoaXMubGVuZ3RoIC09IG9mZnNldDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIGlmICgoIXRoaXMubGVmdCAmJiAoIXRoaXMucmlnaHQgfHwgdGhpcy5yaWdodC5sZWZ0ICE9PSBudWxsKSkgfHwgKHRoaXMubGVmdCAmJiB0aGlzLmxlZnQucmlnaHQgIT09IHRoaXMucmlnaHQpKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLmxlZnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbztcbiAgICAgICAgLy8gc2V0IG8gdG8gdGhlIGZpcnN0IGNvbmZsaWN0aW5nIGl0ZW1cbiAgICAgICAgaWYgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICBvID0gbGVmdC5yaWdodDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgICAgIG8gPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9tYXAuZ2V0KHRoaXMucGFyZW50U3ViKSB8fCBudWxsO1xuICAgICAgICAgIHdoaWxlIChvICE9PSBudWxsICYmIG8ubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbyA9IG8ubGVmdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbyA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX3N0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHVzZSBzb21ldGhpbmcgbGlrZSBEZWxldGVTZXQgaGVyZSAoYSB0cmVlIGltcGxlbWVudGF0aW9uIHdvdWxkIGJlIGJlc3QpXG4gICAgICAgIC8vIEB0b2RvIHVzZSBnbG9iYWwgc2V0IGRlZmluaXRpb25zXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7U2V0PEl0ZW0+fVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgY29uZmxpY3RpbmdJdGVtcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtTZXQ8SXRlbT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBpdGVtc0JlZm9yZU9yaWdpbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgLy8gTGV0IGMgaW4gY29uZmxpY3RpbmdJdGVtcywgYiBpbiBpdGVtc0JlZm9yZU9yaWdpblxuICAgICAgICAvLyAqKip7b3JpZ2lufWJiYmJ7dGhpc317YyxifXtjLGJ9e299KioqXG4gICAgICAgIC8vIE5vdGUgdGhhdCBjb25mbGljdGluZ0l0ZW1zIGlzIGEgc3Vic2V0IG9mIGl0ZW1zQmVmb3JlT3JpZ2luXG4gICAgICAgIHdoaWxlIChvICE9PSBudWxsICYmIG8gIT09IHRoaXMucmlnaHQpIHtcbiAgICAgICAgICBpdGVtc0JlZm9yZU9yaWdpbi5hZGQobyk7XG4gICAgICAgICAgY29uZmxpY3RpbmdJdGVtcy5hZGQobyk7XG4gICAgICAgICAgaWYgKGNvbXBhcmVJRHModGhpcy5vcmlnaW4sIG8ub3JpZ2luKSkge1xuICAgICAgICAgICAgLy8gY2FzZSAxXG4gICAgICAgICAgICBpZiAoby5pZC5jbGllbnQgPCB0aGlzLmlkLmNsaWVudCkge1xuICAgICAgICAgICAgICBsZWZ0ID0gbztcbiAgICAgICAgICAgICAgY29uZmxpY3RpbmdJdGVtcy5jbGVhcigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb21wYXJlSURzKHRoaXMucmlnaHRPcmlnaW4sIG8ucmlnaHRPcmlnaW4pKSB7XG4gICAgICAgICAgICAgIC8vIHRoaXMgYW5kIG8gYXJlIGNvbmZsaWN0aW5nIGFuZCBwb2ludCB0byB0aGUgc2FtZSBpbnRlZ3JhdGlvbiBwb2ludHMuIFRoZSBpZCBkZWNpZGVzIHdoaWNoIGl0ZW0gY29tZXMgZmlyc3QuXG4gICAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgdG8gdGhlIGxlZnQgb2Ygbywgd2UgY2FuIGJyZWFrIGhlcmVcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH0gLy8gZWxzZSwgbyBtaWdodCBiZSBpbnRlZ3JhdGVkIGJlZm9yZSBhbiBpdGVtIHRoYXQgdGhpcyBjb25mbGljdHMgd2l0aC4gSWYgc28sIHdlIHdpbGwgZmluZCBpdCBpbiB0aGUgbmV4dCBpdGVyYXRpb25zXG4gICAgICAgICAgfSBlbHNlIGlmIChvLm9yaWdpbiAhPT0gbnVsbCAmJiBpdGVtc0JlZm9yZU9yaWdpbi5oYXMoZ2V0SXRlbSh0cmFuc2FjdGlvbi5kb2Muc3RvcmUsIG8ub3JpZ2luKSkpIHsgLy8gdXNlIGdldEl0ZW0gaW5zdGVhZCBvZiBnZXRJdGVtQ2xlYW5FbmQgYmVjYXVzZSB3ZSBkb24ndCB3YW50IC8gbmVlZCB0byBzcGxpdCBpdGVtcy5cbiAgICAgICAgICAgIC8vIGNhc2UgMlxuICAgICAgICAgICAgaWYgKCFjb25mbGljdGluZ0l0ZW1zLmhhcyhnZXRJdGVtKHRyYW5zYWN0aW9uLmRvYy5zdG9yZSwgby5vcmlnaW4pKSkge1xuICAgICAgICAgICAgICBsZWZ0ID0gbztcbiAgICAgICAgICAgICAgY29uZmxpY3RpbmdJdGVtcy5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBvID0gby5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgfVxuICAgICAgLy8gcmVjb25uZWN0IGxlZnQvcmlnaHQgKyB1cGRhdGUgcGFyZW50IG1hcC9zdGFydCBpZiBuZWNlc3NhcnlcbiAgICAgIGlmICh0aGlzLmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLmxlZnQucmlnaHQ7XG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgdGhpcy5sZWZ0LnJpZ2h0ID0gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCByO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnRTdWIgIT09IG51bGwpIHtcbiAgICAgICAgICByID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fbWFwLmdldCh0aGlzLnBhcmVudFN1YikgfHwgbnVsbDtcbiAgICAgICAgICB3aGlsZSAociAhPT0gbnVsbCAmJiByLmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHIgPSByLmxlZnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHIgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9zdGFydFxuICAgICAgICAgIDsvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9zdGFydCA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yaWdodCA9IHI7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJpZ2h0LmxlZnQgPSB0aGlzO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgICAvLyBzZXQgYXMgY3VycmVudCBwYXJlbnQgdmFsdWUgaWYgcmlnaHQgPT09IG51bGwgYW5kIHRoaXMgaXMgcGFyZW50U3ViXG4gICAgICAgIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX21hcC5zZXQodGhpcy5wYXJlbnRTdWIsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyB0aGUgY3VycmVudCBhdHRyaWJ1dGUgdmFsdWUgb2YgcGFyZW50LiBkZWxldGUgcmlnaHRcbiAgICAgICAgICB0aGlzLmxlZnQuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gYWRqdXN0IGxlbmd0aCBvZiBwYXJlbnRcbiAgICAgIGlmICh0aGlzLnBhcmVudFN1YiA9PT0gbnVsbCAmJiB0aGlzLmNvdW50YWJsZSAmJiAhdGhpcy5kZWxldGVkKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX2xlbmd0aCArPSB0aGlzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGFkZFN0cnVjdCh0cmFuc2FjdGlvbi5kb2Muc3RvcmUsIHRoaXMpO1xuICAgICAgdGhpcy5jb250ZW50LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgdGhpcyk7XG4gICAgICAvLyBhZGQgcGFyZW50IHRvIHRyYW5zYWN0aW9uLmNoYW5nZWRcbiAgICAgIGFkZENoYW5nZWRUeXBlVG9UcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KSwgdGhpcy5wYXJlbnRTdWIpO1xuICAgICAgaWYgKCgvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9pdGVtICE9PSBudWxsICYmIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX2l0ZW0uZGVsZXRlZCkgfHwgKHRoaXMucGFyZW50U3ViICE9PSBudWxsICYmIHRoaXMucmlnaHQgIT09IG51bGwpKSB7XG4gICAgICAgIC8vIGRlbGV0ZSBpZiBwYXJlbnQgaXMgZGVsZXRlZCBvciBpZiB0aGlzIGlzIG5vdCB0aGUgY3VycmVudCBhdHRyaWJ1dGUgdmFsdWUgb2YgcGFyZW50XG4gICAgICAgIHRoaXMuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcGFyZW50IGlzIG5vdCBkZWZpbmVkLiBJbnRlZ3JhdGUgR0Mgc3RydWN0IGluc3RlYWRcbiAgICAgIG5ldyBHQyh0aGlzLmlkLCB0aGlzLmxlbmd0aCkuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbmV4dCBub24tZGVsZXRlZCBpdGVtXG4gICAqL1xuICBnZXQgbmV4dCAoKSB7XG4gICAgbGV0IG4gPSB0aGlzLnJpZ2h0O1xuICAgIHdoaWxlIChuICE9PSBudWxsICYmIG4uZGVsZXRlZCkge1xuICAgICAgbiA9IG4ucmlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBuXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJldmlvdXMgbm9uLWRlbGV0ZWQgaXRlbVxuICAgKi9cbiAgZ2V0IHByZXYgKCkge1xuICAgIGxldCBuID0gdGhpcy5sZWZ0O1xuICAgIHdoaWxlIChuICE9PSBudWxsICYmIG4uZGVsZXRlZCkge1xuICAgICAgbiA9IG4ubGVmdDtcbiAgICB9XG4gICAgcmV0dXJuIG5cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgbGFzdCBjb250ZW50IGFkZHJlc3Mgb2YgdGhpcyBJdGVtLlxuICAgKi9cbiAgZ2V0IGxhc3RJZCAoKSB7XG4gICAgLy8gYWxsb2NhdGluZyBpZHMgaXMgcHJldHR5IGNvc3RseSBiZWNhdXNlIG9mIHRoZSBhbW91bnQgb2YgaWRzIGNyZWF0ZWQsIHNvIHdlIHRyeSB0byByZXVzZSB3aGVuZXZlciBwb3NzaWJsZVxuICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSA/IHRoaXMuaWQgOiBjcmVhdGVJRCh0aGlzLmlkLmNsaWVudCwgdGhpcy5pZC5jbG9jayArIHRoaXMubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8qKlxuICAgKiBUcnkgdG8gbWVyZ2UgdHdvIGl0ZW1zXG4gICAqXG4gICAqIEBwYXJhbSB7SXRlbX0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID09PSByaWdodC5jb25zdHJ1Y3RvciAmJlxuICAgICAgY29tcGFyZUlEcyhyaWdodC5vcmlnaW4sIHRoaXMubGFzdElkKSAmJlxuICAgICAgdGhpcy5yaWdodCA9PT0gcmlnaHQgJiZcbiAgICAgIGNvbXBhcmVJRHModGhpcy5yaWdodE9yaWdpbiwgcmlnaHQucmlnaHRPcmlnaW4pICYmXG4gICAgICB0aGlzLmlkLmNsaWVudCA9PT0gcmlnaHQuaWQuY2xpZW50ICYmXG4gICAgICB0aGlzLmlkLmNsb2NrICsgdGhpcy5sZW5ndGggPT09IHJpZ2h0LmlkLmNsb2NrICYmXG4gICAgICB0aGlzLmRlbGV0ZWQgPT09IHJpZ2h0LmRlbGV0ZWQgJiZcbiAgICAgIHRoaXMucmVkb25lID09PSBudWxsICYmXG4gICAgICByaWdodC5yZWRvbmUgPT09IG51bGwgJiZcbiAgICAgIHRoaXMuY29udGVudC5jb25zdHJ1Y3RvciA9PT0gcmlnaHQuY29udGVudC5jb25zdHJ1Y3RvciAmJlxuICAgICAgdGhpcy5jb250ZW50Lm1lcmdlV2l0aChyaWdodC5jb250ZW50KVxuICAgICkge1xuICAgICAgY29uc3Qgc2VhcmNoTWFya2VyID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fc2VhcmNoTWFya2VyO1xuICAgICAgaWYgKHNlYXJjaE1hcmtlcikge1xuICAgICAgICBzZWFyY2hNYXJrZXIuZm9yRWFjaChtYXJrZXIgPT4ge1xuICAgICAgICAgIGlmIChtYXJrZXIucCA9PT0gcmlnaHQpIHtcbiAgICAgICAgICAgIC8vIHJpZ2h0IGlzIGdvaW5nIHRvIGJlIFwiZm9yZ290dGVuXCIgc28gd2UgbmVlZCB0byB1cGRhdGUgdGhlIG1hcmtlclxuICAgICAgICAgICAgbWFya2VyLnAgPSB0aGlzO1xuICAgICAgICAgICAgLy8gYWRqdXN0IG1hcmtlciBpbmRleFxuICAgICAgICAgICAgaWYgKCF0aGlzLmRlbGV0ZWQgJiYgdGhpcy5jb3VudGFibGUpIHtcbiAgICAgICAgICAgICAgbWFya2VyLmluZGV4IC09IHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAocmlnaHQua2VlcCkge1xuICAgICAgICB0aGlzLmtlZXAgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0LnJpZ2h0O1xuICAgICAgaWYgKHRoaXMucmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yaWdodC5sZWZ0ID0gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMubGVuZ3RoICs9IHJpZ2h0Lmxlbmd0aDtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIE1hcmsgdGhpcyBJdGVtIGFzIGRlbGV0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCk7XG4gICAgICAvLyBhZGp1c3QgdGhlIGxlbmd0aCBvZiBwYXJlbnRcbiAgICAgIGlmICh0aGlzLmNvdW50YWJsZSAmJiB0aGlzLnBhcmVudFN1YiA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnQuX2xlbmd0aCAtPSB0aGlzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHRoaXMubWFya0RlbGV0ZWQoKTtcbiAgICAgIGFkZFRvRGVsZXRlU2V0KHRyYW5zYWN0aW9uLmRlbGV0ZVNldCwgdGhpcy5pZC5jbGllbnQsIHRoaXMuaWQuY2xvY2ssIHRoaXMubGVuZ3RoKTtcbiAgICAgIGFkZENoYW5nZWRUeXBlVG9UcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgcGFyZW50LCB0aGlzLnBhcmVudFN1Yik7XG4gICAgICB0aGlzLmNvbnRlbnQuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICogQHBhcmFtIHtib29sZWFufSBwYXJlbnRHQ2RcbiAgICovXG4gIGdjIChzdG9yZSwgcGFyZW50R0NkKSB7XG4gICAgaWYgKCF0aGlzLmRlbGV0ZWQpIHtcbiAgICAgIHRocm93IGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbiAgICB9XG4gICAgdGhpcy5jb250ZW50LmdjKHN0b3JlKTtcbiAgICBpZiAocGFyZW50R0NkKSB7XG4gICAgICByZXBsYWNlU3RydWN0KHN0b3JlLCB0aGlzLCBuZXcgR0ModGhpcy5pZCwgdGhpcy5sZW5ndGgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250ZW50ID0gbmV3IENvbnRlbnREZWxldGVkKHRoaXMubGVuZ3RoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdHlwZSB0byBiaW5hcnkgYW5kIHdyaXRlIGl0IHRvIGFuXG4gICAqIEJpbmFyeUVuY29kZXIuXG4gICAqXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhpcyBJdGVtIGlzIHNlbnQgdG8gYSByZW1vdGUgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXIgVGhlIGVuY29kZXIgdG8gd3JpdGUgZGF0YSB0by5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGNvbnN0IG9yaWdpbiA9IG9mZnNldCA+IDAgPyBjcmVhdGVJRCh0aGlzLmlkLmNsaWVudCwgdGhpcy5pZC5jbG9jayArIG9mZnNldCAtIDEpIDogdGhpcy5vcmlnaW47XG4gICAgY29uc3QgcmlnaHRPcmlnaW4gPSB0aGlzLnJpZ2h0T3JpZ2luO1xuICAgIGNvbnN0IHBhcmVudFN1YiA9IHRoaXMucGFyZW50U3ViO1xuICAgIGNvbnN0IGluZm8gPSAodGhpcy5jb250ZW50LmdldFJlZigpICYgYmluYXJ5LkJJVFM1KSB8XG4gICAgICAob3JpZ2luID09PSBudWxsID8gMCA6IGJpbmFyeS5CSVQ4KSB8IC8vIG9yaWdpbiBpcyBkZWZpbmVkXG4gICAgICAocmlnaHRPcmlnaW4gPT09IG51bGwgPyAwIDogYmluYXJ5LkJJVDcpIHwgLy8gcmlnaHQgb3JpZ2luIGlzIGRlZmluZWRcbiAgICAgIChwYXJlbnRTdWIgPT09IG51bGwgPyAwIDogYmluYXJ5LkJJVDYpOyAvLyBwYXJlbnRTdWIgaXMgbm9uLW51bGxcbiAgICBlbmNvZGVyLndyaXRlSW5mbyhpbmZvKTtcbiAgICBpZiAob3JpZ2luICE9PSBudWxsKSB7XG4gICAgICBlbmNvZGVyLndyaXRlTGVmdElEKG9yaWdpbik7XG4gICAgfVxuICAgIGlmIChyaWdodE9yaWdpbiAhPT0gbnVsbCkge1xuICAgICAgZW5jb2Rlci53cml0ZVJpZ2h0SUQocmlnaHRPcmlnaW4pO1xuICAgIH1cbiAgICBpZiAob3JpZ2luID09PSBudWxsICYmIHJpZ2h0T3JpZ2luID09PSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpO1xuICAgICAgaWYgKHBhcmVudC5faXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEl0ZW0gPSBwYXJlbnQuX2l0ZW07XG4gICAgICAgIGlmIChwYXJlbnRJdGVtID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gcGFyZW50IHR5cGUgb24geS5fbWFwXG4gICAgICAgICAgLy8gZmluZCB0aGUgY29ycmVjdCBrZXlcbiAgICAgICAgICBjb25zdCB5a2V5ID0gZmluZFJvb3RUeXBlS2V5KHBhcmVudCk7XG4gICAgICAgICAgZW5jb2Rlci53cml0ZVBhcmVudEluZm8odHJ1ZSk7IC8vIHdyaXRlIHBhcmVudFlLZXlcbiAgICAgICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKHlrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuY29kZXIud3JpdGVQYXJlbnRJbmZvKGZhbHNlKTsgLy8gd3JpdGUgcGFyZW50IGlkXG4gICAgICAgICAgZW5jb2Rlci53cml0ZUxlZnRJRChwYXJlbnRJdGVtLmlkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJlbnQuY29uc3RydWN0b3IgPT09IFN0cmluZykgeyAvLyB0aGlzIGVkZ2UgY2FzZSB3YXMgYWRkZWQgYnkgZGlmZmVyZW50aWFsIHVwZGF0ZXNcbiAgICAgICAgZW5jb2Rlci53cml0ZVBhcmVudEluZm8odHJ1ZSk7IC8vIHdyaXRlIHBhcmVudFlLZXlcbiAgICAgICAgZW5jb2Rlci53cml0ZVN0cmluZyhwYXJlbnQpO1xuICAgICAgfSBlbHNlIGlmIChwYXJlbnQuY29uc3RydWN0b3IgPT09IElEKSB7XG4gICAgICAgIGVuY29kZXIud3JpdGVQYXJlbnRJbmZvKGZhbHNlKTsgLy8gd3JpdGUgcGFyZW50IGlkXG4gICAgICAgIGVuY29kZXIud3JpdGVMZWZ0SUQocGFyZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yLnVuZXhwZWN0ZWRDYXNlKCk7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50U3ViICE9PSBudWxsKSB7XG4gICAgICAgIGVuY29kZXIud3JpdGVTdHJpbmcocGFyZW50U3ViKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb250ZW50LndyaXRlKGVuY29kZXIsIG9mZnNldCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IGluZm9cbiAqL1xuY29uc3QgcmVhZEl0ZW1Db250ZW50ID0gKGRlY29kZXIsIGluZm8pID0+IGNvbnRlbnRSZWZzW2luZm8gJiBiaW5hcnkuQklUUzVdKGRlY29kZXIpO1xuXG4vKipcbiAqIEEgbG9va3VwIG1hcCBmb3IgcmVhZGluZyBJdGVtIGNvbnRlbnQuXG4gKlxuICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKFVwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMik6QWJzdHJhY3RDb250ZW50Pn1cbiAqL1xuY29uc3QgY29udGVudFJlZnMgPSBbXG4gICgpID0+IHsgZXJyb3IudW5leHBlY3RlZENhc2UoKTsgfSwgLy8gR0MgaXMgbm90IEl0ZW1Db250ZW50XG4gIHJlYWRDb250ZW50RGVsZXRlZCwgLy8gMVxuICByZWFkQ29udGVudEpTT04sIC8vIDJcbiAgcmVhZENvbnRlbnRCaW5hcnksIC8vIDNcbiAgcmVhZENvbnRlbnRTdHJpbmcsIC8vIDRcbiAgcmVhZENvbnRlbnRFbWJlZCwgLy8gNVxuICByZWFkQ29udGVudEZvcm1hdCwgLy8gNlxuICByZWFkQ29udGVudFR5cGUsIC8vIDdcbiAgcmVhZENvbnRlbnRBbnksIC8vIDhcbiAgcmVhZENvbnRlbnREb2MsIC8vIDlcbiAgKCkgPT4geyBlcnJvci51bmV4cGVjdGVkQ2FzZSgpOyB9IC8vIDEwIC0gU2tpcCBpcyBub3QgSXRlbUNvbnRlbnRcbl07XG5cbmNvbnN0IHN0cnVjdFNraXBSZWZOdW1iZXIgPSAxMDtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBTa2lwIGV4dGVuZHMgQWJzdHJhY3RTdHJ1Y3Qge1xuICBnZXQgZGVsZXRlZCAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGRlbGV0ZSAoKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1NraXB9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgIT09IHJpZ2h0LmNvbnN0cnVjdG9yKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgdGhpcy5sZW5ndGggKz0gcmlnaHQubGVuZ3RoO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgb2Zmc2V0KSB7XG4gICAgLy8gc2tpcCBzdHJ1Y3RzIGNhbm5vdCBiZSBpbnRlZ3JhdGVkXG4gICAgZXJyb3IudW5leHBlY3RlZENhc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUluZm8oc3RydWN0U2tpcFJlZk51bWJlcik7XG4gICAgLy8gd3JpdGUgYXMgVmFyVWludCBiZWNhdXNlIFNraXBzIGNhbid0IG1ha2UgdXNlIG9mIHByZWRpY3RhYmxlIGxlbmd0aC1lbmNvZGluZ1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCB0aGlzLmxlbmd0aCAtIG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICogQHJldHVybiB7bnVsbCB8IG51bWJlcn1cbiAgICovXG4gIGdldE1pc3NpbmcgKHRyYW5zYWN0aW9uLCBzdG9yZSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuLyoqIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG5cbmNvbnN0IGdsbyA9IC8qKiBAdHlwZSB7YW55fSAqLyAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXG4gID8gZ2xvYmFsVGhpc1xuICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgPyB3aW5kb3dcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHt9KTtcblxuY29uc3QgaW1wb3J0SWRlbnRpZmllciA9ICdfXyAkWUpTJCBfXyc7XG5cbmlmIChnbG9baW1wb3J0SWRlbnRpZmllcl0gPT09IHRydWUpIHtcbiAgLyoqXG4gICAqIERlYXIgcmVhZGVyIG9mIHRoaXMgbWVzc2FnZS4gUGxlYXNlIHRha2UgdGhpcyBzZXJpb3VzbHkuXG4gICAqXG4gICAqIElmIHlvdSBzZWUgdGhpcyBtZXNzYWdlLCBtYWtlIHN1cmUgdGhhdCB5b3Ugb25seSBpbXBvcnQgb25lIHZlcnNpb24gb2YgWWpzLiBJbiBtYW55IGNhc2VzLFxuICAgKiB5b3VyIHBhY2thZ2UgbWFuYWdlciBpbnN0YWxscyB0d28gdmVyc2lvbnMgb2YgWWpzIHRoYXQgYXJlIHVzZWQgYnkgZGlmZmVyZW50IHBhY2thZ2VzIHdpdGhpbiB5b3VyIHByb2plY3QuXG4gICAqIEFub3RoZXIgcmVhc29uIGZvciB0aGlzIG1lc3NhZ2UgaXMgdGhhdCBzb21lIHBhcnRzIG9mIHlvdXIgcHJvamVjdCB1c2UgdGhlIGNvbW1vbmpzIHZlcnNpb24gb2YgWWpzXG4gICAqIGFuZCBvdGhlcnMgdXNlIHRoZSBFY21hU2NyaXB0IHZlcnNpb24gb2YgWWpzLlxuICAgKlxuICAgKiBUaGlzIG9mdGVuIGxlYWRzIHRvIGlzc3VlcyB0aGF0IGFyZSBoYXJkIHRvIGRlYnVnLiBXZSBvZnRlbiBuZWVkIHRvIHBlcmZvcm0gY29uc3RydWN0b3IgY2hlY2tzLFxuICAgKiBlLmcuIGBzdHJ1Y3QgaW5zdGFuY2VvZiBHQ2AuIElmIHlvdSBpbXBvcnRlZCBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgWWpzLCBpdCBpcyBpbXBvc3NpYmxlIGZvciB1cyB0b1xuICAgKiBkbyB0aGUgY29uc3RydWN0b3IgY2hlY2tzIGFueW1vcmUgLSB3aGljaCBtaWdodCBicmVhayB0aGUgQ1JEVCBhbGdvcml0aG0uXG4gICAqXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS95anMveWpzL2lzc3Vlcy80MzhcbiAgICovXG4gIGNvbnNvbGUuZXJyb3IoJ1lqcyB3YXMgYWxyZWFkeSBpbXBvcnRlZC4gVGhpcyBicmVha3MgY29uc3RydWN0b3IgY2hlY2tzIGFuZCB3aWxsIGxlYWQgdG8gaXNzdWVzISAtIGh0dHBzOi8vZ2l0aHViLmNvbS95anMveWpzL2lzc3Vlcy80MzgnKTtcbn1cbmdsb1tpbXBvcnRJZGVudGlmaWVyXSA9IHRydWU7XG5cbmV4cG9ydCB7IEFic29sdXRlUG9zaXRpb24sIEFic3RyYWN0Q29ubmVjdG9yLCBBYnN0cmFjdFN0cnVjdCwgQWJzdHJhY3RUeXBlLCBZQXJyYXkgYXMgQXJyYXksIENvbnRlbnRBbnksIENvbnRlbnRCaW5hcnksIENvbnRlbnREZWxldGVkLCBDb250ZW50RG9jLCBDb250ZW50RW1iZWQsIENvbnRlbnRGb3JtYXQsIENvbnRlbnRKU09OLCBDb250ZW50U3RyaW5nLCBDb250ZW50VHlwZSwgRG9jLCBHQywgSUQsIEl0ZW0sIFlNYXAgYXMgTWFwLCBQZXJtYW5lbnRVc2VyRGF0YSwgUmVsYXRpdmVQb3NpdGlvbiwgU2tpcCwgU25hcHNob3QsIFlUZXh0IGFzIFRleHQsIFRyYW5zYWN0aW9uLCBVbmRvTWFuYWdlciwgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBZWG1sRWxlbWVudCBhcyBYbWxFbGVtZW50LCBZWG1sRnJhZ21lbnQgYXMgWG1sRnJhZ21lbnQsIFlYbWxIb29rIGFzIFhtbEhvb2ssIFlYbWxUZXh0IGFzIFhtbFRleHQsIFlBcnJheUV2ZW50LCBZRXZlbnQsIFlNYXBFdmVudCwgWVRleHRFdmVudCwgWVhtbEV2ZW50LCBhcHBseVVwZGF0ZSwgYXBwbHlVcGRhdGVWMiwgY2xlYW51cFlUZXh0Rm9ybWF0dGluZywgY29tcGFyZUlEcywgY29tcGFyZVJlbGF0aXZlUG9zaXRpb25zLCBjb252ZXJ0VXBkYXRlRm9ybWF0VjFUb1YyLCBjb252ZXJ0VXBkYXRlRm9ybWF0VjJUb1YxLCBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24sIGNyZWF0ZURlbGV0ZVNldCwgY3JlYXRlRGVsZXRlU2V0RnJvbVN0cnVjdFN0b3JlLCBjcmVhdGVEb2NGcm9tU25hcHNob3QsIGNyZWF0ZUlELCBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04sIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4LCBjcmVhdGVTbmFwc2hvdCwgZGVjb2RlUmVsYXRpdmVQb3NpdGlvbiwgZGVjb2RlU25hcHNob3QsIGRlY29kZVNuYXBzaG90VjIsIGRlY29kZVN0YXRlVmVjdG9yLCBkZWNvZGVVcGRhdGUsIGRlY29kZVVwZGF0ZVYyLCBkaWZmVXBkYXRlLCBkaWZmVXBkYXRlVjIsIGVtcHR5U25hcHNob3QsIGVuY29kZVJlbGF0aXZlUG9zaXRpb24sIGVuY29kZVNuYXBzaG90LCBlbmNvZGVTbmFwc2hvdFYyLCBlbmNvZGVTdGF0ZUFzVXBkYXRlLCBlbmNvZGVTdGF0ZUFzVXBkYXRlVjIsIGVuY29kZVN0YXRlVmVjdG9yLCBlbmNvZGVTdGF0ZVZlY3RvckZyb21VcGRhdGUsIGVuY29kZVN0YXRlVmVjdG9yRnJvbVVwZGF0ZVYyLCBlcXVhbERlbGV0ZVNldHMsIGVxdWFsU25hcHNob3RzLCBmaW5kSW5kZXhTUywgZmluZFJvb3RUeXBlS2V5LCBnZXRJdGVtLCBnZXRJdGVtQ2xlYW5FbmQsIGdldEl0ZW1DbGVhblN0YXJ0LCBnZXRTdGF0ZSwgZ2V0VHlwZUNoaWxkcmVuLCBpc0RlbGV0ZWQsIGlzUGFyZW50T2YsIGl0ZXJhdGVEZWxldGVkU3RydWN0cywgbG9nVHlwZSwgbG9nVXBkYXRlLCBsb2dVcGRhdGVWMiwgbWVyZ2VEZWxldGVTZXRzLCBtZXJnZVVwZGF0ZXMsIG1lcmdlVXBkYXRlc1YyLCBvYmZ1c2NhdGVVcGRhdGUsIG9iZnVzY2F0ZVVwZGF0ZVYyLCBwYXJzZVVwZGF0ZU1ldGEsIHBhcnNlVXBkYXRlTWV0YVYyLCByZWFkVXBkYXRlLCByZWFkVXBkYXRlVjIsIHJlbGF0aXZlUG9zaXRpb25Ub0pTT04sIHNuYXBzaG90LCBzbmFwc2hvdENvbnRhaW5zVXBkYXRlLCB0cmFuc2FjdCwgdHJ5R2MsIHR5cGVMaXN0VG9BcnJheVNuYXBzaG90LCB0eXBlTWFwR2V0QWxsU25hcHNob3QsIHR5cGVNYXBHZXRTbmFwc2hvdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eWpzLm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJPYnNlcnZhYmxlVjIiLCJhcnJheSIsIm1hdGgiLCJtYXAiLCJlbmNvZGluZyIsImRlY29kaW5nIiwicmFuZG9tIiwicHJvbWlzZSIsImJ1ZmZlciIsImVycm9yIiwiYmluYXJ5IiwiZiIsImNhbGxBbGwiLCJzZXQiLCJsb2dnaW5nIiwidGltZSIsInN0cmluZyIsIml0ZXJhdG9yIiwib2JqZWN0IiwiZW52IiwiQWJzdHJhY3RDb25uZWN0b3IiLCJjb25zdHJ1Y3RvciIsInlkb2MiLCJhd2FyZW5lc3MiLCJkb2MiLCJEZWxldGVJdGVtIiwiY2xvY2siLCJsZW4iLCJEZWxldGVTZXQiLCJjbGllbnRzIiwiTWFwIiwiaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzIiwidHJhbnNhY3Rpb24iLCJkcyIsImZvckVhY2giLCJkZWxldGVzIiwiY2xpZW50aWQiLCJzdHJ1Y3RzIiwic3RvcmUiLCJnZXQiLCJsYXN0U3RydWN0IiwibGVuZ3RoIiwiY2xvY2tTdGF0ZSIsImlkIiwiaSIsImRlbCIsIml0ZXJhdGVTdHJ1Y3RzIiwiZmluZEluZGV4RFMiLCJkaXMiLCJsZWZ0IiwicmlnaHQiLCJtaWRpbmRleCIsImZsb29yIiwibWlkIiwibWlkY2xvY2siLCJpc0RlbGV0ZWQiLCJjbGllbnQiLCJ1bmRlZmluZWQiLCJzb3J0QW5kTWVyZ2VEZWxldGVTZXQiLCJkZWxzIiwic29ydCIsImEiLCJiIiwiaiIsIm1heCIsIm1lcmdlRGVsZXRlU2V0cyIsImRzcyIsIm1lcmdlZCIsImRzc0kiLCJkZWxzTGVmdCIsImhhcyIsInNsaWNlIiwiYXBwZW5kVG8iLCJhZGRUb0RlbGV0ZVNldCIsInNldElmVW5kZWZpbmVkIiwicHVzaCIsImNyZWF0ZURlbGV0ZVNldCIsImNyZWF0ZURlbGV0ZVNldEZyb21TdHJ1Y3RTdG9yZSIsInNzIiwiZHNpdGVtcyIsInN0cnVjdCIsImRlbGV0ZWQiLCJuZXh0Iiwid3JpdGVEZWxldGVTZXQiLCJlbmNvZGVyIiwid3JpdGVWYXJVaW50IiwicmVzdEVuY29kZXIiLCJzaXplIiwiZnJvbSIsImVudHJpZXMiLCJyZXNldERzQ3VyVmFsIiwiaXRlbSIsIndyaXRlRHNDbG9jayIsIndyaXRlRHNMZW4iLCJyZWFkRGVsZXRlU2V0IiwiZGVjb2RlciIsIm51bUNsaWVudHMiLCJyZWFkVmFyVWludCIsInJlc3REZWNvZGVyIiwibnVtYmVyT2ZEZWxldGVzIiwiZHNGaWVsZCIsInJlYWREc0Nsb2NrIiwicmVhZERzTGVuIiwicmVhZEFuZEFwcGx5RGVsZXRlU2V0IiwidW5hcHBsaWVkRFMiLCJzdGF0ZSIsImdldFN0YXRlIiwiY2xvY2tFbmQiLCJpbmRleCIsImZpbmRJbmRleFNTIiwic3BsaWNlIiwic3BsaXRJdGVtIiwiZGVsZXRlIiwiVXBkYXRlRW5jb2RlclYyIiwidG9VaW50OEFycmF5IiwiZXF1YWxEZWxldGVTZXRzIiwiZHMxIiwiZHMyIiwiZGVsZXRlSXRlbXMxIiwiZGVsZXRlSXRlbXMyIiwiZGkxIiwiZGkyIiwiZ2VuZXJhdGVOZXdDbGllbnRJZCIsInVpbnQzMiIsIkRvYyIsImd1aWQiLCJ1dWlkdjQiLCJjb2xsZWN0aW9uaWQiLCJnYyIsImdjRmlsdGVyIiwibWV0YSIsImF1dG9Mb2FkIiwic2hvdWxkTG9hZCIsImNsaWVudElEIiwic2hhcmUiLCJTdHJ1Y3RTdG9yZSIsIl90cmFuc2FjdGlvbiIsIl90cmFuc2FjdGlvbkNsZWFudXBzIiwic3ViZG9jcyIsIlNldCIsIl9pdGVtIiwiaXNMb2FkZWQiLCJpc1N5bmNlZCIsImlzRGVzdHJveWVkIiwid2hlbkxvYWRlZCIsImNyZWF0ZSIsInJlc29sdmUiLCJvbiIsInByb3ZpZGVTeW5jZWRQcm9taXNlIiwiZXZlbnRIYW5kbGVyIiwib2ZmIiwid2hlblN5bmNlZCIsImVtaXQiLCJsb2FkIiwidHJhbnNhY3QiLCJwYXJlbnQiLCJzdWJkb2NzTG9hZGVkIiwiYWRkIiwiZ2V0U3ViZG9jcyIsImdldFN1YmRvY0d1aWRzIiwib3JpZ2luIiwibmFtZSIsIlR5cGVDb25zdHJ1Y3RvciIsIkFic3RyYWN0VHlwZSIsInR5cGUiLCJ0IiwiX2ludGVncmF0ZSIsIkNvbnN0ciIsIl9tYXAiLCJuIiwiX3N0YXJ0IiwiX2xlbmd0aCIsIkVycm9yIiwiZ2V0QXJyYXkiLCJZQXJyYXkiLCJnZXRUZXh0IiwiWVRleHQiLCJnZXRNYXAiLCJZTWFwIiwiZ2V0WG1sRWxlbWVudCIsIllYbWxFbGVtZW50IiwiZ2V0WG1sRnJhZ21lbnQiLCJZWG1sRnJhZ21lbnQiLCJ0b0pTT04iLCJ2YWx1ZSIsImtleSIsImRlc3Ryb3kiLCJzdWJkb2MiLCJjb250ZW50Iiwib3B0cyIsInN1YmRvY3NBZGRlZCIsInN1YmRvY3NSZW1vdmVkIiwiRFNEZWNvZGVyVjEiLCJVcGRhdGVEZWNvZGVyVjEiLCJyZWFkTGVmdElEIiwiY3JlYXRlSUQiLCJyZWFkUmlnaHRJRCIsInJlYWRDbGllbnQiLCJyZWFkSW5mbyIsInJlYWRVaW50OCIsInJlYWRTdHJpbmciLCJyZWFkVmFyU3RyaW5nIiwicmVhZFBhcmVudEluZm8iLCJyZWFkVHlwZVJlZiIsInJlYWRMZW4iLCJyZWFkQW55IiwicmVhZEJ1ZiIsImNvcHlVaW50OEFycmF5IiwicmVhZFZhclVpbnQ4QXJyYXkiLCJyZWFkSlNPTiIsIkpTT04iLCJwYXJzZSIsInJlYWRLZXkiLCJEU0RlY29kZXJWMiIsImRzQ3VyclZhbCIsImRpZmYiLCJVcGRhdGVEZWNvZGVyVjIiLCJrZXlzIiwia2V5Q2xvY2tEZWNvZGVyIiwiSW50RGlmZk9wdFJsZURlY29kZXIiLCJjbGllbnREZWNvZGVyIiwiVWludE9wdFJsZURlY29kZXIiLCJsZWZ0Q2xvY2tEZWNvZGVyIiwicmlnaHRDbG9ja0RlY29kZXIiLCJpbmZvRGVjb2RlciIsIlJsZURlY29kZXIiLCJzdHJpbmdEZWNvZGVyIiwiU3RyaW5nRGVjb2RlciIsInBhcmVudEluZm9EZWNvZGVyIiwidHlwZVJlZkRlY29kZXIiLCJsZW5EZWNvZGVyIiwiSUQiLCJyZWFkIiwia2V5Q2xvY2siLCJEU0VuY29kZXJWMSIsImNyZWF0ZUVuY29kZXIiLCJVcGRhdGVFbmNvZGVyVjEiLCJ3cml0ZUxlZnRJRCIsIndyaXRlUmlnaHRJRCIsIndyaXRlQ2xpZW50Iiwid3JpdGVJbmZvIiwiaW5mbyIsIndyaXRlVWludDgiLCJ3cml0ZVN0cmluZyIsInMiLCJ3cml0ZVZhclN0cmluZyIsIndyaXRlUGFyZW50SW5mbyIsImlzWUtleSIsIndyaXRlVHlwZVJlZiIsIndyaXRlTGVuIiwid3JpdGVBbnkiLCJhbnkiLCJ3cml0ZUJ1ZiIsImJ1ZiIsIndyaXRlVmFyVWludDhBcnJheSIsIndyaXRlSlNPTiIsImVtYmVkIiwic3RyaW5naWZ5Iiwid3JpdGVLZXkiLCJEU0VuY29kZXJWMiIsInVuZXhwZWN0ZWRDYXNlIiwia2V5TWFwIiwia2V5Q2xvY2tFbmNvZGVyIiwiSW50RGlmZk9wdFJsZUVuY29kZXIiLCJjbGllbnRFbmNvZGVyIiwiVWludE9wdFJsZUVuY29kZXIiLCJsZWZ0Q2xvY2tFbmNvZGVyIiwicmlnaHRDbG9ja0VuY29kZXIiLCJpbmZvRW5jb2RlciIsIlJsZUVuY29kZXIiLCJzdHJpbmdFbmNvZGVyIiwiU3RyaW5nRW5jb2RlciIsInBhcmVudEluZm9FbmNvZGVyIiwidHlwZVJlZkVuY29kZXIiLCJsZW5FbmNvZGVyIiwid3JpdGVVaW50OEFycmF5Iiwid3JpdGUiLCJ3cml0ZVN0cnVjdHMiLCJzdGFydE5ld1N0cnVjdHMiLCJmaXJzdFN0cnVjdCIsIndyaXRlQ2xpZW50c1N0cnVjdHMiLCJfc20iLCJzbSIsImdldFN0YXRlVmVjdG9yIiwiX2Nsb2NrIiwicmVhZENsaWVudHNTdHJ1Y3RSZWZzIiwiY2xpZW50UmVmcyIsIm51bU9mU3RhdGVVcGRhdGVzIiwibnVtYmVyT2ZTdHJ1Y3RzIiwicmVmcyIsIkFycmF5IiwiQklUUzUiLCJHQyIsIlNraXAiLCJjYW50Q29weVBhcmVudEluZm8iLCJCSVQ3IiwiQklUOCIsIkl0ZW0iLCJCSVQ2IiwicmVhZEl0ZW1Db250ZW50IiwiaW50ZWdyYXRlU3RydWN0cyIsImNsaWVudHNTdHJ1Y3RSZWZzIiwic3RhY2siLCJjbGllbnRzU3RydWN0UmVmc0lkcyIsImdldE5leHRTdHJ1Y3RUYXJnZXQiLCJuZXh0U3RydWN0c1RhcmdldCIsInBvcCIsImN1clN0cnVjdHNUYXJnZXQiLCJyZXN0U3RydWN0cyIsIm1pc3NpbmdTViIsInVwZGF0ZU1pc3NpbmdTdiIsIm1jbG9jayIsInN0YWNrSGVhZCIsImFkZFN0YWNrVG9SZXN0U1MiLCJpbmFwcGxpY2FibGVJdGVtcyIsImZpbHRlciIsImMiLCJsb2NhbENsb2NrIiwib2Zmc2V0IiwibWlzc2luZyIsImdldE1pc3NpbmciLCJzdHJ1Y3RSZWZzIiwiaW50ZWdyYXRlIiwidXBkYXRlIiwid3JpdGVTdHJ1Y3RzRnJvbVRyYW5zYWN0aW9uIiwiYmVmb3JlU3RhdGUiLCJyZWFkVXBkYXRlVjIiLCJ0cmFuc2FjdGlvbk9yaWdpbiIsInN0cnVjdERlY29kZXIiLCJsb2NhbCIsInJldHJ5IiwicGVuZGluZyIsInBlbmRpbmdTdHJ1Y3RzIiwibWVyZ2VVcGRhdGVzVjIiLCJkc1Jlc3QiLCJwZW5kaW5nRHMiLCJwZW5kaW5nRFNVcGRhdGUiLCJjcmVhdGVEZWNvZGVyIiwiZHNSZXN0MiIsImFwcGx5VXBkYXRlVjIiLCJyZWFkVXBkYXRlIiwiWURlY29kZXIiLCJhcHBseVVwZGF0ZSIsIndyaXRlU3RhdGVBc1VwZGF0ZSIsInRhcmdldFN0YXRlVmVjdG9yIiwiZW5jb2RlU3RhdGVBc1VwZGF0ZVYyIiwiZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yIiwiVWludDhBcnJheSIsImRlY29kZVN0YXRlVmVjdG9yIiwidXBkYXRlcyIsImRpZmZVcGRhdGVWMiIsIm1lcmdlVXBkYXRlcyIsImNvbnZlcnRVcGRhdGVGb3JtYXRWMlRvVjEiLCJlbmNvZGVTdGF0ZUFzVXBkYXRlIiwicmVhZFN0YXRlVmVjdG9yIiwic3NMZW5ndGgiLCJkZWNvZGVkU3RhdGUiLCJ3cml0ZVN0YXRlVmVjdG9yIiwic3YiLCJ3cml0ZURvY3VtZW50U3RhdGVWZWN0b3IiLCJlbmNvZGVTdGF0ZVZlY3RvclYyIiwiZW5jb2RlU3RhdGVWZWN0b3IiLCJFdmVudEhhbmRsZXIiLCJsIiwiY3JlYXRlRXZlbnRIYW5kbGVyIiwiYWRkRXZlbnRIYW5kbGVyTGlzdGVuZXIiLCJyZW1vdmVFdmVudEhhbmRsZXJMaXN0ZW5lciIsImciLCJjb25zb2xlIiwiY2FsbEV2ZW50SGFuZGxlckxpc3RlbmVycyIsImFyZzAiLCJhcmcxIiwiY29tcGFyZUlEcyIsIndyaXRlSUQiLCJyZWFkSUQiLCJmaW5kUm9vdFR5cGVLZXkiLCJpc1BhcmVudE9mIiwiY2hpbGQiLCJsb2dUeXBlIiwicmVzIiwibG9nIiwibSIsIlBlcm1hbmVudFVzZXJEYXRhIiwic3RvcmVUeXBlIiwieXVzZXJzIiwiaW5pdFVzZXIiLCJ1c2VyIiwidXNlckRlc2NyaXB0aW9uIiwiaWRzIiwiYWRkQ2xpZW50SWQiLCJvYnNlcnZlIiwiZXZlbnQiLCJjaGFuZ2VzIiwiYWRkZWQiLCJnZXRDb250ZW50IiwiZW5jb2RlZERzIiwia2V5c0NoYW5nZWQiLCJzZXRVc2VyTWFwcGluZyIsInVzZXJzIiwiX2V2ZW50Iiwic2V0VGltZW91dCIsInVzZXJPdmVyd3JpdGUiLCJfdXNlckRlc2NyaXB0aW9uIiwieWRzIiwiZGVsZXRlU2V0IiwiZ2V0VXNlckJ5Q2xpZW50SWQiLCJnZXRVc2VyQnlEZWxldGVkSWQiLCJSZWxhdGl2ZVBvc2l0aW9uIiwidG5hbWUiLCJhc3NvYyIsInJlbGF0aXZlUG9zaXRpb25Ub0pTT04iLCJycG9zIiwianNvbiIsImNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTiIsIkFic29sdXRlUG9zaXRpb24iLCJjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uIiwiY3JlYXRlUmVsYXRpdmVQb3NpdGlvbiIsInR5cGVpZCIsImNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4IiwiY291bnRhYmxlIiwibGFzdElkIiwid3JpdGVSZWxhdGl2ZVBvc2l0aW9uIiwid3JpdGVWYXJJbnQiLCJlbmNvZGVSZWxhdGl2ZVBvc2l0aW9uIiwicmVhZFJlbGF0aXZlUG9zaXRpb24iLCJpdGVtSUQiLCJoYXNDb250ZW50IiwicmVhZFZhckludCIsImRlY29kZVJlbGF0aXZlUG9zaXRpb24iLCJ1aW50OEFycmF5IiwiZ2V0SXRlbVdpdGhPZmZzZXQiLCJnZXRJdGVtIiwiY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uIiwiZm9sbG93VW5kb25lRGVsZXRpb25zIiwicmlnaHRJRCIsInR5cGVJRCIsImZvbGxvd1JlZG9uZSIsIkNvbnRlbnRUeXBlIiwiY29tcGFyZVJlbGF0aXZlUG9zaXRpb25zIiwiU25hcHNob3QiLCJlcXVhbFNuYXBzaG90cyIsInNuYXAxIiwic25hcDIiLCJzdjEiLCJzdjIiLCJkc2l0ZW1zMSIsImRzaXRlbXMyIiwiZHNpdGVtMSIsImRzaXRlbTIiLCJlbmNvZGVTbmFwc2hvdFYyIiwic25hcHNob3QiLCJlbmNvZGVTbmFwc2hvdCIsImRlY29kZVNuYXBzaG90VjIiLCJkZWNvZGVTbmFwc2hvdCIsImNyZWF0ZVNuYXBzaG90IiwiZW1wdHlTbmFwc2hvdCIsImlzVmlzaWJsZSIsInNwbGl0U25hcHNob3RBZmZlY3RlZFN0cnVjdHMiLCJnZXRJdGVtQ2xlYW5TdGFydCIsImNyZWF0ZURvY0Zyb21TbmFwc2hvdCIsIm9yaWdpbkRvYyIsIm5ld0RvYyIsImxhc3RTdHJ1Y3RJbmRleCIsInNuYXBzaG90Q29udGFpbnNVcGRhdGVWMiIsInVwZGF0ZURlY29kZXIiLCJsYXp5RGVjb2RlciIsIkxhenlTdHJ1Y3RSZWFkZXIiLCJjdXJyIiwibWVyZ2VkRFMiLCJzbmFwc2hvdENvbnRhaW5zVXBkYXRlIiwiYWRkU3RydWN0IiwiZmluZCIsImZpbmRJbmRleENsZWFuU3RhcnQiLCJnZXRJdGVtQ2xlYW5FbmQiLCJyZXBsYWNlU3RydWN0IiwibmV3U3RydWN0IiwiY2xvY2tTdGFydCIsIlRyYW5zYWN0aW9uIiwiYWZ0ZXJTdGF0ZSIsImNoYW5nZWQiLCJjaGFuZ2VkUGFyZW50VHlwZXMiLCJfbWVyZ2VTdHJ1Y3RzIiwiX25lZWRGb3JtYXR0aW5nQ2xlYW51cCIsIndyaXRlVXBkYXRlTWVzc2FnZUZyb21UcmFuc2FjdGlvbiIsImFkZENoYW5nZWRUeXBlVG9UcmFuc2FjdGlvbiIsInBhcmVudFN1YiIsInRyeVRvTWVyZ2VXaXRoTGVmdHMiLCJwb3MiLCJtZXJnZVdpdGgiLCJ0cnlHY0RlbGV0ZVNldCIsImRlbGV0ZUl0ZW1zIiwiZGkiLCJkZWxldGVJdGVtIiwiZW5kRGVsZXRlSXRlbUNsb2NrIiwic2kiLCJrZWVwIiwidHJ5TWVyZ2VEZWxldGVTZXQiLCJtb3N0UmlnaHRJbmRleFRvQ2hlY2siLCJtaW4iLCJ0cnlHYyIsImNsZWFudXBUcmFuc2FjdGlvbnMiLCJ0cmFuc2FjdGlvbkNsZWFudXBzIiwibWVyZ2VTdHJ1Y3RzIiwiZnMiLCJzdWJzIiwiaXRlbXR5cGUiLCJfY2FsbE9ic2VydmVyIiwiZXZlbnRzIiwiX2RFSCIsInRhcmdldCIsImN1cnJlbnRUYXJnZXQiLCJfcGF0aCIsImV2ZW50MSIsImV2ZW50MiIsInBhdGgiLCJjbGVhbnVwWVRleHRBZnRlclRyYW5zYWN0aW9uIiwiYmVmb3JlQ2xvY2siLCJmaXJzdENoYW5nZVBvcyIsInJlcGxhY2VkU3RydWN0UG9zIiwicHJpbnQiLCJPUkFOR0UiLCJCT0xEIiwiVU5CT0xEIiwiUkVEIiwiX29ic2VydmVycyIsImxvYWRlZCIsInJlbW92ZWQiLCJpbml0aWFsQ2FsbCIsInJlc3VsdCIsImZpbmlzaENsZWFudXAiLCJTdGFja0l0ZW0iLCJkZWxldGlvbnMiLCJpbnNlcnRpb25zIiwiY2xlYXJVbmRvTWFuYWdlclN0YWNrSXRlbSIsInRyIiwidW0iLCJzdGFja0l0ZW0iLCJzY29wZSIsInNvbWUiLCJrZWVwSXRlbSIsInBvcFN0YWNrSXRlbSIsInVuZG9NYW5hZ2VyIiwiZXZlbnRUeXBlIiwiX3RyIiwiY3VyclN0YWNrSXRlbSIsIml0ZW1zVG9SZWRvIiwiaXRlbXNUb0RlbGV0ZSIsInBlcmZvcm1lZENoYW5nZSIsInJlZG9uZSIsInJlZG9JdGVtIiwiaWdub3JlUmVtb3RlTWFwQ2hhbmdlcyIsImRlbGV0ZUZpbHRlciIsInN1YlByb3BzIiwiX3NlYXJjaE1hcmtlciIsIlVuZG9NYW5hZ2VyIiwidHlwZVNjb3BlIiwiY2FwdHVyZVRpbWVvdXQiLCJjYXB0dXJlVHJhbnNhY3Rpb24iLCJ0cmFja2VkT3JpZ2lucyIsImlzQXJyYXkiLCJhZGRUb1Njb3BlIiwidW5kb1N0YWNrIiwicmVkb1N0YWNrIiwidW5kb2luZyIsInJlZG9pbmciLCJsYXN0Q2hhbmdlIiwiYWZ0ZXJUcmFuc2FjdGlvbkhhbmRsZXIiLCJzdG9wQ2FwdHVyaW5nIiwiY2xlYXIiLCJlbmRDbG9jayIsInN0YXJ0Q2xvY2siLCJub3ciLCJnZXRVbml4VGltZSIsImRpZEFkZCIsImxhc3RPcCIsImNoYW5nZUV2ZW50IiwieXR5cGVzIiwidG1wU2V0IiwieXR5cGUiLCJ3YXJuIiwiYWRkVHJhY2tlZE9yaWdpbiIsInJlbW92ZVRyYWNrZWRPcmlnaW4iLCJjbGVhclVuZG9TdGFjayIsImNsZWFyUmVkb1N0YWNrIiwiY2FuVW5kbyIsImNhblJlZG8iLCJ1bmRvU3RhY2tDbGVhcmVkIiwicmVkb1N0YWNrQ2xlYXJlZCIsInVuZG8iLCJyZWRvIiwibGF6eVN0cnVjdFJlYWRlckdlbmVyYXRvciIsImZpbHRlclNraXBzIiwiZ2VuIiwiZG9uZSIsImxvZ1VwZGF0ZSIsImxvZ1VwZGF0ZVYyIiwiZGVjb2RlVXBkYXRlIiwiZGVjb2RlVXBkYXRlVjIiLCJMYXp5U3RydWN0V3JpdGVyIiwiY3VyckNsaWVudCIsIndyaXR0ZW4iLCJjbGllbnRTdHJ1Y3RzIiwiZW5jb2RlU3RhdGVWZWN0b3JGcm9tVXBkYXRlVjIiLCJZRW5jb2RlciIsInN0b3BDb3VudGluZyIsImN1cnJDbG9jayIsImVuYyIsIndyaXRlQmluYXJ5RW5jb2RlciIsImVuY29kZVN0YXRlVmVjdG9yRnJvbVVwZGF0ZSIsInBhcnNlVXBkYXRlTWV0YVYyIiwidG8iLCJwYXJzZVVwZGF0ZU1ldGEiLCJzbGljZVN0cnVjdCIsImxlZnRJdGVtIiwicmlnaHRPcmlnaW4iLCJ1cGRhdGVEZWNvZGVycyIsImxhenlTdHJ1Y3REZWNvZGVycyIsImN1cnJXcml0ZSIsInVwZGF0ZUVuY29kZXIiLCJsYXp5U3RydWN0RW5jb2RlciIsImRlYyIsImRlYzEiLCJkZWMyIiwiY2xvY2tEaWZmIiwiY3VyckRlY29kZXIiLCJmaXJzdENsaWVudCIsIml0ZXJhdGVkIiwid3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIiLCJmaW5pc2hMYXp5U3RydWN0V3JpdGluZyIsImxhenlTdHJ1Y3RXcml0ZXIiLCJyZWFkZXIiLCJzdkNsb2NrIiwiZGlmZlVwZGF0ZSIsImZsdXNoTGF6eVN0cnVjdFdyaXRlciIsImxhenlXcml0ZXIiLCJwYXJ0U3RydWN0cyIsImNvbnZlcnRVcGRhdGVGb3JtYXQiLCJibG9ja1RyYW5zZm9ybWVyIiwiY3JlYXRlT2JmdXNjYXRvciIsImZvcm1hdHRpbmciLCJ5eG1sIiwibWFwS2V5Q2FjaGUiLCJub2RlTmFtZUNhY2hlIiwiZm9ybWF0dGluZ0tleUNhY2hlIiwiZm9ybWF0dGluZ1ZhbHVlQ2FjaGUiLCJibG9jayIsIkNvbnRlbnREZWxldGVkIiwibm9kZU5hbWUiLCJZWG1sSG9vayIsImhvb2tOYW1lIiwiQ29udGVudEFueSIsImFyciIsIkNvbnRlbnRCaW5hcnkiLCJDb250ZW50RG9jIiwiQ29udGVudEVtYmVkIiwiQ29udGVudEZvcm1hdCIsIkNvbnRlbnRKU09OIiwiQ29udGVudFN0cmluZyIsInN0ciIsInJlcGVhdCIsIm9iZnVzY2F0ZVVwZGF0ZSIsIm9iZnVzY2F0ZVVwZGF0ZVYyIiwiY29udmVydFVwZGF0ZUZvcm1hdFYxVG9WMiIsImVycm9yQ29tcHV0ZUNoYW5nZXMiLCJZRXZlbnQiLCJfY2hhbmdlcyIsIl9rZXlzIiwiX2RlbHRhIiwiZ2V0UGF0aFRvIiwiYWN0aW9uIiwib2xkVmFsdWUiLCJhZGRzIiwicHJldiIsImxhc3QiLCJkZWx0YSIsInBhY2tPcCIsImluc2VydCIsImNvbmNhdCIsInJldGFpbiIsInVuc2hpZnQiLCJ3YXJuUHJlbWF0dXJlQWNjZXNzIiwibWF4U2VhcmNoTWFya2VyIiwiZ2xvYmFsU2VhcmNoTWFya2VyVGltZXN0YW1wIiwiQXJyYXlTZWFyY2hNYXJrZXIiLCJwIiwibWFya2VyIiwidGltZXN0YW1wIiwicmVmcmVzaE1hcmtlclRpbWVzdGFtcCIsIm92ZXJ3cml0ZU1hcmtlciIsIm1hcmtQb3NpdGlvbiIsInNlYXJjaE1hcmtlciIsInJlZHVjZSIsInBtIiwiZmluZE1hcmtlciIsInlhcnJheSIsImFicyIsInBpbmRleCIsInVwZGF0ZU1hcmtlckNoYW5nZXMiLCJnZXRUeXBlQ2hpbGRyZW4iLCJjYWxsVHlwZU9ic2VydmVycyIsImNoYW5nZWRUeXBlIiwiX2VIIiwieSIsIl9jb3B5IiwibWV0aG9kVW5pbXBsZW1lbnRlZCIsImNsb25lIiwiX3dyaXRlIiwiX2VuY29kZXIiLCJfZmlyc3QiLCJfcGFyZW50U3VicyIsIm9ic2VydmVEZWVwIiwidW5vYnNlcnZlIiwidW5vYnNlcnZlRGVlcCIsInR5cGVMaXN0U2xpY2UiLCJzdGFydCIsImVuZCIsImNzIiwidHlwZUxpc3RUb0FycmF5IiwidHlwZUxpc3RUb0FycmF5U25hcHNob3QiLCJ0eXBlTGlzdEZvckVhY2giLCJ0eXBlTGlzdE1hcCIsInR5cGVMaXN0Q3JlYXRlSXRlcmF0b3IiLCJjdXJyZW50Q29udGVudCIsImN1cnJlbnRDb250ZW50SW5kZXgiLCJTeW1ib2wiLCJ0eXBlTGlzdEdldCIsInR5cGVMaXN0SW5zZXJ0R2VuZXJpY3NBZnRlciIsInJlZmVyZW5jZUl0ZW0iLCJvd25DbGllbnRJZCIsImpzb25Db250ZW50IiwicGFja0pzb25Db250ZW50IiwiTnVtYmVyIiwiT2JqZWN0IiwiQm9vbGVhbiIsIlN0cmluZyIsIkFycmF5QnVmZmVyIiwibGVuZ3RoRXhjZWVkZWQiLCJ0eXBlTGlzdEluc2VydEdlbmVyaWNzIiwic3RhcnRJbmRleCIsInR5cGVMaXN0UHVzaEdlbmVyaWNzIiwibWF4TWFya2VyIiwiY3Vyck1hcmtlciIsInR5cGVMaXN0RGVsZXRlIiwic3RhcnRMZW5ndGgiLCJ0eXBlTWFwRGVsZXRlIiwidHlwZU1hcFNldCIsInR5cGVNYXBHZXQiLCJ2YWwiLCJ0eXBlTWFwR2V0QWxsIiwidHlwZU1hcEhhcyIsInR5cGVNYXBHZXRTbmFwc2hvdCIsInYiLCJ0eXBlTWFwR2V0QWxsU25hcHNob3QiLCJjcmVhdGVNYXBJdGVyYXRvciIsIml0ZXJhdG9yRmlsdGVyIiwiZW50cnkiLCJZQXJyYXlFdmVudCIsIl9wcmVsaW1Db250ZW50IiwiaXRlbXMiLCJ0b0FycmF5IiwiZWwiLCJwYXJlbnRTdWJzIiwiWUFycmF5UmVmSUQiLCJyZWFkWUFycmF5IiwiX2RlY29kZXIiLCJZTWFwRXZlbnQiLCJ5bWFwIiwiaXRlcmF0b3JNYXAiLCJ2YWx1ZXMiLCJfdmFsdWUiLCJZTWFwUmVmSUQiLCJyZWFkWU1hcCIsImVxdWFsQXR0cnMiLCJlcXVhbEZsYXQiLCJJdGVtVGV4dExpc3RQb3NpdGlvbiIsImN1cnJlbnRBdHRyaWJ1dGVzIiwiZm9yd2FyZCIsInVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzIiwiZmluZE5leHRQb3NpdGlvbiIsImNvdW50IiwiZmluZFBvc2l0aW9uIiwidXNlU2VhcmNoTWFya2VyIiwiaW5zZXJ0TmVnYXRlZEF0dHJpYnV0ZXMiLCJjdXJyUG9zIiwibmVnYXRlZEF0dHJpYnV0ZXMiLCJuZXh0Rm9ybWF0IiwiZm9ybWF0IiwibWluaW1pemVBdHRyaWJ1dGVDaGFuZ2VzIiwiYXR0cmlidXRlcyIsImluc2VydEF0dHJpYnV0ZXMiLCJjdXJyZW50VmFsIiwiaW5zZXJ0VGV4dCIsInRleHQiLCJfdmFsIiwiZ2V0TGVuZ3RoIiwiZm9ybWF0VGV4dCIsIml0ZXJhdGlvbkxvb3AiLCJhdHRyIiwibmV3bGluZXMiLCJjbGVhbnVwRm9ybWF0dGluZ0dhcCIsInN0YXJ0QXR0cmlidXRlcyIsImN1cnJBdHRyaWJ1dGVzIiwiZW5kRm9ybWF0cyIsImNmIiwiY2xlYW51cHMiLCJyZWFjaGVkQ3VyciIsInN0YXJ0QXR0clZhbHVlIiwiY2xlYW51cENvbnRleHRsZXNzRm9ybWF0dGluZ0dhcCIsImF0dHJzIiwiY2xlYW51cFlUZXh0Rm9ybWF0dGluZyIsImNvcHkiLCJuZWVkRnVsbENsZWFudXAiLCJhZnRlckNsb2NrIiwiX2hhc0Zvcm1hdHRpbmciLCJ5VGV4dCIsImRlbGV0ZVRleHQiLCJzdGFydEF0dHJzIiwiWVRleHRFdmVudCIsInl0ZXh0IiwiY2hpbGRMaXN0Q2hhbmdlZCIsInN1YiIsIm9sZEF0dHJpYnV0ZXMiLCJkZWxldGVMZW4iLCJhZGRPcCIsIm9wIiwiaXNFbXB0eSIsImFzc2lnbiIsImN1clZhbCIsIl9wZW5kaW5nIiwiZSIsImFwcGx5RGVsdGEiLCJ0b0RlbHRhIiwidG9TdHJpbmciLCJzYW5pdGl6ZSIsImlucyIsInByZXZTbmFwc2hvdCIsImNvbXB1dGVZQ2hhbmdlIiwib3BzIiwicGFja1N0ciIsImFkZEF0dHJpYnV0ZXMiLCJjb21wdXRlRGVsdGEiLCJjdXIiLCJrIiwiaW5zZXJ0RW1iZWQiLCJyZW1vdmVBdHRyaWJ1dGUiLCJhdHRyaWJ1dGVOYW1lIiwic2V0QXR0cmlidXRlIiwiYXR0cmlidXRlVmFsdWUiLCJnZXRBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGVzIiwiWVRleHRSZWZJRCIsInJlYWRZVGV4dCIsIllYbWxUcmVlV2Fsa2VyIiwicm9vdCIsIl9maWx0ZXIiLCJfcm9vdCIsIl9jdXJyZW50Tm9kZSIsIl9maXJzdENhbGwiLCJueHQiLCJmaXJzdENoaWxkIiwiZmlyc3QiLCJjcmVhdGVUcmVlV2Fsa2VyIiwicXVlcnlTZWxlY3RvciIsInF1ZXJ5IiwidG9VcHBlckNhc2UiLCJlbGVtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsIllYbWxFdmVudCIsInhtbCIsImpvaW4iLCJ0b0RPTSIsIl9kb2N1bWVudCIsImRvY3VtZW50IiwiaG9va3MiLCJiaW5kaW5nIiwiZnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiX2NyZWF0ZUFzc29jaWF0aW9uIiwieG1sVHlwZSIsImluc2VydEJlZm9yZSIsImluc2VydEFmdGVyIiwicmVmIiwicmVmSXRlbSIsInBjIiwiZmluZEluZGV4IiwiWVhtbEZyYWdtZW50UmVmSUQiLCJyZWFkWVhtbEZyYWdtZW50IiwiX3ByZWxpbUF0dHJzIiwibmV4dFNpYmxpbmciLCJwcmV2U2libGluZyIsInN0cmluZ0J1aWxkZXIiLCJrZXlzTGVuIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJhdHRyc1N0cmluZyIsImhhc0F0dHJpYnV0ZSIsImRvbSIsImNyZWF0ZUVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsIllYbWxFbGVtZW50UmVmSUQiLCJyZWFkWVhtbEVsZW1lbnQiLCJhdHRyaWJ1dGVzQ2hhbmdlZCIsImhvb2siLCJjcmVhdGVEb20iLCJZWG1sSG9va1JlZklEIiwicmVhZFlYbWxIb29rIiwiWVhtbFRleHQiLCJjcmVhdGVUZXh0Tm9kZSIsIm5lc3RlZE5vZGVzIiwibm9kZSIsIllYbWxUZXh0UmVmSUQiLCJyZWFkWVhtbFRleHQiLCJBYnN0cmFjdFN0cnVjdCIsImVuY29kaW5nUmVmIiwic3RydWN0R0NSZWZOdW1iZXIiLCJpc0NvdW50YWJsZSIsImdldFJlZiIsInJlYWRDb250ZW50QmluYXJ5IiwibWFya0RlbGV0ZWQiLCJyZWFkQ29udGVudERlbGV0ZWQiLCJjcmVhdGVEb2NGcm9tT3B0cyIsInJlYWRDb250ZW50RG9jIiwicmVhZENvbnRlbnRFbWJlZCIsIl9vZmZzZXQiLCJfcmlnaHQiLCJyZWFkQ29udGVudEZvcm1hdCIsInJlYWRDb250ZW50SlNPTiIsImlzRGV2TW9kZSIsImdldFZhcmlhYmxlIiwiZGVlcEZyZWV6ZSIsInJlYWRDb250ZW50QW55Iiwic3BsaXQiLCJmaXJzdENoYXJDb2RlIiwiY2hhckNvZGVBdCIsInJlYWRDb250ZW50U3RyaW5nIiwidHlwZVJlZnMiLCJyZWFkQ29udGVudFR5cGUiLCJuZXh0SUQiLCJyaWdodEl0ZW0iLCJpc0RlbGV0ZWRCeVVuZG9TdGFjayIsInJlZG9pdGVtcyIsIm93bkNsaWVudElEIiwicGFyZW50SXRlbSIsInBhcmVudFR5cGUiLCJsZWZ0VHJhY2UiLCJyaWdodFRyYWNlIiwibmV4dENsb2NrIiwibmV4dElkIiwicmVkb25lSXRlbSIsIkJJVDIiLCJpc01hcmtlZCIsIkJJVDQiLCJCSVQxIiwiZG9LZWVwIiwiQklUMyIsImRvRGVsZXRlIiwibyIsImNvbmZsaWN0aW5nSXRlbXMiLCJpdGVtc0JlZm9yZU9yaWdpbiIsInIiLCJwYXJlbnRHQ2QiLCJ5a2V5IiwiY29udGVudFJlZnMiLCJzdHJ1Y3RTa2lwUmVmTnVtYmVyIiwiZ2xvIiwiZ2xvYmFsVGhpcyIsIndpbmRvdyIsImdsb2JhbCIsImltcG9ydElkZW50aWZpZXIiLCJUZXh0IiwiWG1sRWxlbWVudCIsIlhtbEZyYWdtZW50IiwiWG1sSG9vayIsIlhtbFRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/yjs/dist/yjs.mjs\n");

/***/ })

};
;